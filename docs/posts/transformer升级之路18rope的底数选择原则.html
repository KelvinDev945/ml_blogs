<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer升级之路：18、RoPE的底数选择原则 | ML & Math Blog Posts</title>
    <meta name="description" content="Transformer升级之路：18、RoPE的底数选择原则&para;
原文链接: https://spaces.ac.cn/archives/10122
发布日期: 

我们知道，在RoPE中频率的计算公式为$\theta_i = b^{-2i/d}$，底数$b$默认值为10000。目前Long Context的主流做法之一是，先在$b=10000$上用短文本预训练，然后调大$b$并在长文本微...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=不等式">不等式</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #144 Transformer升级之路：18、RoPE的底数选择原则
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#144</span>
                Transformer升级之路：18、RoPE的底数选择原则
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> 2024-05-29</span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=不等式" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 不等式</span>
                </a>
                
                <a href="../index.html?tags=attention" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> attention</span>
                </a>
                
                <a href="../index.html?tags=位置编码" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 位置编码</span>
                </a>
                
                <a href="../index.html?tags=rope" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> rope</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="transformer18rope">Transformer升级之路：18、RoPE的底数选择原则<a class="toc-link" href="#transformer18rope" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/10122">https://spaces.ac.cn/archives/10122</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>我们知道，在<a href="/archives/8265">RoPE</a>中频率的计算公式为$\theta_i = b^{-2i/d}$，底数$b$默认值为10000。目前Long Context的主流做法之一是，先在$b=10000$上用短文本预训练，然后调大$b$并在长文本微调，其出发点是<a href="/archives/9675">《Transformer升级之路：10、RoPE是一种β进制编码》</a>里介绍的NTK-RoPE，它本身有较好长度外推性，换用更大的$b$再微调相比不加改动的微调，起始损失更小，收敛也更快。该过程给人的感觉是：调大$b$完全是因为“先短后长”的训练策略，如果一直都用长文本训练似乎就没必要调大$b$了？</p>
<p>上周的论文<a href="https://papers.cool/arxiv/2405.14591">《Base of RoPE Bounds Context Length》</a>试图回答这个问题，它基于一个期望性质研究了$b$的下界，由此指出更大的训练长度本身就应该选择更大的底数，与训练策略无关。整个分析思路颇有启发性，接下来我们一起来品鉴一番。</p>
<h2 id="_1">期望性质<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h2>
<p>RoPE这里就不再详细介绍了，它本质上是一个分块对角矩阵<br />
\begin{equation}\boldsymbol{\mathcal{R}}<em d_2-1="d/2-1">n = \scriptsize{\left(\begin{array}{cc:cc:cc:cc}<br />
\cos n\theta_0 &amp; -\sin n\theta_0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cdots &amp; 0 &amp; 0 \\<br />
\sin n\theta_0 &amp; \cos n\theta_0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cdots &amp; 0 &amp; 0 \\<br />
\hdashline<br />
0 &amp; 0 &amp; \cos n\theta_1 &amp; -\sin n\theta_1 &amp; \cdots &amp; \cdots &amp; 0 &amp; 0 \\<br />
0 &amp; 0 &amp; \sin n\theta_1 &amp; \cos n\theta_1 &amp; \cdots &amp; \cdots &amp; 0 &amp; 0 \\<br />
\hdashline<br />
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \ddots &amp; \vdots &amp; \vdots \\<br />
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \ddots &amp; \vdots &amp; \vdots \\<br />
\hdashline<br />
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cdots &amp; \cos n\theta</em> \\} &amp; -\sin n\theta_{d/2-1<br />
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; \cdots &amp; \sin n\theta_{d/2-1} &amp; \cos n\theta_{d/2-1} \\<br />
\end{array}\right)}\end{equation}<br />
然后利用恒等式<br />
\begin{equation}(\boldsymbol{\mathcal{R}}<em n-m="n-m">m \boldsymbol{q})^{\top}(\boldsymbol{\mathcal{R}}_n \boldsymbol{k}) = \boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}}_m^{\top}\boldsymbol{\mathcal{R}}_n \boldsymbol{k} = \boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}}</em>} \boldsymbol{k}\end{equation<br />
给$\boldsymbol{q},\boldsymbol{k}$注入绝对位置信息，并自动实现了相对位置的效果。其中$\theta_i = b^{-2i/d}$，这里的$b$的取值就是本文要探讨的问题。</p>
<p>除了给模型注入位置信息外，我们期望RoPE能具备两个理想性质，以达到更好的效果：1、<strong>远程衰减</strong> ，即位置相近的Token平均来说获得更多的注意力；2、<strong>语义聚合</strong> ，即语义相似的Token平均来说获得更多的注意力。其中第一点我们早在<a href="/archives/8265">《Transformer升级之路：2、博采众长的旋转式位置编码》</a>有过相关讨论，RoPE确实有一定的远程衰减性质。</p>
<p>所以接下来我们来分析第二点。</p>
<h2 id="_2">不等关系<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>所谓语义聚合，指的是当$\boldsymbol{k}$与$\boldsymbol{q}$相近时，不管它们的相对距离$n-m$多大，其注意力$\boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}}_{n-m} \boldsymbol{k}$平均来说都应该更大（至少要比随机的两个Token更大）。为了得到一个量化的结论，我们进一步简化问题，假设$\boldsymbol{q}$的每个分量都是独立同分布的，每个分量的均值为$\mu$，方差为$\sigma^2$。</p>
<p>现在我们考虑两种不同的$\boldsymbol{k}$：一种是在$\boldsymbol{q}$的基础上，加上一个零均值的扰动$\boldsymbol{\varepsilon}$，我们记$\tilde{\boldsymbol{k}} = \boldsymbol{q} + \boldsymbol{\varepsilon}$，代表跟$\boldsymbol{q}$语义相近的Token；另一种则是假设$\boldsymbol{k}$跟$\boldsymbol{q}$独立同分布，这代表两个随机的Token。根据第二点理想性质，我们希望有<br />
\begin{equation}\mathbb{E}<em n-m="n-m">{\boldsymbol{q},\boldsymbol{k},\boldsymbol{\varepsilon}}\big[\boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}}</em>} \tilde{\boldsymbol{k}} - \boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}<em _boldsymbol_q="\boldsymbol{q">{n-m} \boldsymbol{k}\big] \geq 0\end{equation}<br />
注意我们刚才反复强调了“平均来说”，意味着我们只是期望一个平均的趋势，而不是每一点都能严格成立，所以我们在上式加了取数学期望$\mathbb{E}</em>$。现在根据假设和RoPE的定义，我们可以把上式具体地算出来：},\boldsymbol{k},\boldsymbol{\varepsilon}<br />
\begin{equation}\begin{aligned}<br />
&amp;\,\mathbb{E}<em n-m="n-m">{\boldsymbol{q},\boldsymbol{k},\boldsymbol{\varepsilon}}\big[\boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}}</em>} (\boldsymbol{q} + \boldsymbol{\varepsilon}) - \boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}<em _boldsymbol_q="\boldsymbol{q">{n-m} \boldsymbol{k}\big] \\[5pt]<br />
=&amp;\, \mathbb{E}</em>}}\big[\boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}<em _boldsymbol_q="\boldsymbol{q">{n-m} \boldsymbol{q}\big] - \mathbb{E}</em>},\boldsymbol{k}}\big[\boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}<em _boldsymbol_q="\boldsymbol{q">{n-m} \boldsymbol{k}\big] \\[5pt]<br />
=&amp;\, \mathbb{E}</em>}}\big[\boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}<em _boldsymbol_q="\boldsymbol{q">{n-m} \boldsymbol{q}\big] - \mathbb{E}</em>}}[\boldsymbol{q}]^{\top}\boldsymbol{\mathcal{R}<em _boldsymbol_k="\boldsymbol{k">{n-m} \mathbb{E}</em>] \\[5pt]}}[\boldsymbol{k<br />
=&amp;\, \mathbb{E}<em n-m="n-m">{\boldsymbol{q}}\big[\boldsymbol{q}^{\top} \boldsymbol{\mathcal{R}}</em>} \boldsymbol{q}\big] - \mu^2\boldsymbol{1}^{\top}\boldsymbol{\mathcal{R}<em _boldsymbol_q="\boldsymbol{q">{n-m} \boldsymbol{1} \\[5pt]<br />
=&amp; \mathbb{E}</em> 2\mu^2\cos (n-m)\theta_i \\[5pt]}}\left[\sum_{i=0}^{d/2-1} (q_{2i}^2 + q_{2i+1}^2)\cos (n-m)\theta_i\right] - \sum_{i=0}^{d/2-1<br />
=&amp; \sum_{i=0}^{d/2-1} 2(\mu^2 + \sigma^2)\cos (n-m)\theta_i - \sum_{i=0}^{d/2-1} 2\mu^2\cos (n-m)\theta_i \\[5pt]<br />
=&amp; \sum_{i=0}^{d/2-1} 2\sigma^2\cos (n-m)\theta_i \\<br />
\end{aligned}\end{equation}<br />
如果训练长度最大为$L$，那么$n-m\leq L-1$，因此第二点理想性质可以用如下不等式近似描述：<br />
\begin{equation}\sum_{i=0}^{d/2-1} \cos m\theta_i \geq 0,\quad m\in\{0,1,2,\cdots,L-1\}\label{neq:base}\end{equation}<br />
其中$L$是最大长度，是训练前就要选定的超参，而$d$是模型的head_size，按照LLAMA的一般设置是$d=128$，这也就意味着，上式的唯一可调参数就是$\theta_i = b^{-2i/d}$中的$b$。在<a href="/archives/8231">《Transformer升级之路：1、Sinusoidal位置编码追根溯源》</a>中我们就简单探究过这个函数，它整体趋势是衰减的，$b$越大则衰减速度越慢，对应的连续非负区间就越大，所以存在一个最小的$b$使得上述不等式恒成立，即<br />
\begin{equation}b^* = \inf\left\{\,\,b\,\,\,\left|\,\,\,f_b(m)\triangleq\sum_{i=0}^{d/2-1} \cos m b^{-2i/d} \geq 0,\,\, m\in\{0,1,2,\cdots,L-1\}\right.\right\}\end{equation}</p>
<h2 id="_3">数值求解<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>由于$f_b(m)$涉及到多个三角函数的求和，并且$\theta_i$关于$i$还是非线性的，很难想象上述问题会有解析解，因此只能诉诸数值求解了。然而，$f_b(m)$越到后面震荡越频繁且不规律，因此即便数值求解也不是那么简单的事情。</p>
<p>笔者一开始以为，如果$b_0$使得$f_{b_0}(m)\geq 0$恒成立，那么$\forall b \geq b_0$都恒成立$f_b(m)\geq 0$，所以用二分法就可以了。但事实上这个假设并不成立，所以二分法宣告破产。继续想了一段时间，依然没什么优化思路，期间向原论文作者请教过，他们采用的是逆函数法，即给定$b$求使得$f_b(m)\geq 0$恒成立的最大$L$是比较简单的，于是我们可以得到很多$(b, L)$对，理论上只要枚举的$b$足够多，那么对于任意$L$都可以找出最小的$b$。然而这里有个精度问题，原论文最大的$L$计算到了$10^6$，$b$至少要枚举到$10^8$，如果枚举间隔小，那么计算成本非常大，如果枚举间隔大，那么可能漏掉很多解。</p>
<p>最后，笔者决定还是用“Jax + GPU”进行暴力搜索，以求得到更高精度的结果，大致流程是：</p>
<blockquote>
<p>1、初始化$b=1000L$（在$10^6$内$b=1000L$可以使得$f_b(m)\geq 0$恒成立）；</p>
<p>2、遍历$k=1,2,3,4,5$，执行以下操作：</p>
<p>2.1）将$[0,b]$等分为$10^k$份，遍历等分点，判断$f_b(m)\geq 0$是否恒成立；</p>
<p>2.2）取最小的使得$f_b(m)\geq 0$恒成立的等分点，更新$b$；</p>
<p>3、返回最终的$b$。</p>
</blockquote>
<p>最终结果普遍要比原论文的更紧一些<br />
$$\scriptsize\begin{array}{c|cccccccccc}<br />
\hline<br />
L &amp; 1k &amp; 2k &amp; 4k &amp; 8k &amp; 16k &amp; 32k &amp; 64k &amp; 128k &amp; 256k &amp; 512k &amp; 1M \\<br />
\hline<br />
b^<em>(\text{原文}) &amp; 4.3e3 &amp; 1.6e4 &amp; 2.7e4 &amp; 8.4e4 &amp; 3.1e5 &amp; 6.4e5 &amp; 2.1e6 &amp; 7.8e6 &amp; 3.6e7 &amp; 6.4e7 &amp; 5.1e8 \\<br />
b^</em>(\text{本文}) &amp; 4.3e3 &amp; \color{red}{1.2e4} &amp; 2.7e4 &amp; 8.4e4 &amp; \color{red}{2.3e5} &amp; \color{red}{6.3e5} &amp; 2.1e6 &amp; \color{red}{4.9e6} &amp; \color{red}{2.4e7} &amp; \color{red}{5.8e7} &amp; \color{red}{6.5e7} \\<br />
\hline<br />
\end{array}$$</p>
<p>参考代码：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="kp">arange</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="kp">cos</span><span class="p">(</span><span class="n">m</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="kp">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nd">@np</span><span class="o">.</span><span class="kp">vectorize</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fmin</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="kp">arange</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="kp">min</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">bmin</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="n">B</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">L</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">B</span>  
        <span class="n">ys</span> <span class="o">=</span> <span class="n">fmin</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">bs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">b</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">B</span>

<span class="n">bmin</span><span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">128</span><span class="p">)</span>
</code></pre></div>

<h2 id="_4">渐近估计<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h2>
<p>除了数值求解外，我们也可以通过渐近分析来得到一个解析的估计结果，这个估计比数值结果要小，本质上是$d\to\infty$的解，但同样能够得出“$b$应该随着$L$增大而增大”的结论。</p>
<p>渐近估计的思路，是用积分代替求和：<br />
\begin{equation}f_b(m) = \sum_{i=0}^{d/2-1} \cos m b^{-2i/d}\approx \int_0^1 \cos m b^{-s} ds \xlongequal{\text{令}t = mb^{-s}} \int_{mb^{-1}}^m \frac{\cos t}{t \ln b}dt\end{equation}<br />
其中我们记<br />
\begin{equation}\text{Ci}(x) = -\int_x^{\infty} \frac{\cos t}{t} dt\end{equation}<br />
这是被前人研究过的三角积分（参考 <a href="https://en.wikipedia.org/wiki/Trigonometric_integral">Trigonometric integral</a> ），利用这个记号，我们可以写出<br />
\begin{equation}f_b(m) \approx \frac{\text{Ci}(m) - \text{Ci}(mb^{-1})}{\ln b}\end{equation}<br />
$\text{Ci}(x)$的图像长这样：  </p>
<p><a href="/usr/uploads/2024/05/3588196127.png" title="点击查看原图"><img alt="Ci(x)的图像【来自维基百科】" src="/usr/uploads/2024/05/3588196127.png" /></a></p>
<p>Ci(x)的图像【来自维基百科】</p>
<p>它的第一个零点是$x_0=0.6165\cdots$，对于$m\geq 1$，可以看出$|\text{Ci}(m)|\leq 1/2$，所以其实$\text{Ci}(m)$相对来说是小项，对于渐近估计来说可以忽略，那么问题近似地变成了$\text{Ci}(mb^{-1})\leq 0$对于$m=1,2,\cdots,L$恒成立，我们只需要让相应的$mb^{-1}$都落在$[0,x_0]$区间内就可以实现，这意味着$Lb^{-1}\leq x_0$，即<br />
\begin{equation}b \geq L / x_0 \approx 2L\end{equation}<br />
或者简单点$b^* = \mathcal{O}(L)$。不出意料这个结果比精确的数值结果要小，因为它对应于$d\to\infty$，无限个三角函数叠加会使得函数图像的震荡更少，看起来更加平稳（相比于有限的$d$），从而对于固定的$b$，$f_b(m)$的连续非负区间更长，或者反过来，对于固定的$L$，保持$m=0,1,2,\cdots,L-1$的$f_b(m)$都非负的$b$更小。</p>
<h2 id="_5">相关思考<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h2>
<p>在<a href="/archives/9675">《Transformer升级之路：10、RoPE是一种β进制编码》</a>中，我们将RoPE类比为一种$\beta$进制表示，其中$\beta = b^{2/d}$，那么$b - 1= \beta^{d/2} - 1$正好是$d/2$位$\beta$进制编码能够表示的最大数字，于是要表示$0,1,2,\cdots,L-1$这$L$个位置编码，至少有$b \geq L$，这个朴素的类比再次给出了“$b$应该随着$L$增大而增大”的结论，其结果跟上一节的渐近分析结果更为接近。</p>
<p>另一方面，Meta最新发布的LLAMA3，训练长度为8192，但RoPE的底数选择了惊人的500000（5e5），这比前面的数值结果（8.4e4）还要大将近一个数量级，不管从哪个角度看，这个数值笔者都认为是偏大的，可能LLAMA3的这个底数本就是给更大文本长度预留的。但不论如何，更大的文本长度选择更大的RoPE底数，似乎已经成为了很多训练人员的共识。</p>
<p>其实不管是数值结果还是渐近估计，都只是一个参考值，实际上对于给定的$L$，一个相当大范围内的$b$都应该会有相近的效果。所以具体的数值都不重要，关键是原论文通过语义聚合的出发点和一系列推导，澄清了“$b$应该随着$L$增大而增大”的结论及其原理，这是笔者所认为的原论文的核心贡献。</p>
<p>此外，其实语义聚合的出发点和结论也可以用来解释<a href="https://papers.cool/arxiv/2306.15595">Position Interpolation</a>（PI）。刚才我们说了，同一个$b$，$f_b(m)$的连续非负区间是固定的，如果要使$0,1,2,\cdots,L-1$都落在非负区间内，就需要随着$L$的增大而相应的增加$b$。但反过来，我们也可以不增加$b$，而是减少相邻位置的间隔（即位置ID改成$0,1/k,2/k,\cdots$），那么就可以在同样大小的非负区间内表示$k$倍的位置了，这便是语义聚合视角下的Position Interpolation。</p>
<h2 id="_6">部分旋转<a class="toc-link" href="#_6" title="Permanent link">&para;</a></h2>
<p>RoPE提出于2021年，当时只有一篇中文博客，后来得到了EleutherAI组织的认可和实验，继而才逐渐向学术界推广。当时EleutherAI实验发现，如果只对部分维度加RoPE，会取得稍优的结果，相关内容可以参考<a href="https://github.com/lucidrains/x-transformers/issues/40">这里</a>、<a href="https://wandb.ai/eleutherai/neox/reports/Partial-Rotary-Tests--Vmlldzo2MjE1MjY">这里</a>和<a href="https://wandb.ai/eleutherai/neox/reports/Partial-Rotary-Tests-v2--Vmlldzo2MjE4MTQ">这里</a>，后来这个操作用到了它们的<a href="https://github.com/EleutherAI/gpt-neox/blob/8b43196fbd832b797be9f3d88d54481171010507/megatron/model/transformer.py#L908">GPT-NeoX</a>中。</p>
<p>当然，部分旋转还不是当前LLM的主流选择，但这不妨碍我们研究它，也许它未成为主流选择只是因为我们对它还不够了解。那为什么部分旋转反而可能会更优呢？笔者发现可以用本文的结论来一定程度上解释它。以只旋转一半维度为例，它在数学上等价于选择如下的$\theta_i$：<br />
\begin{equation}\theta_i = \left\{\begin{aligned}&amp;b^{-4i/d},&amp; i &lt; d/4 \\<br />
&amp;0,&amp;i \geq d/4\end{aligned}\right.\end{equation}<br />
此时我们有<br />
\begin{equation}\sum_{i=0}^{d/2-1} \cos m\theta_i = \sum_{i=0}^{d/4-1} (1+\cos mb^{-4i/d})\geq 0\end{equation}<br />
也就是不论$m,b$如何，我们所期望的不等式$\eqref{neq:base}$都自动成立，这意味着从本文的观点来看，部分旋转在赋予位置信息的同时有更好的语义聚合能力，这对模型的效果也许更加有利。同时，部分旋转对模型的长文本能力或许也更有利，因为不等式恒成立，所以按照本文的观点，不论长短文本训练都不用修改$b$。</p>
<p>值得一提的是，DeepSeek提出的<a href="/archives/10091">MLA</a>也应用了部分旋转，虽然在MLA的原始推导中，部分旋转更多是为了整合RoPE的无奈之举，但结合以往的部分旋转实验结果来看，也许MLA的优异效果有部分旋转的一分功劳。</p>
<h2 id="_7">文章小结<a class="toc-link" href="#_7" title="Permanent link">&para;</a></h2>
<p>本文简单介绍了论文<a href="https://papers.cool/arxiv/2405.14591">《Base of RoPE Bounds Context Length》</a>，它从语义聚合的期望性质讨论了RoPE的底数下界，由此指出更大的训练长度应该选择更大的底数，而不单单是为了配合“先短后长”的训练策略、继而利用NTK-RoPE来降低初始损失的折中选择。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/10122">https://spaces.ac.cn/archives/10122</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (May. 29, 2024). 《Transformer升级之路：18、RoPE的底数选择原则 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/10122">https://spaces.ac.cn/archives/10122</a></p>
<p>@online{kexuefm-10122,<br />
title={Transformer升级之路：18、RoPE的底数选择原则},<br />
author={苏剑林},<br />
year={2024},<br />
month={May},<br />
url={\url{https://spaces.ac.cn/archives/10122}},<br />
} </p>
<hr />
<h2 id="_8">公式推导与注释<a class="toc-link" href="#_8" title="Permanent link">&para;</a></h2>
<p>TODO: 添加详细的数学公式推导和注释</p>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="重温ssm一线性系统和hippo矩阵.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#143 重温SSM（一）：线性系统和HiPPO矩阵</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="重温ssm二hippo的一些遗留问题.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#145 重温SSM（二）：HiPPO的一些遗留问题</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#transformer18rope">Transformer升级之路：18、RoPE的底数选择原则</a><ul>
<li><a href="#_1">期望性质</a></li>
<li><a href="#_2">不等关系</a></li>
<li><a href="#_3">数值求解</a></li>
<li><a href="#_4">渐近估计</a></li>
<li><a href="#_5">相关思考</a></li>
<li><a href="#_6">部分旋转</a></li>
<li><a href="#_7">文章小结</a></li>
<li><a href="#_8">公式推导与注释</a></li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>