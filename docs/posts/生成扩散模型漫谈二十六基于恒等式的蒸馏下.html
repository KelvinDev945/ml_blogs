<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生成扩散模型漫谈（二十六）：基于恒等式的蒸馏（下） | ML & Math Blog Posts</title>
    <meta name="description" content="生成扩散模型漫谈（二十六）：基于恒等式的蒸馏（下）&para;
原文链接: https://spaces.ac.cn/archives/10567
发布日期: 

继续回到我们的扩散系列。在《生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上）》中，我们介绍了SiD（Score identity Distillation），这是一种不需要真实数据、也不需要从教师模型采样的扩散模型蒸馏方案，其形式类似...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=生成模型">生成模型</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #171 生成扩散模型漫谈（二十六）：基于恒等式的蒸馏（下）
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#171</span>
                生成扩散模型漫谈（二十六）：基于恒等式的蒸馏（下）
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> 2024-11-22</span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
                <a href="../index.html?tags=梯度" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 梯度</span>
                </a>
                
                <a href="../index.html?tags=扩散" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 扩散</span>
                </a>
                
                <a href="../index.html?tags=去噪" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 去噪</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="_1">生成扩散模型漫谈（二十六）：基于恒等式的蒸馏（下）<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/10567">https://spaces.ac.cn/archives/10567</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>继续回到我们的扩散系列。在<a href="/archives/10085">《生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上）》</a>中，我们介绍了SiD（Score identity Distillation），这是一种不需要真实数据、也不需要从教师模型采样的扩散模型蒸馏方案，其形式类似GAN，但有着比GAN更好的训练稳定性。</p>
<p>SiD的核心是通过恒等变换来为学生模型构建更好的损失函数，这一点是开创性的，同时也遗留了一些问题。比如，SiD对损失函数的恒等变换是不完全的，如果完全变换会如何？如何从理论上解释SiD引入的$\lambda$的必要性？上个月放出的<a href="https://papers.cool/arxiv/2410.19310">《Flow Generator Matching》</a>（简称FGM）成功从更本质的梯度角度解释了$\lambda=0.5$的选择，而受到FGM启发，笔者则进一步发现了$\lambda = 1$的一种解释。</p>
<p>接下来我们将详细介绍SiD的上述理论进展。</p>
<h2 id="_2">思想回顾<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>根据上一篇文章的介绍，我们知道SiD实现蒸馏的思想是“相近的分布，它们训练出来的去噪模型也是相近的”，用公式表示就是<br />
\begin{align}<br />
&amp;\text{教师扩散模型:}\quad\boldsymbol{\varphi}^<em> = \mathop{\text{argmin}}<em _boldsymbol_x="\boldsymbol{x">{\boldsymbol{\varphi}} \mathbb{E}</em><em _boldsymbol_varphi="\boldsymbol{\varphi">0\sim \tilde{p}(\boldsymbol{x}_0),\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}</em> \\[8pt]}}(\boldsymbol{x}_t,t) - \boldsymbol{\varepsilon}\Vert^2\right]\label{eq:tloss<br />
&amp;\text{学生扩散模型:}\quad\boldsymbol{\psi}^</em> = \mathop{\text{argmin}}<em _boldsymbol_z="\boldsymbol{z">{\boldsymbol{\psi}} \mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{\psi}}(\boldsymbol{x}_t^{(g)},t) - \boldsymbol{\varepsilon}\Vert^2\right]\label{eq:dloss}\\[8pt]<br />
&amp;\text{学生生成模型:}\quad\boldsymbol{\theta}^<em> = \mathop{\text{argmin}}<em _boldsymbol_z="\boldsymbol{z">{\boldsymbol{\theta}} \underbrace{\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}_{\boldsymbol{\varphi</em>}(\boldsymbol{x}_t^{(g)},t) - \boldsymbol{\epsilon}</em>}^*}(\boldsymbol{x<em _mathcal_L="\mathcal{L">t^{(g)},t)\Vert^2\right]}</em><em _boldsymbol_theta="\boldsymbol{\theta">1}\label{eq:gloss-1}<br />
\end{align}<br />
这里记号比较多，我们逐一解释。第一个损失函数就是我们要蒸馏的扩散模型的训练目标，其中$\boldsymbol{x}_t = \bar{\alpha}_t\boldsymbol{x}_0 + \bar{\beta}_t\boldsymbol{\varepsilon}$代表加噪样本，$\bar{\alpha}_t,\bar{\beta}_t$是noise schedule，$\boldsymbol{x}_0$是训练样本；第二个损失函数则是用学生模型生成的数据来训练的扩散模型，其中$\boldsymbol{x}_t^{(g)}=\bar{\alpha}_t\boldsymbol{g}</em>}}(\boldsymbol{z}) + \bar{\beta<em _boldsymbol_theta="\boldsymbol{\theta">t\boldsymbol{\varepsilon}$，这里的$\boldsymbol{g}</em>$；第三个损失函数，则是试图通过拉近真实数据和学生数据所训练的扩散模型的差距，来训练学生生成模型（生成器）。}}(\boldsymbol{z})$代表学生模型的生成样本，也记为$\boldsymbol{x}_0^{(g)</p>
<p>这里的教师模型是可以提前训练好的，而两个学生模型的训练只需要教师模型本身，并不需要用到训练教师模型的数据，所以作为一种蒸馏方式来看SiD是data-free的；两个学生模型则是类似GAN那样的交替训练，逐步提高生成器的生成质量。就笔者所阅读过的文献来看，这种训练思想最早出自论文<a href="https://papers.cool/arxiv/2001.02728">《Learning Generative Models using Denoising Density Estimators》</a>，我们在<a href="/archives/7038">《从去噪自编码器到生成模型》</a>也有过相关介绍。</p>
<p>然而，尽管看上去没什么毛病，但实际情况是式$\eqref{eq:dloss}$和式$\eqref{eq:gloss-1}$的交替训练非常容易崩溃，以至于几乎不能出效果。这是因为理论和实践上的两个gap：</p>
<blockquote>
<p>1、理论上要求先求出式$\eqref{eq:dloss}$的最优解，然后才去优化式$\eqref{eq:gloss-1}$，但实际上从训练成本考虑，我们并没有将它训练到最优就去优化式$\eqref{eq:gloss-1}$了；</p>
<p>2、理论上$\boldsymbol{\psi}^<em>$随$\boldsymbol{\theta}$而变，即应该写成$\boldsymbol{\psi}^</em>(\boldsymbol{\theta})$，从而在优化式$\eqref{eq:gloss-1}$时应该多出一项$\boldsymbol{\psi}^<em>(\boldsymbol{\theta})$对$\boldsymbol{\theta}$的梯度，但实际上在优化式$\eqref{eq:gloss-1}$时我们都只当$\boldsymbol{\psi}^</em>$是常数。</p>
</blockquote>
<p>第1个问题其实还好，因为随着训练的推进$\boldsymbol{\psi}$总能慢慢逼近理论最优的$\boldsymbol{\psi}^*$，但第2个问题非常困难且本质，可以说GAN的训练不稳定性同样也有这个问题的“功劳”。而SiD和FGM的核心贡献，正是试图解决第2个问题。</p>
<h2 id="_3">恒等变换<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>SiD的想法是通过恒等变换来减少生成器损失函数$\eqref{eq:gloss-1}$对$\boldsymbol{\psi}^*$的依赖，从而弱化第2个问题。这一想法确实是开创性的，后面已经有不少工作围绕着SiD展开，包括下面要介绍的FGM也算是其中之一。</p>
<p>恒等变换的核心，是如下恒等式：<br />
\begin{equation}\mathbb{E}<em _boldsymbol_varphi="\boldsymbol{\varphi">{\boldsymbol{x}_0\sim \tilde{p}(\boldsymbol{x}_0),\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\langle\boldsymbol{f}(\boldsymbol{x}_t,t), \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t,t)\right\rangle\right] = \mathbb{E}</em><em _boldsymbol_varphi="\boldsymbol{\varphi">0\sim \tilde{p}(\boldsymbol{x}_0),\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\langle\boldsymbol{f}(\boldsymbol{x}_t,t), \boldsymbol{\varepsilon}\right\rangle\right]\label{eq:id}\end{equation}<br />
简单来说就是$\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_varphi="\boldsymbol{\varphi">t,t)$可以替换成$\boldsymbol{\varepsilon}$。这里的$\boldsymbol{\epsilon}</em>}^*}(\boldsymbol{x<em>t,t)$是式$\eqref{eq:tloss}$的理论最优解，而$\boldsymbol{f}(\boldsymbol{x}_t,t)$是任意 _只依赖于$\boldsymbol{x}_t$和$t$</em> 的向量函数。注意“只依赖于$\boldsymbol{x}_t$和$t$”是恒等式成立的必要条件，一旦$\boldsymbol{f}$掺杂了独立的$\boldsymbol{x}_0$或$\boldsymbol{\varepsilon}$，那么恒等式就未必成立了，所以应用该恒等式之前需要仔细检查这一点。</p>
<p>上一篇文章我们已经给出了该恒等式的证明，不过现在看来那个证明显得有点迂回，这里给出一个更直接点的证明：</p>
<blockquote>
<p><strong>证明：</strong> 将目标$\eqref{eq:tloss}$等价地改写成<br />
 \begin{equation}\boldsymbol{\varphi}^<em> = \mathop{\text{argmin}}<em _boldsymbol_x="\boldsymbol{x">{\boldsymbol{\varphi}} \mathbb{E}</em><em _boldsymbol_varepsilon="\boldsymbol{\varepsilon">t\sim p(\boldsymbol{x}_t)}\Big[\mathbb{E}</em>}\sim p(\boldsymbol{\varepsilon}|\boldsymbol{x<em _boldsymbol_varphi="\boldsymbol{\varphi">t)}\left[\Vert\boldsymbol{\epsilon}</em>}}(\boldsymbol{x<em _boldsymbol_mu="\boldsymbol{\mu">t,t) - \boldsymbol{\varepsilon}\Vert^2\right]\Big]\end{equation}<br />
 根据$\mathbb{E}[\boldsymbol{x}] = \mathop{\text{argmin}}\limits</em>}}\mathbb{E<em _boldsymbol_varphi="\boldsymbol{\varphi">{\boldsymbol{x}}\left[\Vert \boldsymbol{\mu} - \boldsymbol{x}\Vert^2\right]$（不熟悉可以求导证一下），我们可以得出上式的理论最优解是<br />
 \begin{equation}\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_varepsilon="\boldsymbol{\varepsilon">t,t) = \mathbb{E}</em>}\sim p(\boldsymbol{\varepsilon}|\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t)}[\boldsymbol{\varepsilon}]\end{equation}<br />
 所以<br />
 \begin{equation}\begin{aligned}<br />
 \mathbb{E}</em><em _boldsymbol_varphi="\boldsymbol{\varphi">0\sim \tilde{p}(\boldsymbol{x}_0),\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\langle\boldsymbol{f}(\boldsymbol{x}_t,t), \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t,t)\right\rangle\right]=&amp;\, \mathbb{E}</em><em _boldsymbol_varphi="\boldsymbol{\varphi">t\sim p(\boldsymbol{x}_t)}\left[\left\langle\boldsymbol{f}(\boldsymbol{x}_t,t), \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t,t)\right\rangle\right] \\<br />
 =&amp;\, \mathbb{E}</em><em _boldsymbol_varepsilon="\boldsymbol{\varepsilon">t\sim p(\boldsymbol{x}_t)}\left[\left\langle\boldsymbol{f}(\boldsymbol{x}_t,t), \mathbb{E}</em>}\sim p(\boldsymbol{\varepsilon}|\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t)}[\boldsymbol{\varepsilon}]\right\rangle\right] \\<br />
 =&amp;\, \mathbb{E}</em><em _boldsymbol_x="\boldsymbol{x">t\sim p(\boldsymbol{x}_t),\boldsymbol{\varepsilon}\sim p(\boldsymbol{\varepsilon}|\boldsymbol{x}_t)}\left[\left\langle\boldsymbol{f}(\boldsymbol{x}_t,t), \boldsymbol{\varepsilon}\right\rangle\right] \\<br />
 =&amp;\, \mathbb{E}</em>\right\rangle\right]}_0\sim \tilde{p}(\boldsymbol{x}_0),\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\langle\boldsymbol{f}(\boldsymbol{x}_t,t), \boldsymbol{\varepsilon<br />
 \end{aligned}\end{equation}<br />
 证毕。证明过程的“必经之路”是第一个等号，这需要用到“$\boldsymbol{f}(\boldsymbol{x}_t,t)$只依赖于$\boldsymbol{x}_t$和$t$”这个条件。</p>
</blockquote>
<p>恒等式$\eqref{eq:id}$的关键是$\boldsymbol{\epsilon}<em _boldsymbol_z="\boldsymbol{z">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t,t)$的最优性，而目标$\eqref{eq:tloss}$和$\eqref{eq:dloss}$形式是一样的，所以同样的结论也适用于$\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t,t)$，利用它我们就可以将$\eqref{eq:gloss-1}$变换成<br />
\begin{equation}\begin{aligned}<br />
&amp;\,\mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon<em _boldsymbol_z="\boldsymbol{z">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t)\Vert^2\right] \\[8pt]<br />
=&amp;\,\mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\bigg[\Big\langle\boldsymbol{\epsilon<em _boldsymbol_varphi="\boldsymbol{\varphi">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t),\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \underbrace{\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _text_可以替换为="\text{可以替换为">t^{(g)},t)}</em>\Big\rangle\bigg] \\[5pt]}\boldsymbol{\varepsilon}<br />
=&amp;\,\mathbb{E}<em _boldsymbol_varphi="\boldsymbol{\varphi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\langle\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_varphi="\boldsymbol{\varphi">t^{(g)},t),\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}_t^{(g)},t) - \boldsymbol{\varepsilon}\right\rangle\right]\triangleq \mathcal{L}_2<br />
\end{aligned}\label{eq:gloss-2}\end{equation}<br />
最后的形式就是SiD所提的生成器损失函数$\mathcal{L}_2$，它是SiD成功训练的关键，我们可以理解为它通过恒等变换提前预估了$\boldsymbol{\psi}^</em>$的值，同时弱化了对$\boldsymbol{\psi}^*$的依赖，从而以它为损失函数训练生成器比$\mathcal{L}_1$有着更好的效果。</p>
<p>SiD的遗留问题是：</p>
<blockquote>
<p>1、$\mathcal{L}<em _boldsymbol_z="\boldsymbol{z">2$的恒等变换并不彻底，将$\mathcal{L}_2$展开会发现里边还有一项$\mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle\boldsymbol{\epsilon<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t),\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t)\rangle]$，这一项的$\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)$同样可以替换为$\boldsymbol{\varepsilon}$，那么问题就是完整的变换即下式会是一个比$\mathcal{L}_2$更好的选择吗？<br />
 \begin{equation}\mathcal{L}_3 = \mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}_{\boldsymbol{\varphi</em>}\Vert^2 - 2\langle\boldsymbol{\epsilon}_{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t),\boldsymbol{\varepsilon}\rangle + \langle \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t)\boldsymbol{\varepsilon}\rangle\right]\label{eq:gloss-3}\end{equation}</p>
<p>2、实际上SiD最终用的损失不是$\mathcal{L}_2$也不是$\mathcal{L}_1$，而是$\mathcal{L}_2 - \lambda\mathcal{L}_1$，其中$\lambda &gt; 0$，并且实验发现$\lambda$的最优值在$1$附近，某些任务甚至在$\lambda=1.2$表现最好，这是非常让人困惑的，因为$\mathcal{L}_1,\mathcal{L}_2$是理论上相等的，所以$\lambda &gt; 1$似乎在反向优化$\mathcal{L}_1$？这不就跟出发点相反了？显然这迫切需要一个理论解释。</p>
</blockquote>
<h2 id="_4">直面梯度<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h2>
<p>再来回顾一下，我们面临的根本困难是：理论上$\boldsymbol{\psi}^<em>$是$\boldsymbol{\theta}$的函数，所以我们在求$\nabla_{\boldsymbol{\theta}} \mathcal{L}<em _boldsymbol_theta="\boldsymbol{\theta">1$或$\nabla</em>}} \mathcal{L<em _boldsymbol_theta="\boldsymbol{\theta">2$时，需要想办法求$\nabla</em>^}}\boldsymbol{\psi</em>$，但实践中我们至多可以得到$\mathcal{L}<em _boldsymbol_psi="\boldsymbol{\psi">i^{\color{skyblue}{(\text{sg})}} \triangleq \mathcal{L}_i|</em>^<em> \to \color{skyblue}{\text{sg}[}\boldsymbol{\psi}^</em>\color{skyblue}{]}}$，其中$\color{skyblue}{\text{sg}}$是stop gradient的意思，即无法获取$\boldsymbol{\psi}^*$关于$\boldsymbol{\theta}$的梯度，所以不论$\mathcal{L}_1,\mathcal{L}_2,\mathcal{L}_3$，它们在实践中的梯度都是有偏的。</p>
<p>这时候就轮到FGM登场了，它的想法更贴近本质：损失$\mathcal{L}<em _boldsymbol_theta="\boldsymbol{\theta">1,\mathcal{L}_2,\mathcal{L}_3$都只关注到了损失层面的相等性，但对于优化器来说我们需要的是梯度层面的相等，所以我们需要想办法找一个新的损失函数$\mathcal{L}_4$，使得它满足<br />
\begin{equation}\nabla</em>}}\mathcal{L<em _boldsymbol_theta="\boldsymbol{\theta">4(\boldsymbol{\theta}, \color{skyblue}{\text{sg}[}\boldsymbol{\psi}^<em>\color{skyblue}{]})= \nabla_{\boldsymbol{\theta}}\mathcal{L}_{1/2/3}(\boldsymbol{\theta}, \boldsymbol{\psi}^</em>)\end{equation}<br />
即$\nabla</em>}}\mathcal{L<em _boldsymbol_theta="\boldsymbol{\theta">4^{\color{skyblue}{(\text{sg})}} = \nabla</em>_4$为损失函数时，就可以实现无偏的优化效果了。}}\mathcal{L}_{1/2/3}$，那么以$\mathcal{L</p>
<p>FGM的推导同样基于恒等式$\eqref{eq:id}$，不过它的原始推导有点繁琐，对于本文来说可以直接从$\mathcal{L}<em _boldsymbol_z="\boldsymbol{z">3$即式$\eqref{eq:gloss-3}$出发，它跟$\boldsymbol{\psi}^<em>$相关的项就只剩下$\mathbb{E}<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t),\boldsymbol{\varepsilon}\rangle]$，我们直接把它的梯度算出来，方法将“先恒等变换后求梯度”和“先求梯度后恒等变换”分别应用于$\mathbb{E}</em>,t)\Vert^2]$操作一遍，对比它们的结果。},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\Vert\boldsymbol{\epsilon}_{\boldsymbol{\psi}^*}(\boldsymbol{x}_t^{(g)</p>
<p>先恒等变换后求梯度：<br />
\begin{equation}\begin{aligned}<br />
&amp;\,\nabla_{\boldsymbol{\theta}}\mathbb{E}<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\Vert\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)},t)\Vert^2] \\[5pt]<br />
=&amp;\, \nabla</em>}}\mathbb{E<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t),\boldsymbol{\varepsilon}\rangle] = \mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle \nabla_{\boldsymbol{\theta}}\boldsymbol{\epsilon<em _boldsymbol_z="\boldsymbol{z">{\boldsymbol{\psi}^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t),\boldsymbol{\varepsilon}\rangle] \\[5pt]<br />
=&amp;\, \mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle \nabla_{\boldsymbol{\theta}}\boldsymbol{\epsilon}_{\color{skyblue}{\text{sg}[}\boldsymbol{\psi</em>\color{skyblue}{]}}(\boldsymbol{x}_t^{(g)},t),\boldsymbol{\varepsilon}\rangle] + \mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle \nabla_{\boldsymbol{\theta}}\boldsymbol{\epsilon<em _boldsymbol_z="\boldsymbol{z">{\boldsymbol{\psi}^<em>}(\color{skyblue}{\text{sg}[}\boldsymbol{x}<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}\color{skyblue}{]},t),\boldsymbol{\varepsilon}\rangle]<br />
\end{aligned}\label{eq:g-grad-1}\end{equation}<br />
先求梯度后恒等变换：<br />
\begin{equation}\begin{aligned}<br />
&amp;\,\nabla</em>}}\mathbb{E<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\Vert\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t)\Vert^2] \\[8pt]<br />
=&amp;\, \mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\nabla_{\boldsymbol{\theta}}\Vert\boldsymbol{\epsilon<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{\psi}^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\Vert^2] = 2\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle\nabla_{\boldsymbol{\theta}}\boldsymbol{\epsilon}_{\boldsymbol{\psi</em>}(\boldsymbol{x}_t^{(g)},t), \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\rangle] \\[8pt]<br />
=&amp;\, 2\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle\nabla_{\boldsymbol{\theta}}\boldsymbol{\epsilon}_{\color{skyblue}{\text{sg}[}\boldsymbol{\psi</em>\color{skyblue}{]}}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t), \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\rangle] + \underbrace{2\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle\nabla_{\boldsymbol{\theta}}\boldsymbol{\epsilon}_{\boldsymbol{\psi</em>}(\color{skyblue}{\text{sg}[}\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)}\color{skyblue}{]},t), \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _text_可以应用式="\text{可以应用式">t^{(g)},t)\rangle]}</em> \\[5pt]}\eqref{eq:id}<br />
=&amp;\, 2\mathbb{E}<em _boldsymbol_theta="\boldsymbol{\theta">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle\nabla</em>^}}\boldsymbol{\epsilon}_{\color{skyblue}{\text{sg}[}\boldsymbol{\psi</em>\color{skyblue}{]}}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t), \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\rangle] + 2\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle\nabla_{\boldsymbol{\theta}}\boldsymbol{\epsilon}_{\boldsymbol{\psi</em>}(\color{skyblue}{\text{sg}[}\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)}\color{skyblue}{]},t), \boldsymbol{\varepsilon}\rangle]<br />
\end{aligned}\label{eq:g-grad-2}\end{equation}<br />
这里要注意第三个等号，只有$\boldsymbol{\epsilon}</em>^<em>}(\color{skyblue}{\text{sg}[}\boldsymbol{x}<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}\color{skyblue}{]},t)$这一项才可以应用恒等式$\eqref{eq:id}$，因为$\nabla</em>^}}\boldsymbol{\epsilon}_{\color{skyblue}{\text{sg}[}\boldsymbol{\psi</em>\color{skyblue}{]}}(\boldsymbol{x}_t^{(g)},t)$的$\boldsymbol{x}_t^{(g)}$要对$\boldsymbol{\theta}$求梯度，求完梯度后就不一定是$\boldsymbol{x}_t^{(g)}$的函数了，所以不满足应用式$\eqref{eq:id}$的条件。</p>
<p>现在对于$\nabla_{\boldsymbol{\theta}}\mathbb{E}<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\Vert\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)},t)\Vert^2]$我们有两个结果，将式$\eqref{eq:g-grad-1}$乘以2然后减去式$\eqref{eq:g-grad-2}$得到<br />
\begin{equation}\begin{aligned}<br />
&amp;\,\nabla</em>}}\mathbb{E<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)},t),\boldsymbol{\varepsilon}\rangle] = \nabla</em>}}\mathbb{E<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\Vert\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\Vert^2] = \eqref{eq:g-grad-1}\times 2 - \eqref{eq:g-grad-2} \\[5pt]<br />
=&amp;\,2 \mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle \nabla_{\boldsymbol{\theta}}\boldsymbol{\epsilon}_{\color{skyblue}{\text{sg}[}\boldsymbol{\psi</em>\color{skyblue}{]}}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t),\boldsymbol{\varepsilon}\rangle] - 2\mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle\nabla_{\boldsymbol{\theta}}\boldsymbol{\epsilon<em _boldsymbol_theta="\boldsymbol{\theta">{\color{skyblue}{\text{sg}[}\boldsymbol{\psi}^<em>\color{skyblue}{]}}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t), \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t)\rangle] \\[5pt]<br />
=&amp;\,2 \nabla</em>}}\mathbb{E<em _color_skyblue="\color{skyblue">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle \boldsymbol{\epsilon}</em>^}{\text{sg}[}\boldsymbol{\psi<em>\color{skyblue}{]}}(\boldsymbol{x}<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)},t),\boldsymbol{\varepsilon}\rangle] - \nabla</em>}}\mathbb{E<em _color_skyblue="\color{skyblue">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\Vert\boldsymbol{\epsilon}</em>^}{\text{sg}[}\boldsymbol{\psi</em>\color{skyblue}{]}}(\boldsymbol{x}<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)},t)\Vert^2] \\[5pt]<br />
=&amp;\,\nabla</em>}}\mathbb{E<em _color_skyblue="\color{skyblue">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[2\langle \boldsymbol{\epsilon}</em>^}{\text{sg}[}\boldsymbol{\psi<em>\color{skyblue}{]}}(\boldsymbol{x}<em _color_skyblue="\color{skyblue">t^{(g)},t),\boldsymbol{\varepsilon}\rangle - \Vert\boldsymbol{\epsilon}</em>^}{\text{sg}[}\boldsymbol{\psi</em>\color{skyblue}{]}}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\Vert^2]<br />
\end{aligned}\end{equation}<br />
留意最后被求梯度的式子，它所有的$\boldsymbol{\psi}^<em>$都被加上了$\color{skyblue}{\text{sg}}$，说明我们不用设法求它关于$\boldsymbol{\theta}$的梯度了，但它的梯度等于$\mathbb{E}<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}[\langle \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t),\boldsymbol{\varepsilon}\rangle]$的准确梯度，所以用它来替换掉$\mathcal{L}_3$的对应项，我们就得到了$\mathcal{L}_4$：<br />
\begin{equation}\mathcal{L}_4^{\color{skyblue}{(\text{sg})}} = \mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon<em _color_skyblue="\color{skyblue">{\boldsymbol{\varphi}^<em>}\Vert^2 - 2\langle\boldsymbol{\epsilon}_{\boldsymbol{\varphi}^</em>}(\boldsymbol{x}_t^{(g)},t),\boldsymbol{\varepsilon}\rangle + 2\langle \boldsymbol{\epsilon}</em>^}{\text{sg}[}\boldsymbol{\psi<em>\color{skyblue}{]}}(\boldsymbol{x}<em _color_skyblue="\color{skyblue">t^{(g)},t),\boldsymbol{\varepsilon}\rangle - \Vert\boldsymbol{\epsilon}</em>^}{\text{sg}[}\boldsymbol{\psi</em>\color{skyblue}{]}}(\boldsymbol{x}<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)},t)\Vert^2\right]\end{equation}<br />
这就是FGM的最终结果，它只依赖于$\color{skyblue}{\text{sg}[}\boldsymbol{\psi}^*\color{skyblue}{]}$，但成立$\nabla</em>}}\mathcal{L<em _boldsymbol_theta="\boldsymbol{\theta">4^{\color{skyblue}{(\text{sg})}}=\nabla</em>)$，所以FGM相当于从梯度角度肯定了SiD的$\lambda=0.5$的选择。}}\mathcal{L}_{1/2/3}$。再仔细观察一下，就会发现成立$\mathcal{L}_4^{\color{skyblue}{(\text{sg})}}=2\mathcal{L}_2^{\color{skyblue}{(\text{sg})}}-\mathcal{L}_1^{\color{skyblue}{(\text{sg})}}=2(\mathcal{L}_2^{\color{skyblue}{(\text{sg})}}-0.5\times \mathcal{L}_1^{\color{skyblue}{(\text{sg})}</p>
<p>顺便说一下，FGM原论文的描述是在ODE式扩散框架（flow matching）内进行的，但正如笔者在上一篇文章所说，不管是SiD还是FGM，它实际并没有用到扩散模型的迭代生成过程，而是只用到了扩散模型所训练的去噪模型，所以不管是ODE、SDE还是DDPM框架都只是表象，它的去噪模型才是本质，所以本文可以接着上一篇SiD的记号来介绍FGM。</p>
<h2 id="_5">广义散度<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h2>
<p>FGM已经成功地求出了最本质的梯度，但这只能解释SiD的$\lambda=0.5$，这意味着如果我们需要解释其他$\lambda$值的可行性，就必须修改出发点了。为此，我们回到原点，反思一下生成器的目标$\eqref{eq:gloss-1}$。</p>
<p>熟悉扩散模型的读者应该都知道，式$\eqref{eq:tloss}$的理论最优解还可以写成$\boldsymbol{\epsilon}<em _boldsymbol_x="\boldsymbol{x">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t,t)=-\bar{\beta}_t\nabla</em><em _boldsymbol_psi="\boldsymbol{\psi">t}\log p(\boldsymbol{x}_t)$，同理式$\eqref{eq:dloss}$的最优解则是$\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t)=-\bar{\beta}_t\nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)})$，这里的$p(\boldsymbol{x}_t)$、$p</em>)$分别是真实数据、生成器数据加噪的分布，如果不了解这个结果，可以参考}}(\boldsymbol{x}_t^{(g)<a href="/archives/9209">《生成扩散模型漫谈（五）：一般框架之SDE篇》</a>、<a href="/archives/9509">《生成扩散模型漫谈（十八）：得分匹配 = 条件得分匹配》</a>等介绍。</p>
<p>将这两个理论最优解代回式$\eqref{eq:gloss-1}$，我们会发现生成器实际上在试图最小化Fisher散度：<br />
\begin{equation}\begin{aligned}<br />
\mathcal{F}(p, p_{\boldsymbol{\theta}}) =&amp;\, \mathbb{E}<em _boldsymbol_x="\boldsymbol{x">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})} \left[\Vert \nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t^{(g)}) - \nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p(\boldsymbol{x}_t^{(g)})\Vert^2\right] \\<br />
=&amp;\, \int p</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t^{(g)}) \left\Vert \nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t^{(g)}) - \nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p(\boldsymbol{x}_t^{(g)})\right\Vert^2 d\boldsymbol{x}_t^{(g)}<br />
\end{aligned}\end{equation}<br />
我们要反思的事情，就是Fisher散度的合理性和改进点。可以看到，Fisher散度里边$p</em>$出现了两次，现在我们来请读者思考一个问题：}<strong>这两处$p_{\boldsymbol{\theta}}$中哪一处更重要呢？</strong></p>
<p>答案是<strong>第二处</strong> 。为了理解这个事实，我们不妨考虑两种情况： <em _boldsymbol_theta="\boldsymbol{\theta">1、固定第一处$p</em>$。}}$，只优化第二处$p_{\boldsymbol{\theta}}$；2、固定第二处$p_{\boldsymbol{\theta}}$，只优化第一处$p_{\boldsymbol{\theta}<em _boldsymbol_theta="\boldsymbol{\theta"> 它们的结果有什么区别呢？第一种情况大概率不会有什么变化，即依然能学到$p</em>=p$，事实上由于Fisher散度带有$\Vert\Vert^2$，所以下面更一般的结论几乎是显然成立的：}</p>
<blockquote>
<p>只要$r(\boldsymbol{x})$是一个处处不为零的分布，那么$p(\boldsymbol{x})=q(\boldsymbol{x})$依然是如下广义Fisher散度的理论最优解： \begin{equation}\mathcal{F}(p,q|r) = \int r(\boldsymbol{x}) \Vert \nabla_{\boldsymbol{x}} p(\boldsymbol{x}) - \nabla_{\boldsymbol{x}} q(\boldsymbol{x})\Vert^2 d\boldsymbol{x}\end{equation}</p>
</blockquote>
<p>说简单点，就是第一处$p_{\boldsymbol{\theta}}$根本不重要，换成其他分布都行，单靠$\Vert\Vert^2$就能保证两个分布相等。但第二种情况就不一样了，固定第二处$p_{\boldsymbol{\theta}}$只优化第一处$p_{\boldsymbol{\theta}}$的理论最优解是<br />
\begin{equation}p_{\boldsymbol{\theta}}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)}) = \delta(\boldsymbol{x}_t^{(g)} - \boldsymbol{x}_t^<em>),\quad \boldsymbol{x}_t^</em> = \mathop{\text{argmin}}</em><em _boldsymbol_x="\boldsymbol{x">t^{(g)}} \,\left\Vert \nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t^{(g)}) - \nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p(\boldsymbol{x}_t^{(g)})\right\Vert^2\end{equation}<br />
其中$\delta$是狄拉克delta分布，即模型只需要生成让$\Vert\Vert^2$最小的那个样本，就可以让损失最小，这说白了就是模式坍缩（Mode Collapse）！所以，Fisher散度中的第一处$p</em>$的作用不单单是次要的，甚至还可能是负面的。}</p>
<p>这启发我们，当我们使用基于梯度的优化器来训练模型时，第一处$p_{\boldsymbol{\theta}}$的梯度干脆不要还会更好，即下述形式的Fisher散度是一个更好的选择<br />
\begin{equation}\begin{aligned}<br />
\mathcal{F}^+(p, p_{\boldsymbol{\theta}}) =&amp;\, \int p_{\color{skyblue}{\text{sg}[}\boldsymbol{\theta}\color{skyblue}{]}}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)}) \left\Vert \nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t^{(g)}) - \nabla</em><em _boldsymbol_z="\boldsymbol{z">t^{(g)}}\log p(\boldsymbol{x}_t^{(g)})\right\Vert^2 d\boldsymbol{x}_t^{(g)} \\[5pt]<br />
=&amp;\, \mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})} \left[\Vert \nabla_{\boldsymbol{x<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\color{skyblue}{\text{sg}[}\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t^{(g)}\color{skyblue}{]}) - \nabla</em><em _boldsymbol_z="\boldsymbol{z">t^{(g)}}\log p(\color{skyblue}{\text{sg}[}\boldsymbol{x}_t^{(g)}\color{skyblue}{]})\Vert^2\right] \\[5pt]<br />
\propto&amp;\, \underbrace{\mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})} \left[\Vert \boldsymbol{\epsilon<em _mathcal_L="\mathcal{L">{\boldsymbol{\varphi}^<em>}(\color{skyblue}{\text{sg}[}\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)}\color{skyblue}{]},t) - \boldsymbol{\epsilon}</em>^</em>}(\color{skyblue}{\text{sg}[}\boldsymbol{x}_t^{(g)}\color{skyblue}{]},t)\Vert^2\right]}</em><em _boldsymbol_theta="\boldsymbol{\theta">5}<br />
\end{aligned}\end{equation}<br />
也就是说，这里的$\mathcal{L}_5$极有可能会是一个比$\mathcal{L}_1$更好的出发点，它数值上跟$\mathcal{L}_1$是相等的，但少了一部分梯度：<br />
\begin{equation}\nabla</em>}}\mathcal{L<em _boldsymbol_theta="\boldsymbol{\theta">5 = \nabla</em>}}\mathcal{L<em _boldsymbol_theta="\boldsymbol{\theta">1 - \nabla</em>}}\underbrace{\mathbb{E<em _boldsymbol_varphi="\boldsymbol{\varphi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})} \left[\Vert \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _color_skyblue="\color{skyblue">t^{(g)},t) - \boldsymbol{\epsilon}</em>^}{\text{sg}[}\boldsymbol{\psi</em>\color{skyblue}{]}}(\boldsymbol{x}<em _text_刚好是="\text{刚好是">t^{(g)},t)\Vert^2\right]}</em>}\mathcal{L<em _boldsymbol_theta="\boldsymbol{\theta">1^{\color{skyblue}{(\text{sg})}}}\end{equation}<br />
其中$\nabla</em>}}\mathcal{L<em _boldsymbol_theta="\boldsymbol{\theta">1$已经由FGM算出来了，它等于$\nabla</em>$作为额外的惩罚项，进一步降低模式坍缩的风险，当然这里真就是单纯的惩罚项，所以权重就不能太大了，根据SiD的实验结果，$\lambda=1.5$的时候已经开始训崩了。}}(2\mathcal{L}_2^{\color{skyblue}{(\text{sg})}}-\mathcal{L}_1^{\color{skyblue}{(\text{sg})}})$，因此以$\mathcal{L}_5$为出发点，我们实践中的损失函数是$2\mathcal{L}_2^{\color{skyblue}{(\text{sg})}}-\mathcal{L}_1^{\color{skyblue}{(\text{sg})}}-\mathcal{L}_1^{\color{skyblue}{(\text{sg})}}=2(\mathcal{L}_2^{\color{skyblue}{(\text{sg})}}-\mathcal{L}_1^{\color{skyblue}{(\text{sg})}})$，这就解释了$\lambda=1$的选择。至于$\lambda$稍大于1的选择，则更为极端一些，它相当于在$\mathcal{L}_5$的基础上将$-\mathcal{L}_1^{\color{skyblue}{(\text{sg})}</p>
<p>顺便说一下，FGM之前作者还有个作品<a href="https://papers.cool/arxiv/2410.16794">《One-Step Diffusion Distillation through Score Implicit Matching》</a>，里边也提出了类似的对第一处$p_{\boldsymbol{\theta}}$改为$p_{\color{skyblue}{\text{sg}[}\boldsymbol{\theta}\color{skyblue}{]}}$的做法，但没有明确地从Fisher散度的原始形式出发讨论该操作的合理性，稍欠完整。</p>
<h2 id="_6">文章小结<a class="toc-link" href="#_6" title="Permanent link">&para;</a></h2>
<p>本文介绍了SiD（Score identity Distillation）的后续理论进展，主要内容是从梯度视角解释了SiD中的$\lambda$参数设置，核心部分是由FGM（Flow Generator Matching）发现的准确估计SiD梯度的巧妙思路，这肯定了$\lambda=0.5$的选择，在此基础上，笔者拓展了Fisher散度的概念，从而解释了$\lambda=1$的取值。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/10567">https://spaces.ac.cn/archives/10567</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Nov. 22, 2024). 《生成扩散模型漫谈（二十六）：基于恒等式的蒸馏（下） 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/10567">https://spaces.ac.cn/archives/10567</a></p>
<p>@online{kexuefm-10567,<br />
title={生成扩散模型漫谈（二十六）：基于恒等式的蒸馏（下）},<br />
author={苏剑林},<br />
year={2024},<br />
month={Nov},<br />
url={\url{https://spaces.ac.cn/archives/10567}},<br />
} </p>
<hr />
<h2 id="_7">公式推导与注释<a class="toc-link" href="#_7" title="Permanent link">&para;</a></h2>
<p>TODO: 添加详细的数学公式推导和注释</p>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="adam的epsilon如何影响学习率的scaling-law.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#170 Adam的epsilon如何影响学习率的Scaling Law？</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="从hessian近似看自适应学习率优化器.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#172 从Hessian近似看自适应学习率优化器</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#_1">生成扩散模型漫谈（二十六）：基于恒等式的蒸馏（下）</a><ul>
<li><a href="#_2">思想回顾</a></li>
<li><a href="#_3">恒等变换</a></li>
<li><a href="#_4">直面梯度</a></li>
<li><a href="#_5">广义散度</a></li>
<li><a href="#_6">文章小结</a></li>
<li><a href="#_7">公式推导与注释</a></li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>