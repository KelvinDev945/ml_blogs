<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoE环游记：3、换个思路来分配 | ML & Math Blog Posts</title>
    <meta name="description" content="MoE环游记：3、换个思路来分配&para;
原文链接: https://spaces.ac.cn/archives/10757
发布日期: 

这篇文章我们继续探讨MoE的负载均衡问题。在上一篇文章《MoE环游记：2、不患寡而患不均》中，我们主要讨论了通过Aux Loss来促进负载均衡的思路。Aux Loss固然简单直观，但它也有一个明显的缺点——权重不好调——调低了无法促进均衡，调高了容易损害...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering with equation numbering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        tags: 'ams',  // Enable equation numbering with AMS style
        tagSide: 'right',  // Place equation numbers on the right
        tagIndent: '0.8em',  // Indentation for equation numbers
        multlineWidth: '85%'
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=详细推导">详细推导</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #166 MoE环游记：3、换个思路来分配
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#166</span>
                MoE环游记：3、换个思路来分配
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> 2025-03-05</span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=详细推导" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 详细推导</span>
                </a>
                
                <a href="../index.html?tags=最优" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 最优</span>
                </a>
                
                <a href="../index.html?tags=损失函数" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 损失函数</span>
                </a>
                
                <a href="../index.html?tags=梯度" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 梯度</span>
                </a>
                
                <a href="../index.html?tags=moe" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> moe</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="moe3">MoE环游记：3、换个思路来分配<a class="toc-link" href="#moe3" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/10757">https://spaces.ac.cn/archives/10757</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>这篇文章我们继续探讨MoE的负载均衡问题。在上一篇文章<a href="/archives/10735">《MoE环游记：2、不患寡而患不均》</a>中，我们主要讨论了通过Aux Loss来促进负载均衡的思路。Aux Loss固然简单直观，但它也有一个明显的缺点——权重不好调——调低了无法促进均衡，调高了容易损害LM Loss，所以业界一直有寻找替代方案的尝试。</p>
<p>本文要分享的是名为“Loss-Free”的方案，由DeepSeek在<a href="https://papers.cool/arxiv/2408.15664">《Auxiliary-Loss-Free Load Balancing Strategy for Mixture-of-Experts》</a>提出。和DeepSeek众多耀眼的开源作品相比，这篇论文也许不算起眼，但在笔者看来，它潜在的学术影响力可能远超其他工作，因为所提方法不仅简单有效，而且极具普适性，堪称经典。</p>
<h2 id="_1">方法大意<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h2>
<p>面对负载不均衡，Aux Loss的应对思路是通过额外的损失引导Router给出均衡的打分，而Loss-Free的想法则是换个新的分配思路，即不改变Router现有打分结果，而是改变$\mathop{\text{argtop}}_k \boldsymbol{\rho}$这个分配方式。</p>
<p>其实这个方向此前也有过一些努力。比如2021年Facebook提出了<a href="https://papers.cool/arxiv/2103.16716">BASE Layer</a>，将Expert的分配视为<a href="https://en.wikipedia.org/wiki/Assignment_problem">线性指派问题</a>，即以负载均衡为约束条件，求在该约束之下Router总打分尽可能高的分配结果，这可以用<a href="https://en.wikipedia.org/wiki/Hungarian_algorithm">匈牙利算法</a>等来解决。但该方案需要知道全体Token的打分，所以对于自回归式LLM来说，它只适用于训练，推理还是只能用$\mathop{\text{argtop}}_k \boldsymbol{\rho}$，训练推理存在不一致性，并且由于目前求解算法的限制，它只适用于$k=1$的场景。</p>
<p>相比之下，Loss-Free的做法非常简单且有效，它留意到一个事实，即我们总可以引入一个偏置项$\boldsymbol{b}$，使得$\mathop{\text{argtop}}<em _mathop_text_argtop="\mathop{\text{argtop" i_in="i\in">k \boldsymbol{\rho} + \boldsymbol{b}$的分配是均衡的，所以它将MoE的形式改为<br />
\begin{equation}\boldsymbol{y} = \sum</em>}<em _mathop_text_argtop="\mathop{\text{argtop" i_in="i\in">k \boldsymbol{\rho}} \rho_i \boldsymbol{e}_i\qquad\to\qquad \boldsymbol{y} = \sum</em>}}_k \boldsymbol{\rho} + \boldsymbol{b}} \rho_i \boldsymbol{e}_i\end{equation
这里的$\boldsymbol{b}$是输入无关的向量，由训练过程确定下来，训练完后它就保持不变，因此推理阶段也可以用，换言之训练和推理具有一致的形式。注意乘以$\boldsymbol{e}_i$的还是$\rho_i$而不是$\rho_i + b_i$，也就是说$\boldsymbol{b}$仅仅参与分配过程而不参与MoE的前向计算，所以我们对$\boldsymbol{b}$或$\boldsymbol{\rho} + \boldsymbol{b}$的正负性都没有特殊要求。</p>
<h2 id="_2">手搓梯度<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>怎么训练$\boldsymbol{b}$呢？我们知道，$\boldsymbol{b}$的优化方向自然是促进负载均衡，为此按照上一篇的记号，我们先定义$\boldsymbol{f}=[f_1,f_2,\cdots,f_n]$：<br />
\begin{equation}f_i = \left\{\begin{aligned}1/k, \quad i\in \mathop{\text{argtop}}\nolimits_k \boldsymbol{\rho}+\boldsymbol{b} \\
0, \quad i\not\in \mathop{\text{argtop}}\nolimits_k \boldsymbol{\rho}+\boldsymbol{b}\end{aligned}\right.\end{equation}<br />
以及$\boldsymbol{F}=\mathbb{E}[\boldsymbol{f}]$，这里的$\boldsymbol{F}$自然就是在$\boldsymbol{b}$偏置下Expert当前的负载分布了。借着我们定义均匀分布为$\boldsymbol{Q}=(1/n,1/n,\cdots,1/n)$，那么负载均衡就相当于最小化<br />
\begin{equation}\mathcal{L}<em i="1">{\text{aux}} = \frac{1}{2}\Vert\boldsymbol{F} - \boldsymbol{Q}\Vert^2 = \frac{1}{2}\sum</em>}^n (F_i - 1/n)^2\end{equation
这个目标是不可导的，但有了上一篇的经验，我们知道STE（Straight-Through Estimator）可以解决这个问题。STE的关键是找一个可导且跟$\boldsymbol{F}$具有同增减趋势的量作为$\boldsymbol{F}$的光滑近似，这里我们的优化参数只有$\boldsymbol{b}$，而它正好具有我们期望的性质（增大$b_i$，$i$被选中的概率就更高，那么$F_i$就更大），所以答案就呼之欲出了：<br />
\begin{equation}\mathcal{L}<em i="1">{\text{aux}} = \frac{1}{2}\Vert\boldsymbol{b} + \text{sg}[\boldsymbol{F}-\boldsymbol{b}] - \boldsymbol{Q}\Vert^2 = \frac{1}{2}\sum</em>}^n (b_i + \text{sg}[F_i - b_i] - 1/n)^2\end{equation
它的梯度是
\begin{equation}\nabla_{\boldsymbol{b}}\mathcal{L}<em _boldsymbol_b="\boldsymbol{b">{\text{aux}} = \frac{1}{2}\nabla</em>}}\Vert\boldsymbol{b} + \text{sg}[\boldsymbol{F}-\boldsymbol{b}] - \boldsymbol{Q}\Vert^2 = \boldsymbol{F} - \boldsymbol{Q}\end{equation<br />
所以用梯度下降（SGD）来更新$\boldsymbol{b}$就是<br />
\begin{equation}\boldsymbol{b}\leftarrow \boldsymbol{b} - \alpha (\boldsymbol{F} - \boldsymbol{Q})\end{equation}<br />
这里$\alpha$是$\boldsymbol{b}$的学习率。不过Loss-Free最终选择的更新规则略有不同，它选择的是符号梯度下降（SignSGD）：<br />
\begin{equation}\boldsymbol{b}\leftarrow \boldsymbol{b} - \alpha \mathop{\text{sign}}(\boldsymbol{F} - \boldsymbol{Q})\label{eq:aux-loss-free}\end{equation}<br />
这个结果其实也很好理解，就是如果$F_i$比$1/n$大，那么就调小一点$b_i$，否则就增大一点$b_i$。</p>
<h2 id="_3">改良版本<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>除了加$\mathop{\text{sign}}$的符号梯度下降外，笔者发现直接对$\boldsymbol{F} - \boldsymbol{Q}$做RMS Norm（即Normalized SGD），在相同的$\alpha$下往往能达到更好的均衡效果：<br />
\begin{equation}\boldsymbol{b}\leftarrow \boldsymbol{b} - \alpha\frac{\boldsymbol{F} - \boldsymbol{Q}}{\text{RMS}(\boldsymbol{F} - \boldsymbol{Q})}\end{equation}<br />
这里的$\text{RMS}$是“Root Mean Square”，定义为<br />
\begin{equation}\text{RMS}(\boldsymbol{F} - \boldsymbol{Q}) = \sqrt{\frac{1}{n}\sum_{i=1}^n (F_i - Q_i)^2}\end{equation}<br />
不难看出，加$\mathop{\text{sign}}$后的$\mathop{\text{sign}}(\boldsymbol{F} - \boldsymbol{Q})$和加RMS Norm后的$\frac{\boldsymbol{F} - \boldsymbol{Q}}{\text{RMS}(\boldsymbol{F} - \boldsymbol{Q})}$，它们的$\text{RMS}$都是1，因此它们俩尺度上是大致相同的，所以我们可以使用相同的$\alpha$。</p>
<p>简单来说，$\mathop{\text{sign}}$的问题在于不论$F_i$与目标$Q_i$的远近都使用同样的更新幅度，这导致原本就已经跟$Q_i$比较接近的$F_i$反而容易偏离原本已经达到的均衡，从而产生震荡；而RMS Norm则保留了$F_i-Q_i$之间的相对大小，更新幅度更加自适应一些，理论上更有助于促进均衡，实测效果也多是它更好。</p>
<h2 id="_4">一脉相承<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h2>
<p>原论文在介绍Loss-Free时，并没有上述Aux Loss的推导过程，而是直接给出式$\eqref{eq:aux-loss-free}$的更新规则，给人的感觉是给$\boldsymbol{b}$“手搓”了梯度$\mathop{\text{sign}}(\boldsymbol{F} - \boldsymbol{Q})$，这也是它Loss-Free这个名字的来源。</p>
<p>然而，从本文给出的推导可以看出，更新规则$\eqref{eq:aux-loss-free}$也完全可以从Aux Loss视角得到，两者是一脉相承的。看起来Loss-Free最直接的好处是不用调Aux Loss权重了，但它实际上也有个学习率参数$\alpha$要调，尽管原论文已经帮我们搜好$\alpha=0.001$这个默认值，但不可否认这个超参数是存在的。</p>
<p>在笔者看来，Loss-Free的本质创新并不是没有Aux Loss，而是隔离了Aux Loss和LM Loss的优化参数，从而达到了负载均衡和模型能力两不误的效果。其中最关键一步，是留意到“一个偏置项足以达到负载均衡”这一事实，然后就让Aux Loss只优化新引入的偏置$\boldsymbol{b}$，而LM Loss则优化剩余参数，让Aux Loss对LM Loss的负面作用降到最低。</p>
<p>相比之下，常规的Aux Loss方案需要全体参数来促进负载均衡，而LM Loss优化的也是全体参数，两者的优化方向可能并不完全兼容，因此想找到一个最优的平衡点相对来说就更为困难。所以，Loss-Free基于“一个偏置项足以达到负载均衡”将两个Loss的优化参数隔离开来，是负载均衡问题的一个绝妙的解决办法。</p>
<h2 id="_5">相关细节<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h2>
<p>尽管Loss-Free已经足够简单明了，但是在使用的时候还要稍微注意一些细节。</p>
<p>首先，对于每个Batch的数据，我们应当先根据LM Loss来更新模型参数，然后再根据式$\eqref{eq:aux-loss-free}$来更新$\boldsymbol{b}$。这是因为$\boldsymbol{b}$的更新依赖于全体Token的统计信息$\boldsymbol{F}$，先更新$\boldsymbol{b}$再更新模型其余参数的话，原则上会有泄漏未来信息的风险。虽然直观看来就一个向量$\boldsymbol{b}$泄漏不了多少信息，但这个风险终归是存在的，因此要尽量去规避它。</p>
<p>其次，刚才我们说原论文已经调好$\alpha=0.001$，但这个结果可能跟原论文用Sigmoid作为Router $\boldsymbol{\rho}$激活函数的选择是绑定的。原因也不难想，经过Sigmoid后，每个$\rho_i$相对比较独立，并且都在$(0,1)$内，$\alpha=0.001$相当于说每一步的更新幅度约为千分之一，如果换Softmax、ReLU或者其他激活函数，那么就可能需要重调$\alpha$了。</p>
<p>针对这个问题，笔者建议的做法是解耦Gate和Bias所用的激活函数，即<br />
\begin{equation}\boldsymbol{y} = \sum_{i\in \mathop{\text{argtop}}<em _mathop_text_argtop="\mathop{\text{argtop" i_in="i\in">k \boldsymbol{\rho} + \boldsymbol{b}} \rho_i \boldsymbol{e}_i\qquad\to\qquad \boldsymbol{y} = \sum</em>}}_k \boldsymbol{\rho}^{(\sigma)} + \boldsymbol{b}} \rho_i^{(h)} \boldsymbol{e}_i\end{equation
其中$\boldsymbol{\rho}^{(\sigma)} = \sigma(\boldsymbol{x}\boldsymbol{W}^{(R)}), \boldsymbol{\rho}^{(h)} = h(\boldsymbol{x}\boldsymbol{W}^{(R)})$，$\sigma(\cdot)$是Sigmoid函数，$h(\cdot)$是任意单调且值域非负的函数，说白了就是加上$\boldsymbol{b}$的是Sigmoid激活的打分，这样我们就可以复用$\alpha=0.001$，至于乘上Expert的Gate，我们可以用其他激活函数，只要它的单调性跟Sigmoid一致就行。</p>
<p>此外，由于更新规则$\eqref{eq:aux-loss-free}$加了$\text{sign}$函数，因此有可能训出绝对值大于1的$b_i$，整体绝对值还可能越来越大，这些都是正常的，对模型效果不会有影响。实际上$\boldsymbol{b}$有一个冗余的自由度，因为全体$b_i$都加上同一个常数后，$\mathop{\text{argtop}}_k \boldsymbol{\rho} + \boldsymbol{b}$的结果不变。这个额外的自由度我们可以用来做其他好玩的事情（且听下回分解）。</p>
<h2 id="_6">延伸思考<a class="toc-link" href="#_6" title="Permanent link">&para;</a></h2>
<p>除了MoE的负载均衡之外，Loss-Free的思想还可以应用到很多类似问题，比如VQ-VQE的编码表坍缩（Codebook Collapse），就可以用同样思路解决，而且相比之前介绍的“<a href="/archives/10489">旋转技巧</a>”、“<a href="/archives/10519">线性变换技巧</a>”显得更自然和普适。事实上，本文开篇的评价“Loss-Free潜在的学术影响力可能远超其他工作”，正是基于Loss-Free的普适性考虑的。</p>
<p>抛开具体的应用背景，从数学上来看，Loss-Free的贡献可以理解为给出了用梯度下降来求解指派问题的方法。一个经典的线性指派问题可以表示为：<br />
\begin{equation}\min_f \sum_{i=1}^n c_{i, f(i)}\end{equation}<br />
其中$c_{i,j}$是给定的成本函数，$f$是$\{1,2,\cdots,n\}$到自身的双射。放到本文的背景下，$c_{i,j}$不就相当于$n$个Token、$n$个Expert的打分，所求$f$不就是一个负载均衡的分配方案？求解此类问题的一般想法是在满足约束条件的空间里搜索尽可能优的解，而Loss-Free则反过来，先构建一个最优但不一定满足约束条件的解：<br />
\begin{equation}f(i) = \mathop{\text{argmin}}<em i_j="i,j">j c</em>}\end{equation
这个解在分数上肯定是最优的，但不一定满足双射的条件，这里不满足双射就等价于负载不均衡。于是我们引入偏置
\begin{equation}f(i) = \mathop{\text{argmin}}<em i_j="i,j">j c</em>} + b_j\end{equation<br />
$b_j$初始化为零，然后根据式$\eqref{eq:aux-loss-free}$来更新，更新规则说白了就是哪个$j$出现出现次数多，那减少相应的$b_j$，反之增加，直到出现双射为止。</p>
<h2 id="_7">文章小结<a class="toc-link" href="#_7" title="Permanent link">&para;</a></h2>
<p>本文介绍了MoE负载均衡问题的Loss-Free方法，它由DeepSeek提出，其核心在于通过引入一个简单的偏置项来实现负载均衡。本文进一步思考了它与Aux Loss的联系，以及它在类似数学问题上的应用潜力。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/10757">https://spaces.ac.cn/archives/10757</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Mar. 05, 2025). 《MoE环游记：3、换个思路来分配 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/10757">https://spaces.ac.cn/archives/10757</a></p>
<p>@online{kexuefm-10757,<br />
title={MoE环游记：3、换个思路来分配},<br />
author={苏剑林},<br />
year={2025},<br />
month={Mar},<br />
url={\url{https://spaces.ac.cn/archives/10757}},<br />
} </p>
<hr />
<h2 id="_8">公式推导与注释<a class="toc-link" href="#_8" title="Permanent link">&para;</a></h2>
<p>本节提供MoE负载均衡问题的深入数学分析，从最优化理论、深度学习和实际应用等多个角度解释Loss-Free方法的理论基础。</p>
<h3 id="1-moe">1. MoE的数学模型<a class="toc-link" href="#1-moe" title="Permanent link">&para;</a></h3>
<h4 id="11">1.1 基本形式<a class="toc-link" href="#11" title="Permanent link">&para;</a></h4>
<p>标准的MoE（Mixture of Experts）模型可以形式化表示为：</p>
<p>$$
\boldsymbol{y} = \sum_{i=1}^{n} g_i(\boldsymbol{x}) \boldsymbol{e}_i(\boldsymbol{x})
$$</p>
<p>其中：
- $\boldsymbol{x} \in \mathbb{R}^d$ 是输入token的表示
- $n$ 是专家（Expert）的总数
- $\boldsymbol{e}<em i="1">i: \mathbb{R}^d \to \mathbb{R}^{d'}$ 是第 $i$ 个专家网络
- $g_i: \mathbb{R}^d \to \mathbb{R}$ 是门控（Gating）函数，满足 $\sum</em>) = 1$}^n g_i(\boldsymbol{x</p>
<h4 id="12-top-kmoe">1.2 Top-K稀疏化MoE<a class="toc-link" href="#12-top-kmoe" title="Permanent link">&para;</a></h4>
<p>为了计算效率，实际应用中通常采用Top-K稀疏化的MoE：</p>
<p>$$
\boldsymbol{y} = \sum_{i \in \mathcal{T}_k(\boldsymbol{x})} \tilde{g}_i(\boldsymbol{x}) \boldsymbol{e}_i(\boldsymbol{x})
$$</p>
<p>其中 $\mathcal{T}_k(\boldsymbol{x}) = \mathop{\text{argtop}}_k {\rho_1(\boldsymbol{x}), \ldots, \rho_n(\boldsymbol{x})}$ 是选择得分最高的 $k$ 个专家的索引集合，而</p>
<p>$$
\tilde{g}<em _in="\in" _mathcal_T="\mathcal{T" j="j">i(\boldsymbol{x}) = \frac{\rho_i(\boldsymbol{x})}{\sum</em>
$$}_k(\boldsymbol{x})} \rho_j(\boldsymbol{x})</p>
<p>是重归一化的门控权重。这里 $\boldsymbol{\rho}(\boldsymbol{x}) = [\rho_1(\boldsymbol{x}), \ldots, \rho_n(\boldsymbol{x})]^T$ 是路由器（Router）的输出得分。</p>
<p><strong>路由器的参数化</strong>：</p>
<p>$$
\boldsymbol{\rho}(\boldsymbol{x}) = h(\boldsymbol{x} \boldsymbol{W}^{(R)})
$$</p>
<p>其中 $\boldsymbol{W}^{(R)} \in \mathbb{R}^{d \times n}$ 是路由器的权重矩阵，$h(\cdot)$ 是激活函数（如Softmax、Sigmoid、ReLU等）。</p>
<h3 id="2">2. 专家分配问题的最优化表述<a class="toc-link" href="#2" title="Permanent link">&para;</a></h3>
<h4 id="21">2.1 负载均衡作为约束优化问题<a class="toc-link" href="#21" title="Permanent link">&para;</a></h4>
<p>考虑一个批次（batch）中有 $m$ 个token，记为 ${\boldsymbol{x}_1, \ldots, \boldsymbol{x}_m}$。专家分配问题可以表述为以下优化问题：</p>
<p>$$
\begin{align}
\max_{{S_i}<em t="1">{i=1}^{m}} \quad &amp; \sum</em>}^{m} \sum_{i \in S_t} \rho_i(\boldsymbol{x<em S_t="S_t" _in="\in" i="i" t:="t:">t) \
\text{s.t.} \quad &amp; |S_t| = k, \quad \forall t = 1, \ldots, m \
&amp; \left|\bigcup</em> {t}\right| \leq C, \quad \forall i = 1, \ldots, n
\end{align}
$$</p>
<p>其中：
- $S_t \subseteq {1, \ldots, n}$ 是分配给第 $t$ 个token的专家集合
- 第一个约束保证每个token恰好选择 $k$ 个专家
- 第二个约束是容量约束（Capacity Constraint），限制每个专家最多处理 $C$ 个token
- $C = \lceil \frac{mk}{n} \cdot \gamma \rceil$ 是容量上限，$\gamma \geq 1$ 是容量因子（Capacity Factor）</p>
<p><strong>当 $\gamma = 1$ 时的完美均衡</strong>：容量恰好等于 $C = \frac{mk}{n}$，这意味着所有专家的负载完全均衡。</p>
<h4 id="22-linear-assignment-problem">2.2 线性指派问题（Linear Assignment Problem）<a class="toc-link" href="#22-linear-assignment-problem" title="Permanent link">&para;</a></h4>
<p>当 $k=1$ 时，上述问题退化为经典的线性指派问题：</p>
<p>$$
\begin{align}
\min_{A \in \mathcal{P}} \quad &amp; \sum_{t=1}^{m} \sum_{i=1}^{n} c_{ti} a_{ti} \
\text{s.t.} \quad &amp; \sum_{i=1}^{n} a_{ti} = 1, \quad \forall t \
&amp; \sum_{t=1}^{m} a_{ti} \leq C, \quad \forall i \
&amp; a_{ti} \in {0, 1}
\end{align}
$$</p>
<p>其中 $c_{ti} = -\rho_i(\boldsymbol{x}<em ti="ti">t)$ 是成本矩阵，$a</em>$ 是指示变量（token $t$ 是否分配给专家 $i$）。</p>
<p>这个问题可以用<strong>匈牙利算法</strong>（Hungarian Algorithm）或<strong>Kuhn-Munkres算法</strong>在 $O(m^3)$ 时间内求解，但存在以下限制：
1. 仅适用于 $k=1$ 的情况
2. 需要全局信息（整个batch的所有token），不适合自回归推理
3. 计算复杂度较高</p>
<h3 id="3">3. 负载均衡约束的数学表征<a class="toc-link" href="#3" title="Permanent link">&para;</a></h3>
<h4 id="31">3.1 负载分布的定义<a class="toc-link" href="#31" title="Permanent link">&para;</a></h4>
<p>对于单个token $\boldsymbol{x}$，定义其专家选择的one-hot向量：</p>
<p>$$
f_i = \begin{cases}
\frac{1}{k}, &amp; i \in \mathop{\text{argtop}}_k \boldsymbol{\rho}(\boldsymbol{x}) \
0, &amp; \text{otherwise}
\end{cases}
$$</p>
<p>这里除以 $k$ 是为了归一化，使得 $\sum_{i=1}^{n} f_i = 1$。</p>
<p><strong>批次级别的负载分布</strong>：对于包含 $m$ 个token的批次，专家 $i$ 的平均负载为：</p>
<p>$$
F_i = \frac{1}{m} \sum_{t=1}^{m} f_i^{(t)} = \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}[f_i(\boldsymbol{x})]
$$</p>
<p>其中 $\mathcal{D}$ 是训练数据分布。</p>
<p><strong>理想均匀分布</strong>：</p>
<p>$$
Q_i = \frac{1}{n}, \quad \forall i = 1, \ldots, n
$$</p>
<p>满足 $\sum_{i=1}^{n} Q_i = 1$。</p>
<h4 id="32">3.2 负载不均衡的度量<a class="toc-link" href="#32" title="Permanent link">&para;</a></h4>
<p>常用的度量包括：</p>
<p><strong>（1）L2距离（欧氏距离）</strong>：</p>
<p>$$
\mathcal{D}<em i="1">2(\boldsymbol{F}, \boldsymbol{Q}) = |\boldsymbol{F} - \boldsymbol{Q}|_2 = \sqrt{\sum</em>
$$}^{n} (F_i - Q_i)^2</p>
<p><strong>（2）KL散度（Kullback-Leibler Divergence）</strong>：</p>
<p>$$
\mathcal{D}<em i="1">{\text{KL}}(\boldsymbol{F} | \boldsymbol{Q}) = \sum</em>
$$}^{n} F_i \log \frac{F_i}{Q_i</p>
<p><strong>（3）变异系数（Coefficient of Variation）</strong>：</p>
<p>$$
\text{CV}(\boldsymbol{F}) = \frac{\sqrt{\text{Var}(\boldsymbol{F})}}{\mathbb{E}[\boldsymbol{F}]} = \frac{\sqrt{\frac{1}{n}\sum_{i=1}^{n} (F_i - \frac{1}{n})^2}}{\frac{1}{n}} = \sqrt{n \sum_{i=1}^{n} (F_i - \frac{1}{n})^2}
$$</p>
<p>本文采用L2距离的平方作为优化目标，这在数学上更加方便处理。</p>
<h3 id="4">4. 路由策略的数学分析<a class="toc-link" href="#4" title="Permanent link">&para;</a></h3>
<h4 id="41">4.1 常见激活函数的性质<a class="toc-link" href="#41" title="Permanent link">&para;</a></h4>
<p><strong>（1）Softmax激活</strong>：</p>
<p>$$
\rho_i^{(\text{softmax})}(\boldsymbol{x}) = \frac{\exp(z_i)}{\sum_{j=1}^{n} \exp(z_j)}
$$</p>
<p>其中 $z_i = \boldsymbol{x}^T \boldsymbol{w}_i^{(R)}$ 是第 $i$ 个专家的logit。</p>
<p><strong>性质</strong>：
- 概率约束：$\sum_{i=1}^{n} \rho_i = 1$
- 值域：$\rho_i \in (0, 1)$
- 梯度：$\frac{\partial \rho_i}{\partial z_j} = \rho_i (\delta_{ij} - \rho_j)$，其中 $\delta_{ij}$ 是Kronecker delta</p>
<p><strong>（2）Sigmoid激活</strong>：</p>
<p>$$
\rho_i^{(\text{sigmoid})}(\boldsymbol{x}) = \sigma(z_i) = \frac{1}{1 + \exp(-z_i)}
$$</p>
<p><strong>性质</strong>：
- 独立性：每个 $\rho_i$ 独立计算
- 值域：$\rho_i \in (0, 1)$
- 梯度：$\frac{\partial \rho_i}{\partial z_i} = \rho_i(1 - \rho_i)$
- <strong>不满足概率约束</strong>：$\sum_{i=1}^{n} \rho_i \neq 1$（一般情况）</p>
<p><strong>（3）ReLU激活</strong>：</p>
<p>$$
\rho_i^{(\text{ReLU})}(\boldsymbol{x}) = \max(0, z_i)
$$</p>
<p><strong>性质</strong>：
- 值域：$\rho_i \in [0, +\infty)$
- 稀疏性：可能产生很多零值
- 梯度：$\frac{\partial \rho_i}{\partial z_i} = \mathbb{1}_{z_i &gt; 0}$（几乎处处可导）</p>
<h4 id="42-top-k">4.2 Top-K选择的非平滑性<a class="toc-link" href="#42-top-k" title="Permanent link">&para;</a></h4>
<p>Top-K操作定义为：</p>
<p>$$
\mathop{\text{argtop}}_k \boldsymbol{\rho} = {i_1, \ldots, i_k}
$$</p>
<p>其中 $\rho_{i_1} \geq \rho_{i_2} \geq \cdots \geq \rho_{i_k} \geq \rho_j$ 对所有 $j \notin {i_1, \ldots, i_k}$。</p>
<p><strong>问题</strong>：这是一个<strong>离散的、不可微的</strong>操作：
- 当 $\rho_i$ 发生微小变化时，选择集合 $\mathcal{T}_k$ 可能发生突变
- 标准的反向传播无法直接应用</p>
<p><strong>梯度近似方法</strong>：</p>
<p>（1）<strong>直通估计器（Straight-Through Estimator, STE）</strong>：</p>
<p>$$
\frac{\partial \mathcal{L}}{\partial \rho_i} \approx \begin{cases}
\frac{\partial \mathcal{L}}{\partial \tilde{\rho}_i}, &amp; i \in \mathcal{T}_k \
0, &amp; \text{otherwise}
\end{cases}
$$</p>
<p>其中 $\tilde{\rho}_i$ 是归一化后的门控权重。</p>
<p>（2）<strong>Gumbel-Softmax松弛</strong>：用连续分布近似离散采样。</p>
<p>（3）<strong>本文方法（Loss-Free）</strong>：引入偏置项 $\boldsymbol{b}$，将Top-K的输入从 $\boldsymbol{\rho}$ 改为 $\boldsymbol{\rho} + \boldsymbol{b}$。</p>
<h3 id="5-loss-free">5. Loss-Free方法的最优化理论<a class="toc-link" href="#5-loss-free" title="Permanent link">&para;</a></h3>
<h4 id="51">5.1 偏置项的引入<a class="toc-link" href="#51" title="Permanent link">&para;</a></h4>
<p><strong>核心观察</strong>：对于任意给定的路由得分 $\boldsymbol{\rho}$，总存在一个偏置向量 $\boldsymbol{b} \in \mathbb{R}^n$，使得基于 $\boldsymbol{\rho} + \boldsymbol{b}$ 的Top-K选择达到负载均衡。</p>
<p><strong>数学表述</strong>：存在 $\boldsymbol{b}^* \in \mathbb{R}^n$，使得</p>
<p>$$
\mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[\boldsymbol{f}(\boldsymbol{x}; \boldsymbol{b}^*)\right] = \boldsymbol{Q}
$$</p>
<p>其中</p>
<p>$$
f_i(\boldsymbol{x}; \boldsymbol{b}) = \begin{cases}
\frac{1}{k}, &amp; i \in \mathop{\text{argtop}}_k (\boldsymbol{\rho}(\boldsymbol{x}) + \boldsymbol{b}) \
0, &amp; \text{otherwise}
\end{cases}
$$</p>
<p><strong>存在性证明（构造性）</strong>：</p>
<p>考虑映射 $\Phi: \mathbb{R}^n \to \mathbb{R}^n$：</p>
<p>$$
\Phi(\boldsymbol{b}) = \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}\left[\boldsymbol{f}(\boldsymbol{x}; \boldsymbol{b})\right] - \boldsymbol{Q}
$$</p>
<p>目标是找到 $\boldsymbol{b}^<em>$ 使得 $\Phi(\boldsymbol{b}^</em>) = \boldsymbol{0}$。</p>
<p>通过以下观察可以证明解的存在性：
1. 当 $b_i \to +\infty$ 时，专家 $i$ 总是被选中（对所有token），因此 $F_i \to 1 &gt; Q_i$
2. 当 $b_i \to -\infty$ 时，专家 $i$ 从不被选中，因此 $F_i \to 0 &lt; Q_i$
3. $\Phi_i(\boldsymbol{b})$ 关于 $b_i$ 单调递增（几乎处处）
4. 由中间值定理和不动点定理，存在 $\boldsymbol{b}^<em>$ 使得 $\Phi(\boldsymbol{b}^</em>) = \boldsymbol{0}$</p>
<h4 id="52">5.2 优化目标的构造<a class="toc-link" href="#52" title="Permanent link">&para;</a></h4>
<p>定义损失函数：</p>
<p>$$
\mathcal{L}<em i="1">{\text{balance}}(\boldsymbol{b}) = \frac{1}{2} |\boldsymbol{F}(\boldsymbol{b}) - \boldsymbol{Q}|_2^2 = \frac{1}{2} \sum</em>) - Q_i)^2
$$}^{n} (F_i(\boldsymbol{b</p>
<p>其中 $\boldsymbol{F}(\boldsymbol{b}) = \mathbb{E}_{\boldsymbol{x} \sim \mathcal{D}}[\boldsymbol{f}(\boldsymbol{x}; \boldsymbol{b})]$。</p>
<p><strong>目标</strong>：最小化 $\mathcal{L}_{\text{balance}}(\boldsymbol{b})$ 以达到 $\boldsymbol{F}(\boldsymbol{b}) \approx \boldsymbol{Q}$。</p>
<p><strong>困难</strong>：$\boldsymbol{F}(\boldsymbol{b})$ 关于 $\boldsymbol{b}$ 不可微（因为涉及 $\mathop{\text{argtop}}_k$ 操作）。</p>
<h4 id="53-ste">5.3 直通估计器（STE）的应用<a class="toc-link" href="#53-ste" title="Permanent link">&para;</a></h4>
<p><strong>观察</strong>：尽管 $F_i(\boldsymbol{b})$ 不可微，但我们可以利用以下性质：
- 增大 $b_i$ 会增加专家 $i$ 被选中的概率，从而增大 $F_i$
- 减小 $b_i$ 会减少专家 $i$ 被选中的概率，从而减小 $F_i$</p>
<p><strong>STE构造</strong>：将损失函数重写为</p>
<p>$$
\mathcal{L}_{\text{balance}}(\boldsymbol{b}) = \frac{1}{2} |\boldsymbol{b} + \text{sg}[\boldsymbol{F}(\boldsymbol{b}) - \boldsymbol{b}] - \boldsymbol{Q}|_2^2
$$</p>
<p>其中 $\text{sg}[\cdot]$ 表示stop-gradient操作（在反向传播时视为常数）。</p>
<p><strong>梯度计算</strong>：</p>
<p>$$
\begin{align}
\nabla_{\boldsymbol{b}} \mathcal{L}<em _boldsymbol_b="\boldsymbol{b">{\text{balance}} &amp;= \nabla</em>|}} \frac{1}{2} |\boldsymbol{b} + \text{sg}[\boldsymbol{F} - \boldsymbol{b}] - \boldsymbol{Q<em _boldsymbol_b="\boldsymbol{b">2^2 \
&amp;= \nabla</em>) \
&amp;= \boldsymbol{F} - \boldsymbol{Q}
\end{align}
$$}} \frac{1}{2} |\boldsymbol{F} - \boldsymbol{Q}|_2^2 \quad (\text{视} \boldsymbol{F} \text{为常数</p>
<p>这个梯度形式简单且直观：
- 如果 $F_i &gt; Q_i$（专家 $i$ 过载），则 $\nabla_{b_i} \mathcal{L} &gt; 0$，梯度下降会减小 $b_i$
- 如果 $F_i &lt; Q_i$（专家 $i$ 欠载），则 $\nabla_{b_i} \mathcal{L} &lt; 0$，梯度下降会增大 $b_i$</p>
<h4 id="54">5.4 梯度下降更新规则<a class="toc-link" href="#54" title="Permanent link">&para;</a></h4>
<p><strong>标准SGD</strong>：</p>
<p>$$
\boldsymbol{b}^{(t+1)} = \boldsymbol{b}^{(t)} - \alpha (\boldsymbol{F}^{(t)} - \boldsymbol{Q})
$$</p>
<p>其中 $\alpha &gt; 0$ 是学习率，$\boldsymbol{F}^{(t)}$ 是第 $t$ 步的负载统计。</p>
<p><strong>符号梯度下降（SignSGD）</strong>（原论文采用）：</p>
<p>$$
\boldsymbol{b}^{(t+1)} = \boldsymbol{b}^{(t)} - \alpha \, \text{sign}(\boldsymbol{F}^{(t)} - \boldsymbol{Q})
$$</p>
<p>其中</p>
<p>$$
\text{sign}(x) = \begin{cases}
+1, &amp; x &gt; 0 \
0, &amp; x = 0 \
-1, &amp; x &lt; 0
\end{cases}
$$</p>
<p><strong>优点</strong>：
- 更新幅度统一，不受 $|F_i - Q_i|$ 绝对值的影响
- 类似于Adam等自适应优化器的效果
- 鲁棒性更强，不容易因为某个专家负载极度不均而产生过大的更新</p>
<p><strong>缺点</strong>：
- 忽略了不均衡程度的信息
- 可能在接近最优点时产生震荡</p>
<h4 id="55-rms">5.5 RMS归一化梯度下降（改进版）<a class="toc-link" href="#55-rms" title="Permanent link">&para;</a></h4>
<p>本文作者提出的改进方案：</p>
<p>$$
\boldsymbol{b}^{(t+1)} = \boldsymbol{b}^{(t)} - \alpha \frac{\boldsymbol{F}^{(t)} - \boldsymbol{Q}}{\text{RMS}(\boldsymbol{F}^{(t)} - \boldsymbol{Q})}
$$</p>
<p>其中RMS（Root Mean Square）定义为：</p>
<p>$$
\text{RMS}(\boldsymbol{v}) = \sqrt{\frac{1}{n} \sum_{i=1}^{n} v_i^2}
$$</p>
<p><strong>性质分析</strong>：</p>
<p>（1）<strong>尺度归一化</strong>：归一化后的梯度的RMS值恒为1：</p>
<p>$$
\text{RMS}\left(\frac{\boldsymbol{v}}{\text{RMS}(\boldsymbol{v})}\right) = 1
$$</p>
<p>这与 $\text{sign}(\boldsymbol{v})$ 的 $\ell_2$ 范数为 $\sqrt{n}$ 不同，但两者都实现了尺度归一化。</p>
<p>（2）<strong>保留相对信息</strong>：与SignSGD不同，RMS归一化保留了各分量的相对大小关系：</p>
<p>$$
\frac{F_i - Q_i}{\text{RMS}(\boldsymbol{F} - \boldsymbol{Q})} \propto (F_i - Q_i)
$$</p>
<p>这意味着不均衡更严重的专家会得到更大的调整。</p>
<p>（3）<strong>减少震荡</strong>：在接近收敛时，$|\boldsymbol{F} - \boldsymbol{Q}|$ 较小，归一化梯度的各分量也相应变小，有助于稳定收敛。</p>
<p><strong>与标准SGD的关系</strong>：</p>
<p>RMS归一化梯度下降可以看作是自适应学习率的SGD：</p>
<p>$$
\boldsymbol{b}^{(t+1)} = \boldsymbol{b}^{(t)} - \frac{\alpha}{\text{RMS}(\boldsymbol{F}^{(t)} - \boldsymbol{Q})} (\boldsymbol{F}^{(t)} - \boldsymbol{Q})
$$</p>
<p>相当于有效学习率为 $\alpha_{\text{eff}} = \frac{\alpha}{\text{RMS}(\boldsymbol{F} - \boldsymbol{Q})}$。</p>
<h3 id="6">6. 最优传输理论的联系<a class="toc-link" href="#6" title="Permanent link">&para;</a></h3>
<h4 id="61-optimal-transport">6.1 最优传输问题（Optimal Transport）<a class="toc-link" href="#61-optimal-transport" title="Permanent link">&para;</a></h4>
<p>负载均衡问题可以从最优传输（OT）的角度来理解。给定两个概率分布：
- 源分布：$\boldsymbol{\mu} = \boldsymbol{F}$（当前负载分布）
- 目标分布：$\boldsymbol{\nu} = \boldsymbol{Q}$（均匀分布）</p>
<p>最优传输问题寻找一个传输计划 $\boldsymbol{\pi} \in \mathbb{R}^{n \times n}$，使得</p>
<p>$$
\begin{align}
\min_{\boldsymbol{\pi}} \quad &amp; \sum_{i,j=1}^{n} C_{ij} \pi_{ij} \
\text{s.t.} \quad &amp; \sum_{j=1}^{n} \pi_{ij} = \mu_i, \quad \forall i \
&amp; \sum_{i=1}^{n} \pi_{ij} = \nu_j, \quad \forall j \
&amp; \pi_{ij} \geq 0
\end{align}
$$</p>
<p>其中 $C_{ij}$ 是从位置 $i$ 传输到位置 $j$ 的成本。</p>
<p><strong>特殊情况</strong>：当 $C_{ij} = |i - j|^2$ 时，这是经典的<strong>Wasserstein-2距离</strong>：</p>
<p>$$
W_2(\boldsymbol{\mu}, \boldsymbol{\nu}) = \left(\min_{\boldsymbol{\pi} \in \Pi(\boldsymbol{\mu}, \boldsymbol{\nu})} \sum_{i,j} C_{ij} \pi_{ij}\right)^{1/2}
$$</p>
<h4 id="62">6.2 熵正则化最优传输<a class="toc-link" href="#62" title="Permanent link">&para;</a></h4>
<p>为了提高计算效率，引入<strong>熵正则化</strong>：</p>
<p>$$
\min_{\boldsymbol{\pi}} \quad \sum_{i,j=1}^{n} C_{ij} \pi_{ij} + \epsilon H(\boldsymbol{\pi})
$$</p>
<p>其中熵项定义为：</p>
<p>$$
H(\boldsymbol{\pi}) = -\sum_{i,j=1}^{n} \pi_{ij} \log \pi_{ij}
$$</p>
<p>参数 $\epsilon &gt; 0$ 控制正则化强度。</p>
<p><strong>优点</strong>：
- 最优解具有 $\pi_{ij}^<em> = u_i K_{ij} v_j$ 的形式，其中 $K_{ij} = \exp(-C_{ij}/\epsilon)$
- 可以用</em><em>Sinkhorn算法</em>*高效求解</p>
<h4 id="63-sinkhorn">6.3 Sinkhorn算法<a class="toc-link" href="#63-sinkhorn" title="Permanent link">&para;</a></h4>
<p>Sinkhorn算法是求解熵正则化OT问题的经典迭代算法。</p>
<p><strong>初始化</strong>：</p>
<p>$$
\boldsymbol{u}^{(0)} = \mathbf{1}_n, \quad \boldsymbol{v}^{(0)} = \mathbf{1}_n
$$</p>
<p><strong>迭代更新</strong>（第 $t$ 次迭代）：</p>
<p>$$
\begin{align}
u_i^{(t+1)} &amp;= \frac{\mu_i}{\sum_{j=1}^{n} K_{ij} v_j^{(t)}} = \frac{\mu_i}{(\boldsymbol{K} \boldsymbol{v}^{(t)})<em i="1">i} \
v_j^{(t+1)} &amp;= \frac{\nu_j}{\sum</em>
\end{align}
$$}^{n} K_{ij} u_i^{(t+1)}} = \frac{\nu_j}{(\boldsymbol{K}^T \boldsymbol{u}^{(t+1)})_j</p>
<p><strong>收敛性</strong>：Sinkhorn算法线性收敛到最优解，收敛速度与 $\epsilon$ 有关。</p>
<p><strong>与Loss-Free的联系</strong>：Loss-Free的偏置项 $\boldsymbol{b}$ 可以看作是一种隐式的最优传输调整：
- $\boldsymbol{b}$ 的作用是调整选择概率，使得负载分布从 $\boldsymbol{F}$ 移动到 $\boldsymbol{Q}$
- 这类似于OT中的dual variable（对偶变量）</p>
<p><strong>对偶形式</strong>：最优传输的对偶问题为</p>
<p>$$
\max_{\boldsymbol{\phi}, \boldsymbol{\psi}} \quad \sum_{i=1}^{n} \mu_i \phi_i + \sum_{j=1}^{n} \nu_j \psi_j
$$</p>
<p>满足 $\phi_i + \psi_j \leq C_{ij}$。偏置项 $\boldsymbol{b}$ 可以理解为对偶变量的离散化近似。</p>
<h3 id="7">7. 梯度计算与反向传播<a class="toc-link" href="#7" title="Permanent link">&para;</a></h3>
<h4 id="71-moe">7.1 完整的MoE前向传播<a class="toc-link" href="#71-moe" title="Permanent link">&para;</a></h4>
<p>考虑带偏置的MoE前向过程：</p>
<p>$$
\begin{align}
\boldsymbol{z} &amp;= \boldsymbol{x} \boldsymbol{W}^{(R)} \in \mathbb{R}^n \
\boldsymbol{\rho} &amp;= h(\boldsymbol{z}) \in \mathbb{R}^n \
\boldsymbol{\rho}' &amp;= \boldsymbol{\rho} + \boldsymbol{b} \
\mathcal{T}<em _mathcal_T="\mathcal{T">k &amp;= \mathop{\text{argtop}}_k \boldsymbol{\rho}' \
\tilde{\boldsymbol{\rho}} &amp;= \text{normalize}(\boldsymbol{\rho}|</em><em _in="\in" _mathcal_T="\mathcal{T" i="i">k}) \
\boldsymbol{y} &amp;= \sum</em>)
\end{align}
$$}_k} \tilde{\rho}_i \boldsymbol{e}_i(\boldsymbol{x</p>
<h4 id="72">7.2 参数的梯度<a class="toc-link" href="#72" title="Permanent link">&para;</a></h4>
<p><strong>（1）专家网络参数的梯度</strong>：</p>
<p>对于 $i \in \mathcal{T}_k$：</p>
<p>$$
\frac{\partial \mathcal{L}}{\partial \boldsymbol{\theta}_i^{(E)}} = \frac{\partial \mathcal{L}}{\partial \boldsymbol{y}} \cdot \frac{\partial \boldsymbol{y}}{\partial \boldsymbol{e}_i} \cdot \frac{\partial \boldsymbol{e}_i}{\partial \boldsymbol{\theta}_i^{(E)}} = \tilde{\rho}_i \frac{\partial \mathcal{L}}{\partial \boldsymbol{y}} \cdot \frac{\partial \boldsymbol{e}_i}{\partial \boldsymbol{\theta}_i^{(E)}}
$$</p>
<p>对于 $i \notin \mathcal{T}_k$：梯度为零（因为该专家未参与计算）。</p>
<p><strong>（2）路由器参数的梯度</strong>：</p>
<p>使用STE近似：</p>
<p>$$
\frac{\partial \mathcal{L}}{\partial \boldsymbol{W}^{(R)}} \approx \sum_{i \in \mathcal{T}_k} \frac{\partial \mathcal{L}}{\partial \tilde{\rho}_i} \cdot \frac{\partial \tilde{\rho}_i}{\partial \rho_i} \cdot \frac{\partial \rho_i}{\partial \boldsymbol{z}} \cdot \frac{\partial \boldsymbol{z}}{\partial \boldsymbol{W}^{(R)}}
$$</p>
<p>其中归一化的梯度为：</p>
<p>$$
\frac{\partial \tilde{\rho}_i}{\partial \rho_j} = \begin{cases}
\frac{1}{Z} - \frac{\rho_i}{Z^2}, &amp; i = j \in \mathcal{T}_k \
-\frac{\rho_i}{Z^2}, &amp; i \neq j, \, i,j \in \mathcal{T}_k \
0, &amp; \text{otherwise}
\end{cases}
$$</p>
<p>其中 $Z = \sum_{j \in \mathcal{T}_k} \rho_j$。</p>
<p><strong>（3）偏置项的梯度</strong>：</p>
<p>关键是 $\boldsymbol{b}$ <strong>不参与前向计算的权重</strong>，只参与Top-K选择。因此：</p>
<p>$$
\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{b}} = \boldsymbol{0}
$$</p>
<p>换言之，$\boldsymbol{b}$ 对主损失函数 $\mathcal{L}_{\text{LM}}$ 的梯度为零！</p>
<p>这正是Loss-Free的核心优势：$\boldsymbol{b}$ 的优化完全独立于主任务，不会干扰语言模型的训练。</p>
<h4 id="73">7.3 偏置项的独立更新<a class="toc-link" href="#73" title="Permanent link">&para;</a></h4>
<p>$\boldsymbol{b}$ 的更新不通过 $\mathcal{L}_{\text{LM}}$ 的梯度，而是通过负载均衡目标：</p>
<p>$$
\boldsymbol{b}^{(t+1)} = \boldsymbol{b}^{(t)} - \alpha \nabla_{\boldsymbol{b}} \mathcal{L}_{\text{balance}} = \boldsymbol{b}^{(t)} - \alpha (\boldsymbol{F}^{(t)} - \boldsymbol{Q})
$$</p>
<p><strong>更新顺序</strong>：
1. 前向传播：计算 $\mathcal{L}_{\text{LM}}$ 和统计 $\boldsymbol{F}$
2. 反向传播：更新 $\boldsymbol{W}^{(R)}$ 和 ${\boldsymbol{\theta}_i^{(E)}}$
3. 独立更新 $\boldsymbol{b}$</p>
<p>这个顺序保证了：
- $\boldsymbol{b}$ 的更新基于当前batch的真实负载统计
- 避免了"泄漏未来信息"的风险</p>
<h3 id="8-capacity-factor">8. 容量因子（Capacity Factor）的影响<a class="toc-link" href="#8-capacity-factor" title="Permanent link">&para;</a></h3>
<h4 id="81">8.1 容量因子的定义<a class="toc-link" href="#81" title="Permanent link">&para;</a></h4>
<p>容量因子 $\gamma \geq 1$ 决定了每个专家的最大容量：</p>
<p>$$
C = \left\lceil \frac{mk}{n} \cdot \gamma \right\rceil
$$</p>
<p>其中：
- $m$：batch中的token数
- $k$：每个token选择的专家数
- $n$：专家总数
- $\frac{mk}{n}$：完美均衡时每个专家的平均负载</p>
<h4 id="82-gamma">8.2 不同 $\gamma$ 值的影响<a class="toc-link" href="#82-gamma" title="Permanent link">&para;</a></h4>
<p><strong>（1）$\gamma = 1$（理想情况）</strong>：</p>
<ul>
<li>容量恰好等于平均负载</li>
<li><strong>无溢出空间</strong>：要求严格的负载均衡</li>
<li>优点：计算资源利用最优</li>
<li>缺点：可能导致token overflow（某些token无法分配到k个专家）</li>
</ul>
<p><strong>（2）$\gamma &gt; 1$（实际常用）</strong>：</p>
<ul>
<li>提供了 $(\gamma - 1) \times 100\%$ 的冗余容量</li>
<li>允许一定程度的负载不均衡</li>
<li>常用值：$\gamma = 1.25$ 或 $\gamma = 1.5$</li>
</ul>
<p><strong>token溢出概率分析</strong>：</p>
<p>假设负载分布的标准差为 $\sigma_F$，则专家 $i$ 的实际负载 $L_i$ 可以近似为：</p>
<p>$$
L_i \sim \mathcal{N}\left(\frac{mk}{n}, \sigma_F^2 m\right)
$$</p>
<p>溢出概率：</p>
<p>$$
P(\text{overflow}) = P\left(L_i &gt; C\right) = P\left(L_i &gt; \frac{mk}{n} \gamma\right)
$$</p>
<p>标准化后：</p>
<p>$$
P(\text{overflow}) \approx 1 - \Phi\left(\frac{(\gamma - 1) mk/n}{\sigma_F \sqrt{m}}\right)
$$</p>
<p>其中 $\Phi(\cdot)$ 是标准正态分布的CDF。</p>
<p><strong>结论</strong>：
- $\gamma$ 越大，溢出概率越低
- $\sigma_F$ 越小（负载越均衡），溢出概率越低
- Loss-Free通过减小 $\sigma_F$ 来降低所需的 $\gamma$</p>
<h4 id="83">8.3 容量约束下的修正<a class="toc-link" href="#83" title="Permanent link">&para;</a></h4>
<p>当存在容量约束时，分配策略需要修改为：</p>
<p>$$
\mathcal{T}_k(\boldsymbol{x}_t; {\ell_i}) = \begin{cases}
\mathop{\text{argtop}}_k (\boldsymbol{\rho}_t + \boldsymbol{b}) &amp; \text{if no overflow} \
\text{greedy allocation} &amp; \text{otherwise}
\end{cases}
$$</p>
<p>其中 $\ell_i$ 是专家 $i$ 的当前负载计数。</p>
<p><strong>贪心分配算法</strong>：按 $\rho_{ti} + b_i$ 降序遍历，跳过已满的专家：</p>
<pre class="highlight"><code>for i in argsort(ρ_t + b, descending=True):
    if ℓ_i &lt; C and |T_k| &lt; k:
        T_k.add(i)
        ℓ_i += 1
</code></pre>

<h3 id="9">9. 损失函数设计（辅助损失对比）<a class="toc-link" href="#9" title="Permanent link">&para;</a></h3>
<h4 id="91-aux-loss">9.1 传统辅助损失（Aux Loss）<a class="toc-link" href="#91-aux-loss" title="Permanent link">&para;</a></h4>
<p><strong>形式1：均衡损失</strong>（Switch Transformer）：</p>
<p>$$
\mathcal{L}<em i="1">{\text{aux}}^{(1)} = \alpha \sum</em> F_i P_i
$$}^{n</p>
<p>其中 $P_i = \frac{1}{m} \sum_{t=1}^{m} \rho_{ti}$ 是专家 $i$ 的平均得分。</p>
<p><strong>优化目标</strong>：最小化负载 $F_i$ 与得分 $P_i$ 的乘积，促使高得分的专家被更多选择。</p>
<p><strong>形式2：变异系数损失</strong>：</p>
<p>$$
\mathcal{L}<em i="1">{\text{aux}}^{(2)} = \alpha \cdot \text{Var}(\boldsymbol{F}) = \alpha \sum</em>)^2
$$}^{n} (F_i - \frac{1}{n</p>
<p><strong>总损失</strong>：</p>
<p>$$
\mathcal{L}<em _text_LM="\text{LM">{\text{total}} = \mathcal{L}</em>
$$}} + \mathcal{L}_{\text{aux}</p>
<p><strong>问题</strong>：
- 权重 $\alpha$ 难以调节
- $\mathcal{L}_{\text{aux}}$ 的梯度会影响所有参数（包括路由器和专家网络）
- 可能损害主任务性能</p>
<h4 id="92-loss-free">9.2 Loss-Free的优势<a class="toc-link" href="#92-loss-free" title="Permanent link">&para;</a></h4>
<p><strong>对比表</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>传统Aux Loss</th>
<th>Loss-Free</th>
</tr>
</thead>
<tbody>
<tr>
<td>优化参数</td>
<td>全体参数</td>
<td>仅偏置 $\boldsymbol{b}$</td>
</tr>
<tr>
<td>对主任务影响</td>
<td>直接影响 $\mathcal{L}_{\text{LM}}$</td>
<td>不影响前向权重</td>
</tr>
<tr>
<td>超参数</td>
<td>权重 $\alpha$</td>
<td>学习率 $\alpha$</td>
</tr>
<tr>
<td>训练/推理一致性</td>
<td>一致</td>
<td>一致</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>中等</td>
<td>低</td>
</tr>
</tbody>
</table>
<p><strong>数学分析</strong>：</p>
<p>（1）<strong>参数空间分离</strong>：</p>
<p>传统方法：$\theta = {\boldsymbol{W}^{(R)}, {\boldsymbol{\theta}_i^{(E)}}}$ 同时优化两个目标</p>
<p>$$
\theta^* = \arg\min_{\theta} \left[\mathcal{L}<em _text_aux="\text{aux">{\text{LM}}(\theta) + \alpha \mathcal{L}</em>(\theta)\right]
$$}</p>
<p>Loss-Free：参数分为两组
- 主参数：$\theta = {\boldsymbol{W}^{(R)}, {\boldsymbol{\theta}<em _text_LM="\text{LM">i^{(E)}}}$ 优化 $\mathcal{L}</em>$
- 辅助参数：$\boldsymbol{b}$ 优化 $\mathcal{L}_{\text{balance}}$}</p>
<p>$$
\begin{align}
\theta^<em> &amp;= \arg\min_{\theta} \mathcal{L}_{\text{LM}}(\theta; \boldsymbol{b}) \
\boldsymbol{b}^</em> &amp;= \arg\min_{\boldsymbol{b}} \mathcal{L}_{\text{balance}}(\boldsymbol{b})
\end{align}
$$</p>
<p>（2）<strong>优化景观（Optimization Landscape）</strong>：</p>
<p>传统方法的梯度：</p>
<p>$$
\nabla_{\theta} \mathcal{L}<em _theta="\theta">{\text{total}} = \nabla</em>} \mathcal{L<em _theta="\theta">{\text{LM}} + \alpha \nabla</em>
$$} \mathcal{L}_{\text{aux}</p>
<p>两个梯度可能方向冲突，导致优化困难。</p>
<p>Loss-Free的梯度：</p>
<p>$$
\begin{align}
\nabla_{\theta} \mathcal{L}<em _boldsymbol_b="\boldsymbol{b">{\text{LM}} &amp;\quad \text{(主任务)} \
\nabla</em>
\end{align}
$$}} \mathcal{L}_{\text{balance}} = \boldsymbol{F} - \boldsymbol{Q} &amp;\quad \text{(负载均衡)</p>
<p>两者正交，互不干扰。</p>
<h3 id="10">10. 收敛性分析与理论保证<a class="toc-link" href="#10" title="Permanent link">&para;</a></h3>
<h4 id="101">10.1 偏置更新的收敛性<a class="toc-link" href="#101" title="Permanent link">&para;</a></h4>
<p>考虑连续时间的梯度流（Gradient Flow）：</p>
<p>$$
\frac{d\boldsymbol{b}(t)}{dt} = -(\boldsymbol{F}(\boldsymbol{b}(t)) - \boldsymbol{Q})
$$</p>
<p><strong>Lyapunov函数</strong>：定义</p>
<p>$$
V(\boldsymbol{b}) = \frac{1}{2} |\boldsymbol{F}(\boldsymbol{b}) - \boldsymbol{Q}|_2^2
$$</p>
<p>其沿梯度流的导数为：</p>
<p>$$
\frac{dV}{dt} = (\boldsymbol{F} - \boldsymbol{Q})^T \frac{d\boldsymbol{F}}{dt} = (\boldsymbol{F} - \boldsymbol{Q})^T \frac{\partial \boldsymbol{F}}{\partial \boldsymbol{b}} \frac{d\boldsymbol{b}}{dt}
$$</p>
<p>假设 $\frac{\partial F_i}{\partial b_i} &gt; 0$（增大 $b_i$ 增加 $F_i$），并且 $\frac{\partial F_i}{\partial b_j} \approx 0$ 对 $i \neq j$，则</p>
<p>$$
\frac{dV}{dt} \approx -\sum_{i=1}^{n} (F_i - Q_i) \frac{\partial F_i}{\partial b_i} (F_i - Q_i) = -\sum_{i=1}^{n} \frac{\partial F_i}{\partial b_i} (F_i - Q_i)^2 &lt; 0
$$</p>
<p>因此 $V(\boldsymbol{b}(t))$ 单调递减，系统收敛到 $\boldsymbol{F} = \boldsymbol{Q}$。</p>
<h4 id="102">10.2 离散化误差<a class="toc-link" href="#102" title="Permanent link">&para;</a></h4>
<p>实际的SignSGD或RMS-SGD是离散化的：</p>
<p>$$
\boldsymbol{b}^{(t+1)} = \boldsymbol{b}^{(t)} - \alpha \boldsymbol{g}^{(t)}
$$</p>
<p>其中 $\boldsymbol{g}^{(t)}$ 是归一化梯度。</p>
<p><strong>稳定性条件</strong>：要求学习率满足</p>
<p>$$
\alpha &lt; \frac{2}{\lambda_{\max}(\boldsymbol{H})}
$$</p>
<p>其中 $\boldsymbol{H} = \frac{\partial^2 V}{\partial \boldsymbol{b}^2}$ 是Hessian矩阵。</p>
<p>对于本问题，由于 $\frac{\partial F_i}{\partial b_i}$ 通常较小（负载变化缓慢），$\alpha = 0.001$ 远小于稳定性上界，因此收敛有保证。</p>
<h4 id="103">10.3 随机性的影响<a class="toc-link" href="#103" title="Permanent link">&para;</a></h4>
<p>实际训练中，$\boldsymbol{F}$ 是基于mini-batch估计的，存在方差：</p>
<p>$$
\boldsymbol{F}<em _text_true="\text{true">{\text{batch}} = \boldsymbol{F}</em>
$$}} + \boldsymbol{\epsilon</p>
<p>其中 $\mathbb{E}[\boldsymbol{\epsilon}] = \boldsymbol{0}$，$\text{Var}(\epsilon_i) = \frac{\sigma_i^2}{m}$。</p>
<p><strong>影响</strong>：
- 更新存在噪声，导致 $\boldsymbol{b}$ 在最优点附近振荡
- 振荡幅度与batch size $m$ 成反比
- 可以通过增大 $m$ 或使用moving average来减小方差</p>
<h3 id="11_1">11. 实验结果的理论解释<a class="toc-link" href="#11_1" title="Permanent link">&para;</a></h3>
<h4 id="111">11.1 负载均衡指标<a class="toc-link" href="#111" title="Permanent link">&para;</a></h4>
<p>常用指标：</p>
<p><strong>（1）负载变异系数</strong>：</p>
<p>$$
\text{CV}(\boldsymbol{F}) = \frac{\sqrt{\text{Var}(\boldsymbol{F})}}{\mathbb{E}[\boldsymbol{F}]} = \sqrt{n \sum_{i=1}^{n} (F_i - \frac{1}{n})^2}
$$</p>
<p><strong>（2）最大/最小负载比</strong>：</p>
<p>$$
\text{Ratio} = \frac{\max_i F_i}{\min_i F_i}
$$</p>
<p>理想情况：$\text{Ratio} = 1$</p>
<p><strong>（3）熵</strong>：</p>
<p>$$
H(\boldsymbol{F}) = -\sum_{i=1}^{n} F_i \log F_i
$$</p>
<p>最大值：$H(\boldsymbol{Q}) = \log n$（均匀分布）</p>
<h4 id="112">11.2 性能改进的理论原因<a class="toc-link" href="#112" title="Permanent link">&para;</a></h4>
<p><strong>（1）计算效率</strong>：</p>
<p>均衡负载下，总计算时间为：</p>
<p>$$
T_{\text{total}} = \max_{i} T_i \approx \frac{mk}{n} \cdot T_{\text{expert}}
$$</p>
<p>不均衡时：</p>
<p>$$
T_{\text{total}} = \max_{i} L_i \cdot T_{\text{expert}} \gg \frac{mk}{n} \cdot T_{\text{expert}}
$$</p>
<p><strong>加速比</strong>：</p>
<p>$$
\text{Speedup} = \frac{\max_i L_i^{\text{before}}}{\max_i L_i^{\text{after}}} = \frac{\max_i L_i^{\text{before}}}{mk/n}
$$</p>
<p><strong>（2）模型质量</strong>：</p>
<p>传统Aux Loss会损害主任务，因为：</p>
<p>$$
\nabla_{\theta} \mathcal{L}<em _theta="\theta">{\text{LM}} \quad \text{与} \quad \nabla</em>
$$} \mathcal{L}_{\text{aux}} \quad \text{可能反向</p>
<p>导致妥协解：</p>
<p>$$
\theta^* \neq \arg\min_{\theta} \mathcal{L}_{\text{LM}}
$$</p>
<p>Loss-Free避免了这个问题：</p>
<p>$$
\theta^<em> = \arg\min_{\theta} \mathcal{L}_{\text{LM}}(\theta; \boldsymbol{b}^</em>)
$$</p>
<p><strong>（3）专家专业化（Expert Specialization）</strong>：</p>
<p>负载均衡有助于每个专家学习不同的模式：</p>
<p>$$
\min_{{\boldsymbol{\theta}<em _in="\in" _mathcal_T="\mathcal{T" i="i">i^{(E)}}} \mathbb{E}\left[\sum</em>)\right]
$$}_k(\boldsymbol{x})} \tilde{\rho}_i(\boldsymbol{x}) \mathcal{L}(\boldsymbol{e}_i(\boldsymbol{x}), \boldsymbol{y</p>
<p>均衡负载确保每个专家都有足够的训练样本，避免某些专家"饿死"。</p>
<h4 id="113">11.3 消融实验分析<a class="toc-link" href="#113" title="Permanent link">&para;</a></h4>
<p><strong>（1）不同激活函数的影响</strong>：</p>
<ul>
<li>Sigmoid：$\rho_i \in (0,1)$，独立，适合 $\alpha=0.001$</li>
<li>Softmax：$\sum_i \rho_i = 1$，相互依赖，可能需要调整 $\alpha$</li>
<li>ReLU：$\rho_i \in [0, \infty)$，尺度不固定，需要仔细调整</li>
</ul>
<p><strong>（2）SignSGD vs RMS-SGD</strong>：</p>
<p>实验表明RMS-SGD通常更好：
- 更平滑的收敛曲线
- 更低的最终CV值
- 对学习率 $\alpha$ 的鲁棒性更强</p>
<p><strong>理论解释</strong>：RMS归一化保留了梯度的方向信息，而Sign仅保留符号，丢失了幅度信息。</p>
<p><strong>（3）学习率 $\alpha$ 的影响</strong>：</p>
<ul>
<li>$\alpha$ 太小：收敛慢，可能在训练结束前未达到均衡</li>
<li>$\alpha$ 太大：可能产生振荡或过冲</li>
<li>最优 $\alpha$ 依赖于batch size、专家数等</li>
</ul>
<p><strong>经验法则</strong>：</p>
<p>$$
\alpha \approx \frac{C_0}{\sqrt{n}}
$$</p>
<p>其中 $C_0 \approx 0.03$ 对Sigmoid激活。</p>
<h3 id="12-vq-vae">12. 扩展应用：VQ-VAE的编码表坍缩<a class="toc-link" href="#12-vq-vae" title="Permanent link">&para;</a></h3>
<h4 id="121">12.1 问题描述<a class="toc-link" href="#121" title="Permanent link">&para;</a></h4>
<p>Vector Quantization VAE（VQ-VAE）中的编码表坍缩（Codebook Collapse）：某些编码向量从不被使用，导致编码表的有效容量减小。</p>
<p><strong>形式化</strong>：设编码表 ${\boldsymbol{c}_1, \ldots, \boldsymbol{c}_K}$，编码过程为</p>
<p>$$
\text{encode}(\boldsymbol{z}) = \arg\min_{i} |\boldsymbol{z} - \boldsymbol{c}_i|_2
$$</p>
<p><strong>问题</strong>：某些 $\boldsymbol{c}_i$ 可能永远不被选中。</p>
<h4 id="122-loss-free">12.2 Loss-Free解决方案<a class="toc-link" href="#122-loss-free" title="Permanent link">&para;</a></h4>
<p>引入偏置 $\boldsymbol{b} = [b_1, \ldots, b_K]$：</p>
<p>$$
\text{encode}(\boldsymbol{z}; \boldsymbol{b}) = \arg\min_{i} |\boldsymbol{z} - \boldsymbol{c}_i|_2 + b_i
$$</p>
<p><strong>目标</strong>：均衡使用频率 $\boldsymbol{F} = [F_1, \ldots, F_K]$，其中</p>
<p>$$
F_i = \mathbb{E}<em _text_encode="\text{encode">{\boldsymbol{z}}[\mathbb{1}</em>]
$$}(\boldsymbol{z}; \boldsymbol{b}) = i</p>
<p><strong>更新规则</strong>：</p>
<p>$$
\boldsymbol{b} \leftarrow \boldsymbol{b} - \alpha (\boldsymbol{F} - \boldsymbol{Q})
$$</p>
<p>其中 $\boldsymbol{Q} = (\frac{1}{K}, \ldots, \frac{1}{K})$。</p>
<p><strong>优势</strong>：
- 不需要修改VQ-VAE的核心损失
- 训练和推理一致
- 自动适应数据分布</p>
<h3 id="_9">总结<a class="toc-link" href="#_9" title="Permanent link">&para;</a></h3>
<p>Loss-Free方法的数学本质是：
1. <strong>参数空间分离</strong>：通过引入偏置 $\boldsymbol{b}$，将负载均衡与主任务优化解耦
2. <strong>直通估计器</strong>：利用STE处理不可微的Top-K操作
3. <strong>自适应调整</strong>：通过梯度下降自动调整负载分布
4. <strong>最优传输视角</strong>：隐式求解从当前分布到均匀分布的最优传输</p>
<p>这种方法在理论上优雅，实践上有效，具有广泛的应用潜力。</p>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="muon续集为什么我们选择尝试muon.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#165 Muon续集：为什么我们选择尝试Muon？</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="初探mup超参数的跨模型尺度迁移规律.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#167 初探MuP：超参数的跨模型尺度迁移规律</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#moe3">MoE环游记：3、换个思路来分配</a><ul>
<li><a href="#_1">方法大意</a></li>
<li><a href="#_2">手搓梯度</a></li>
<li><a href="#_3">改良版本</a></li>
<li><a href="#_4">一脉相承</a></li>
<li><a href="#_5">相关细节</a></li>
<li><a href="#_6">延伸思考</a></li>
<li><a href="#_7">文章小结</a></li>
<li><a href="#_8">公式推导与注释</a><ul>
<li><a href="#1-moe">1. MoE的数学模型</a></li>
<li><a href="#2">2. 专家分配问题的最优化表述</a></li>
<li><a href="#3">3. 负载均衡约束的数学表征</a></li>
<li><a href="#4">4. 路由策略的数学分析</a></li>
<li><a href="#5-loss-free">5. Loss-Free方法的最优化理论</a></li>
<li><a href="#6">6. 最优传输理论的联系</a></li>
<li><a href="#7">7. 梯度计算与反向传播</a></li>
<li><a href="#8-capacity-factor">8. 容量因子（Capacity Factor）的影响</a></li>
<li><a href="#9">9. 损失函数设计（辅助损失对比）</a></li>
<li><a href="#10">10. 收敛性分析与理论保证</a></li>
<li><a href="#11_1">11. 实验结果的理论解释</a></li>
<li><a href="#12-vq-vae">12. 扩展应用：VQ-VAE的编码表坍缩</a></li>
<li><a href="#_9">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>