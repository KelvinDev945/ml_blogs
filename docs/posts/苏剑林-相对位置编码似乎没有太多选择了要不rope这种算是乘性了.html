<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>让研究人员绞尽脑汁的Transformer位置编码 | ML & Math Blog Posts</title>
    <meta name="description" content="让研究人员绞尽脑汁的Transformer位置编码&para;
原文链接: https://spaces.ac.cn/archives/8130
发布日期: 

不同于RNN、CNN等模型，对于Transformer模型来说，位置编码的加入是必不可少的，因为纯粹的Attention模块是无法捕捉输入顺序的，即无法区分不同位置的Token。为此我们大体有两个选择：1、想办法将位置信息融入到输入中，这...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering with equation numbering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        tags: 'ams',  // Enable equation numbering with AMS style
        tagSide: 'right',  // Place equation numbers on the right
        tagIndent: '0.8em',  // Indentation for equation numbers
        multlineWidth: '85%'
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=复数">复数</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #107 让研究人员绞尽脑汁的Transformer位置编码
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#107</span>
                让研究人员绞尽脑汁的Transformer位置编码
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> </span>
                
                <span class="ms-3">
                    <i class="fas fa-link"></i>
                    <a href="https://spaces.ac.cn/archives/8130" target="_blank" rel="noopener">原文链接</a>
                </span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=复数" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 复数</span>
                </a>
                
                <a href="../index.html?tags=attention" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> attention</span>
                </a>
                
                <a href="../index.html?tags=位置编码" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 位置编码</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
                <a href="../index.html?tags=attention" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> attention</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="transformer">让研究人员绞尽脑汁的Transformer位置编码<a class="toc-link" href="#transformer" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/8130">https://spaces.ac.cn/archives/8130</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>不同于RNN、CNN等模型，对于Transformer模型来说，位置编码的加入是必不可少的，因为纯粹的Attention模块是无法捕捉输入顺序的，即无法区分不同位置的Token。为此我们大体有两个选择：1、想办法将位置信息融入到输入中，这构成了绝对位置编码的一般做法；2、想办法微调一下Attention结构，使得它有能力分辨不同位置的Token，这构成了相对位置编码的一般做法。</p>
<p>虽然说起来主要就是绝对位置编码和相对位置编码两大类，但每一类其实又能衍生出各种各样的变种，为此研究人员可算是煞费苦心、绞尽脑汁了，此外还有一些不按套路出牌的位置编码。本文就让我们来欣赏一下研究人员为了更好地表达位置信息所构建出来的“八仙过海，各显神通”般的编码方案。</p>
<h2 id="_1">绝对位置编码<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h2>
<p>形式上来看，绝对位置编码是相对简单的一种方案，但即便如此，也不妨碍各路研究人员的奇思妙想，也有不少的变种。一般来说，绝对位置编码会加到输入中：在输入的第$k$个向量$\boldsymbol{x}_k$中加入位置向量$\boldsymbol{p}_k$变为$\boldsymbol{x}_k + \boldsymbol{p}_k$，其中$\boldsymbol{p}_k$只依赖于位置编号$k$。</p>
<h3 id="_2">训练式<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h3>
<p>很显然，绝对位置编码的一个最朴素方案是不特意去设计什么，而是直接将位置编码当作可训练参数，比如最大长度为512，编码维度为768，那么就初始化一个$512\times 768$的矩阵作为位置向量，让它随着训练过程更新。现在的BERT、GPT等模型所用的就是这种位置编码，事实上它还可以追溯得更早，比如2017年Facebook的<a href="https://papers.cool/arxiv/1705.03122">《Convolutional Sequence to Sequence Learning》</a>就已经用到了它。</p>
<p>对于这种训练式的绝对位置编码，一般的认为它的缺点是没有外推性，即如果预训练最大长度为512的话，那么最多就只能处理长度为512的句子，再长就处理不了了。当然，也可以将超过512的位置向量随机初始化，然后继续微调。但笔者最近的研究表明，通过层次分解的方式，可以使得绝对位置编码能外推到足够长的范围，同时保持还不错的效果，细节请参考笔者之前的博文<a href="/archives/7947">《层次分解位置编码，让BERT可以处理超长文本》</a>。因此，其实外推性也不是绝对位置编码的明显缺点。</p>
<h3 id="_3">三角式<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h3>
<p>三角函数式位置编码，一般也称为Sinusoidal位置编码，是Google的论文<a href="https://papers.cool/arxiv/1706.03762">《Attention is All You Need》</a>所提出来的一个显式解：<br />
\begin{equation}\left\{\begin{aligned}&amp;\boldsymbol{p}<em 2i_1="2i+1" k_="k,">{k,2i}=\sin\Big(k/10000^{2i/d}\Big)\\
&amp;\boldsymbol{p}</em>\Big)}=\cos\Big(k/10000^{2i/d
\end{aligned}\right.\end{equation}<br />
其中$\boldsymbol{p}<em k_2i_1="k,2i+1">{k,2i},\boldsymbol{p}</em>$分别是位置$k$的编码向量的第$2i,2i+1$个分量，$d$是位置向量的维度。</p>
<p>很明显，三角函数式位置编码的特点是有显式的生成规律，因此可以期望于它有一定的外推性。另外一个使用它的理由是：由于$\sin(\alpha+\beta)=\sin\alpha\cos\beta+\cos\alpha\sin\beta$以及$\cos(\alpha+\beta)=\cos\alpha\cos\beta-\sin\alpha\sin\beta$，这表明位置$\alpha+\beta$的向量可以表示成位置$\alpha$和位置$\beta$的向量组合，这提供了表达相对位置信息的可能性。但很奇怪的是，现在我们很少能看到直接使用这种形式的绝对位置编码的工作，原因不详。</p>
<h3 id="_4">递归式<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h3>
<p>原则上来说，RNN模型不需要位置编码，它在结构上就自带了学习到位置信息的可能性（因为递归就意味着我们可以训练一个“数数”模型），因此，如果在输入后面先接一层RNN，然后再接Transformer，那么理论上就不需要加位置编码了。同理，我们也可以用RNN模型来学习一种绝对位置编码，比如从一个向量$\boldsymbol{p}<em k_1="k+1">0$出发，通过递归格式$\boldsymbol{p}</em>_k)$来得到各个位置的编码向量。}=f(\boldsymbol{p</p>
<p>ICML 2020的论文<a href="https://papers.cool/arxiv/2003.09229">《Learning to Encode Position for Transformer with Continuous Dynamical Model》</a>把这个思想推到了极致，它提出了用微分方程（ODE）$d\boldsymbol{p}_t/dt=\boldsymbol{h}(\boldsymbol{p}_t,t)$的方式来建模位置编码，该方案称之为FLOATER。显然，FLOATER也属于递归模型，函数$\boldsymbol{h}(\boldsymbol{p}_t,t)$可以通过神经网络来建模，因此这种微分方程也称为神经微分方程，关于它的工作最近也逐渐多了起来。</p>
<p>理论上来说，基于递归模型的位置编码也具有比较好的外推性，同时它也比三角函数式的位置编码有更好的灵活性（比如容易证明三角函数式的位置编码就是FLOATER的某个特解）。但是很明显，递归形式的位置编码牺牲了一定的并行性，可能会带速度瓶颈。</p>
<h3 id="_5">相乘式<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h3>
<p>刚才我们说到，输入$\boldsymbol{x}<em>k$与绝对位置编码$\boldsymbol{p}_k$的组合方式一般是$\boldsymbol{x}_k + \boldsymbol{p}_k$，那有没有“不一般”的组合方式呢？比如$\boldsymbol{x}_k \otimes \boldsymbol{p}_k$（逐位相乘）？我们平时在搭建模型的时候，对于融合两个向量有多种方式， _相加、相乘甚至拼接都是可以考虑的</em> ，怎么大家在做绝对位置编码的时候，都默认只考虑相加了？</p>
<p>很抱歉，笔者也不知道答案。可能大家默认选择相加是因为向量的相加具有比较鲜明的几何意义，但是对于深度学习模型来说，这种几何意义其实没有什么实际的价值。最近笔者看到的一个实验显示，似乎将“加”换成“乘”，也就是$\boldsymbol{x}_k \otimes \boldsymbol{p}_k$的方式，似乎比$\boldsymbol{x}_k + \boldsymbol{p}_k$能取得更好的结果。具体效果笔者也没有完整对比过，只是提供这么一种可能性。关于实验来源，可以参考<a href="https://zhuanlan.zhihu.com/p/183234823">《中文语言模型研究：(1) 乘性位置编码》</a>。</p>
<h2 id="_6">相对位置编码<a class="toc-link" href="#_6" title="Permanent link">&para;</a></h2>
<p>相对位置并没有完整建模每个输入的位置信息，而是在算Attention的时候考虑当前位置与被Attention的位置的相对距离，由于自然语言一般更依赖于相对位置，所以相对位置编码通常也有着优秀的表现。对于相对位置编码来说，它的灵活性更大，更加体现出了研究人员的“天马行空”。</p>
<h3 id="_7">经典式<a class="toc-link" href="#_7" title="Permanent link">&para;</a></h3>
<p>相对位置编码起源于Google的论文<a href="https://papers.cool/arxiv/1803.02155">《Self-Attention with Relative Position Representations》</a>，华为开源的NEZHA模型也用到了这种位置编码，后面各种相对位置编码变体基本也是依葫芦画瓢的简单修改。</p>
<p>一般认为，相对位置编码是由绝对位置编码启发而来，考虑一般的带绝对位置编码的Attention：<br />
\begin{equation}\left\{\begin{aligned}
\boldsymbol{q}<em i_j="i,j">i =&amp;\, (\boldsymbol{x}_i + \boldsymbol{p}_i)\boldsymbol{W}_Q \\
\boldsymbol{k}_j =&amp;\, (\boldsymbol{x}_j + \boldsymbol{p}_j)\boldsymbol{W}_K \\
\boldsymbol{v}_j =&amp;\, (\boldsymbol{x}_j + \boldsymbol{p}_j)\boldsymbol{W}_V \\
a</em>} =&amp;\, softmax\left(\boldsymbol{q<em i_j="i,j">i \boldsymbol{k}_j^{\top}\right)\\
\boldsymbol{o}_i =&amp;\, \sum_j a</em>}\boldsymbol{v<em i_j="i,j">j
\end{aligned}\right.\end{equation}<br />
其中$softmax$对$j$那一维归一化，这里的向量都是指行向量。我们初步展开$\boldsymbol{q}_i \boldsymbol{k}_j^{\top}$：<br />
\begin{equation}
\boldsymbol{q}_i \boldsymbol{k}_j^{\top} = \left(\boldsymbol{x}_i + \boldsymbol{p}_i\right)\boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\left(\boldsymbol{x}_j + \boldsymbol{p}_j\right)^{\top} = \left(\boldsymbol{x}_i \boldsymbol{W}_Q + \boldsymbol{p}_i \boldsymbol{W}_Q\right)\left(\boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top} + \boldsymbol{W}_K^{\top}\boldsymbol{p}_j^{\top}\right)
\end{equation}<br />
为了引入相对位置信息，Google把第一项位置去掉，第二项$\boldsymbol{p}_j \boldsymbol{W}_K$改为二元位置向量$\boldsymbol{R}</em>$，变成}^{K<br />
\begin{equation}
a_{i,j} = softmax\left(\boldsymbol{x}<em i_j="i,j">i \boldsymbol{W}_Q\left(\boldsymbol{x}_j\boldsymbol{W}_K + \color{green}{\boldsymbol{R}</em>\right)}^K}\right)^{\top
\end{equation}<br />
以及$\boldsymbol{o}<em i_j="i,j">i =\sum\limits_j a</em>}\boldsymbol{v<em i_j="i,j">j = \sum\limits_j a</em>}(\boldsymbol{x<em i_j="i,j">j\boldsymbol{W}_V + \boldsymbol{p}_j\boldsymbol{W}_V)$中的$\boldsymbol{p}_j \boldsymbol{W}_V$换成$\boldsymbol{R}</em>$：}^{V<br />
\begin{equation}\boldsymbol{o}<em i_j="i,j">i = \sum_j a</em>}\left(\boldsymbol{x<em i_j="i,j">j\boldsymbol{W}_V + \color{green}{\boldsymbol{R}</em>\right)}^{V}
\end{equation}<br />
所谓相对位置，是将本来依赖于二元坐标$(i,j)$的向量$\boldsymbol{R}<em i_j="i,j">{i,j}^{K},\boldsymbol{R}</em>$，改为只依赖于相对距离$i-j$，并且通常来说会进行截断，以适应不同任意的距离}^{V<br />
\begin{equation}\begin{aligned}
\boldsymbol{R}<em _min="\min">{i,j}^{K} = \boldsymbol{p}_K\left[\text{clip}(i-j, p</em>)\right]\\}, p_{\max
\boldsymbol{R}<em _min="\min">{i,j}^{V} = \boldsymbol{p}_V\left[\text{clip}(i-j, p</em>)\right]}, p_{\max
\end{aligned}\label{eq:rp-clip}\end{equation}<br />
这样一来，只需要有限个位置编码，就可以表达出任意长度的相对位置（因为进行了截断），不管$\boldsymbol{p}_K,\boldsymbol{p}_V$是选择可训练式的还是三角函数式的，都可以达到处理任意长度文本的需求。</p>
<h3 id="xlnet">XLNET式<a class="toc-link" href="#xlnet" title="Permanent link">&para;</a></h3>
<p>XLNET式位置编码其实源自Transformer-XL的论文<a href="https://papers.cool/arxiv/1901.02860">《Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context》</a>，只不过因为使用了Transformer-XL架构的<a href="https://papers.cool/arxiv/1906.08237">XLNET</a>模型并在一定程度上超过了BERT后，Transformer-XL才算广为人知，因此这种位置编码通常也被冠以XLNET之名。</p>
<p>XLNET式位置编码源于对上述$\boldsymbol{q}<em i-j="i-j">i \boldsymbol{k}_j^{\top}$的完全展开：<br />
\begin{equation}
\boldsymbol{q}_i \boldsymbol{k}_j^{\top} = \boldsymbol{x}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top} + \boldsymbol{x}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{p}_j^{\top} + \boldsymbol{p}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top} + \boldsymbol{p}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{p}_j^{\top}\label{eq:qk-exp}
\end{equation}<br />
Transformer-XL的做法很简单，直接将$\boldsymbol{p}_j$替换为相对位置向量$\boldsymbol{R}</em>}$，至于两个$\boldsymbol{p<em i-j="i-j">i$，则干脆替换为两个可训练的向量$\boldsymbol{u},\boldsymbol{v}$：<br />
\begin{equation}\boldsymbol{x}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top} + \boldsymbol{x}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\color{green}{\boldsymbol{R}</em>}^{\top}} + \color{red}{\boldsymbol{u}}\boldsymbol{W<em i-j="i-j">Q \boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top} + \color{red}{\boldsymbol{v}} \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\color{green}{\boldsymbol{R}</em>}^{\top}
\end{equation}<br />
该编码方式中的$\boldsymbol{R}<em i-j="i-j">{i-j}$没有像式$\eqref{eq:rp-clip}$那样进行截断，而是直接用了Sinusoidal式的生成方案，由于$\boldsymbol{R}</em>}$的编码空间与$\boldsymbol{x<em i-j="i-j">j$不一定相同，所以$\boldsymbol{R}</em>}$前面的$\boldsymbol{W<em K_R="K,R">K^{\top}$换了另一个独立的矩阵$\boldsymbol{W}</em>}^{\top}$，还有$\color{red}{\boldsymbol{u}}\boldsymbol{W<em K_R="K,R">Q$ 、$\color{red}{\boldsymbol{v}} \boldsymbol{W}_Q$可以直接合并为单个$\color{red}{\boldsymbol{u}}$ 、$\color{red}{\boldsymbol{v}}$，所以最终使用的式子是<br />
\begin{equation}\boldsymbol{x}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top} + \boldsymbol{x}_i \boldsymbol{W}_Q \boldsymbol{W}</em>}^{\top}\color{green}{\boldsymbol{R<em K_R="K,R">{i-j}^{\top}} + \color{red}{\boldsymbol{u}}\boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top} + \color{red}{\boldsymbol{v}} \boldsymbol{W}</em>}^{\top}\color{green}{\boldsymbol{R<em i_j="i,j">{i-j}^{\top}}
\end{equation}<br />
此外，$\boldsymbol{v}_j$上的位置偏置就直接去掉了，即直接令$\boldsymbol{o}_i = \sum\limits_j a</em>_j$上去了。}\boldsymbol{x}_j\boldsymbol{W}_V$。似乎从这个工作开始，后面的相对位置编码都只加到Attention矩阵上去，而不加到$\boldsymbol{v</p>
<h3 id="t5">T5式<a class="toc-link" href="#t5" title="Permanent link">&para;</a></h3>
<p>T5模型出自文章<a href="https://papers.cool/arxiv/1910.10683">《Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer》</a>，里边用到了一种更简单的相对位置编码。思路依然源自展开式$\eqref{eq:qk-exp}$，如果非要分析每一项的含义，那么可以分别理解为“输入-输入”、“输入-位置”、“位置-输入”、“位置-位置”四项注意力的组合。如果我们认为输入信息与位置信息应该是独立（解耦）的，那么它们就不应该有过多的交互，所以“输入-位置”、“位置-输入”两项Attention可以删掉，而$\boldsymbol{p}<em i_j="i,j">i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{p}_j^{\top}$实际上只是一个只依赖于$(i,j)$的标量，我们可以直接将它作为参数训练出来，即简化为<br />
\begin{equation}\boldsymbol{x}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top} + \color{green}{\boldsymbol{\beta}</em>}}\end{equation
说白了，它仅仅是在Attention矩阵的基础上加一个可训练的偏置项而已，而跟XLNET式一样，在$\boldsymbol{v}_j$上的位置偏置则直接被去掉了。包含同样的思想的还有微软在ICLR 2021的论文<a href="https://papers.cool/arxiv/2006.15595">《Rethinking Positional Encoding in Language Pre-training》</a>中提出的TUPE位置编码。</p>
<p>比较“别致”的是，不同于常规位置编码对将$\boldsymbol{\beta}_{i,j}$视为$i-j$的函数并进行截断的做法，T5对相对位置进行了一个“分桶”处理，即相对位置是$i-j$的位置实际上对应的是$f(i-j)$位置，映射关系如下：<br />
\begin{array}{c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c}
\hline
i - j &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15\\
\hline
f(i-j) &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 8 &amp; 8 &amp; 8 &amp; 9 &amp; 9 &amp; 9 &amp; 9 \\
\hline
i - j &amp; 16 &amp; 17 &amp; 18 &amp; 19 &amp; 20 &amp; 21 &amp; 22 &amp; 23 &amp; 24 &amp; 25 &amp; 26 &amp; 27 &amp; 28 &amp; 29 &amp; 30 &amp; \cdots\\
\hline
f(i-j) &amp; 10 &amp; 10 &amp; 10 &amp; 10 &amp; 10 &amp; 10 &amp; 10 &amp; 11 &amp; 11 &amp; 11 &amp; 11 &amp; 11 &amp; 11 &amp; 11 &amp; 11 &amp; \cdots \\
\hline\end{array}<br />
具体的映射代码，读者自行看源码就好。这个设计的思路其实也很直观，就是比较邻近的位置（0～7），我们需要比较得精细一些，所以给它们都分配一个独立的位置编码，至于稍远的位置（比如8～11），我们不用区分得太清楚，所以它们可以共用一个位置编码，距离越远，共用的范围就可以越大，直到达到指定范围再clip。</p>
<h3 id="deberta">DeBERTa式<a class="toc-link" href="#deberta" title="Permanent link">&para;</a></h3>
<p>DeBERTa也是微软搞的，去年6月就发出来了，论文为<a href="https://papers.cool/arxiv/2006.03654">《DeBERTa: Decoding-enhanced BERT with Disentangled Attention》</a>，最近又小小地火了一把，一是因为它正式中了ICLR 2021，二则是它登上<a href="https://super.gluebenchmark.com/">SuperGLUE</a>的榜首，成绩稍微超过了T5。</p>
<p>其实DeBERTa的主要改进也是在位置编码上，同样还是从展开式$\eqref{eq:qk-exp}$出发，T5是干脆去掉了第2、3项，只保留第4项并替换为相对位置编码，而DeBERTa则刚刚相反，它扔掉了第4项，保留第2、3项并且替换为相对位置编码（果然， <em>科研就是枚举所有的排列组合看哪个最优</em> ）：<br />
\begin{equation}
\boldsymbol{q}<em i_j="i,j">i \boldsymbol{k}_j^{\top} = \boldsymbol{x}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top} + \boldsymbol{x}_i \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\color{green}{\boldsymbol{R}</em>}^{\top}} + \color{green}{\boldsymbol{R<em i_j="i,j">{j,i}} \boldsymbol{W}_Q \boldsymbol{W}_K^{\top}\boldsymbol{x}_j^{\top}
\end{equation}<br />
至于$\boldsymbol{R}</em>$那样进行截断的，没有特别的地方。}$的设计也是像式$\eqref{eq:rp-clip</p>
<p>不过，DeBERTa比较有意思的地方，是提供了使用相对位置和绝对位置编码的一个新视角，它指出NLP的大多数任务可能都只需要相对位置信息，但确实有些场景下绝对位置信息更有帮助，于是它将整个模型分为两部分来理解。以Base版的MLM预训练模型为例，它一共有13层，前11层只是用相对位置编码，这部分称为Encoder，后面2层加入绝对位置信息，这部分它称之为Decoder，还弄了个简称EMD（Enhanced Mask Decoder）；至于下游任务的微调截断，则是使用前11层的Encoder加上1层的Decoder来进行。</p>
<p>SuperGLUE上的成绩肯定了DeBERTa的价值，但是 <em>它论文的各种命名真的是让人觉得极度不适</em> ，比如它自称的“Encoder”、“Decoder”就很容易让人误解这是一个Seq2Seq模型，比如EMD这个简称也跟Earth Mover's Distance重名。虽然有时候重名是不可避免的，但它重的名都是ML界大家都比较熟悉的对象，相当容易引起误解，真不知道作者是怎么想的...</p>
<h2 id="_8">其他位置编码<a class="toc-link" href="#_8" title="Permanent link">&para;</a></h2>
<p>绝对位置编码和相对位置编码虽然花样百出，但仍然算是经典范围内，从上述介绍中我们依然可以体会到满满的套路感。除此之外，还有一些并不按照常规套路出牌，它们同样也表达了位置编码。</p>
<h3 id="cnn">CNN式<a class="toc-link" href="#cnn" title="Permanent link">&para;</a></h3>
<p>尽管经典的将CNN用于NLP的工作<a href="https://papers.cool/arxiv/1705.03122">《Convolutional Sequence to Sequence Learning》</a>往里边加入了位置编码，但我们知道一般的CNN模型尤其是图像中的CNN模型，都是没有另外加位置编码的，那CNN模型究竟是怎么捕捉位置信息的呢？</p>
<p>如果让笔者来回答，那么答案可能是卷积核的各项异性导致了它能分辨出不同方向的相对位置。不过ICLR 2020的论文<a href="https://papers.cool/arxiv/2001.08248">《How Much Position Information Do Convolutional Neural Networks Encode?》</a>给出了一个可能让人比较意外的答案：CNN模型的位置信息，是Zero Padding泄漏的！</p>
<p>我们知道，为了使得卷积编码过程中的feature保持一定的大小，我们通常会对输入padding一定的0，而这篇论文显示该操作导致模型有能力识别位置信息。也就是说，卷积核的各向异性固然重要，但是最根本的是zero padding的存在，那么可以想象，实际上提取的是当前位置与padding的边界的相对距离。</p>
<p>不过，这个能力依赖于CNN的局部性，像Attention这种全局的无先验结构并不适用，如果只关心Transformer位置编码方案的读者，这就权当是扩展一下视野吧。</p>
<h3 id="_9">复数式<a class="toc-link" href="#_9" title="Permanent link">&para;</a></h3>
<p>复数式位置编码可谓是 <em>最特立独行</em> 的一种位置编码方案了，它来自ICLR 2020的论文<a href="https://papers.cool/arxiv/1912.12333">《Encoding word order in complex embeddings》</a>。论文的主要思想是结合复数的性质以及一些基本原理，推导出了它的位置编码形式（Complex Order）为：<br />
\begin{equation}\left[r_{j, 1} e^{\text{i}\left(\omega_{j, 1} k+\theta_{j, 1}\right)}, \ldots, r_{j, 2} e^{\text{i}\left(\omega_{j, 2} k+\theta_{j, 2}\right)}, \cdots, r_{j, d} e^{\text{i}\left(\omega_{j, d} k+\theta_{j, d}\right)}\right]\label{eq:complex}\end{equation}<br />
这里的$\text{i}$是虚数单位，$j$代表某个词，$k$代表该词所在的位置，而<br />
\begin{equation}\begin{aligned}
\boldsymbol{r}<em 1="1" j_="j,">j =&amp;\, [r</em>]\\},r_{j, 2},\cdots,r_{j, d
\boldsymbol{\omega}<em 1="1" j_="j,">j =&amp;\, [\omega</em>]\\},\omega_{j, 2},\cdots,\omega_{j, d
\boldsymbol{\theta}<em 1="1" j_="j,">j =&amp;\, [\theta</em>]\\},\theta_{j, 2},\cdots,\theta_{j, d
\end{aligned}\end{equation}<br />
代表词$j$的三组词向量。你没看错，它确实假设每个词有三组跟位置无关的词向量了（当然可以按照某种形式进行参数共享，使得它退化为两组甚至一组），然后跟位置$k$相关的词向量就按照上述公式运算。</p>
<p>你以为引入多组词向量就是它最特立独行的地方了？并不是！我们看到式$\eqref{eq:complex}$还是复数形式，你猜它接下来怎么着？将它实数化？非也，它是将它直接用于复数模型！也就是说，它走的是一条复数模型路线，不仅仅输入的Embedding层是复数的，里边的每一层Transformer都是复数的，它还实现和对比了复数版的Fasttext、LSTM、CNN等模型！这篇文章的一作是Benyou Wang，可以搜到他的相关工作基本上都是围绕着复数模型展开的，可谓复数模型的铁杆粉了～</p>
<h3 id="_10">融合式<a class="toc-link" href="#_10" title="Permanent link">&para;</a></h3>
<p>无偶独有，利用复数的形式，笔者其实也构思了一种比较巧的位置编码，它可以将绝对位置编码与相对位置编码融于一体，分享在此，有兴趣的读者欢迎一起交流研究。</p>
<p>简单起见，我们先假设$\boldsymbol{q}_m,\boldsymbol{k}_n$是所在位置分别为$m,n$的二维行向量，既然是二维，那么我们可以将它当作复数来运算。我们知道，Attention关键之处在于向量的内积，用复数表示为<br />
\begin{equation}\langle \boldsymbol{q}_m, \boldsymbol{k}_n\rangle = \text{Re}\left[\boldsymbol{q}_m \boldsymbol{k}_n^<em>\right]\end{equation}<br />
其中$^</em>$是共轭复数，右端的乘法是普通的复数乘法，$\text{Re}[]$表示取结果的实部。上式也就是说：</p>
<blockquote>
<p>两个二维向量的内积，等于把它们当复数看时，一个复数与另一个复数的共轭的乘积实部。</p>
</blockquote>
<p>如果我们将$\boldsymbol{q}_m,\boldsymbol{k}_n$分别乘以$e^{\text{i}m\theta},e^{\text{i}n\theta}$变成$\boldsymbol{q}_m e^{\text{i}m\theta}, \boldsymbol{k}_n e^{\text{i}n\theta}$，那么就相当于给它们配上了绝对位置编码了（因为显式地依赖绝对位置$m,n$），然后放到内积里边，我们有<br />
\begin{equation}\langle \boldsymbol{q}_m e^{\text{i}m\theta}, \boldsymbol{k}_n e^{\text{i}n\theta}\rangle = \text{Re}\left[\left(\boldsymbol{q}_m e^{\text{i}m\theta}\right) \left(\boldsymbol{k}_n e^{\text{i}n\theta}\right)^<em>\right] = \text{Re}\left[\boldsymbol{q}_m \boldsymbol{k}_n^</em> e^{\text{i}(m-n)\theta}\right]\end{equation}<br />
相当有意思的是，内积只依赖于相对位置$m-n$！这就巧妙地将绝对位置与相对位置融合在一起了。</p>
<p>注意，我们没有像Complex Order那么“疯狂”，上述运算本质上还是在实数范畴内的，只不过我们是借助复数来完成了某些推导而已。由上述结果可知，对于位置为$n$的二维实数向量$[x,y]$，我们当它复数来运算，乘以$e^{\text{i}n\theta}$，得到恒等式<br />
\begin{equation}(x + y\text{i})e^{\text{i}n\theta} = (x \cos n\theta - y\sin n\theta) + \text{i} (x \sin n\theta + y\cos n\theta)\end{equation}<br />
这也就是意味着，通过<br />
\begin{equation}\begin{pmatrix}x \\ y\end{pmatrix}<br />
\to<br />
\begin{pmatrix}x \cos n\theta - y\sin n\theta \\ x \sin n\theta + y\cos n\theta
\end{pmatrix} = \begin{pmatrix}x \\ y
\end{pmatrix}\cos n\theta + \begin{pmatrix}-y \\ x
\end{pmatrix}\sin n\theta\end{equation}<br />
来赋予$[x, y]$绝对位置信息，那么在Attention运算的时候也等价于相对位置编码。如果是多于二维的向量，可以考虑每两维为一组进行同样的运算，每一组的$\theta$可以不一样。</p>
<p>这样一来，我们得到了一种融绝对位置与相对位置于一体的位置编码方案，从形式上看它有点像乘性的绝对位置编码，通过在$\boldsymbol{q},\boldsymbol{k}$中施行该位置编码，那么效果就等价于相对位置编码，而如果还需要显式的绝对位置信息，则可以同时在$\boldsymbol{v}$上也施行这种位置编码。总的来说，我们通过绝对位置的操作，可以达到绝对位置的效果，也能达到相对位置的效果，初步实验显示它是可以work的，但还没有充分验证，欢迎大家尝试交流。</p>
<h2 id="_11">文章内容小结<a class="toc-link" href="#_11" title="Permanent link">&para;</a></h2>
<p>本文汇总了一些位置编码的工作，大体分为绝对式、相对式、非套路式三种，从中我们可以看到各种神奇的操作。最后，笔者分享了自己构思的一种融合绝对位置与相对位置的编码方案，供有兴趣的读者参考。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/8130">https://spaces.ac.cn/archives/8130</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Feb. 03, 2021). 《让研究人员绞尽脑汁的Transformer位置编码 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/8130">https://spaces.ac.cn/archives/8130</a></p>
<p>@online{kexuefm-8130,<br />
title={让研究人员绞尽脑汁的Transformer位置编码},<br />
author={苏剑林},<br />
year={2021},<br />
month={Feb},<br />
url={\url{https://spaces.ac.cn/archives/8130}},<br />
} </p>
<hr />
<h2 id="_12">公式推导与注释<a class="toc-link" href="#_12" title="Permanent link">&para;</a></h2>
<p>TODO: 添加详细的数学公式推导和注释</p>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="旁门左道之如何让python的重试代码更加优雅.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#106 旁门左道之如何让Python的重试代码更加优雅</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="隐藏在动量中的梯度累积少更新几步效果反而更好.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#108 隐藏在动量中的梯度累积：少更新几步，效果反而更好？</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#transformer">让研究人员绞尽脑汁的Transformer位置编码</a><ul>
<li><a href="#_1">绝对位置编码</a><ul>
<li><a href="#_2">训练式</a></li>
<li><a href="#_3">三角式</a></li>
<li><a href="#_4">递归式</a></li>
<li><a href="#_5">相乘式</a></li>
</ul>
</li>
<li><a href="#_6">相对位置编码</a><ul>
<li><a href="#_7">经典式</a></li>
<li><a href="#xlnet">XLNET式</a></li>
<li><a href="#t5">T5式</a></li>
<li><a href="#deberta">DeBERTa式</a></li>
</ul>
</li>
<li><a href="#_8">其他位置编码</a><ul>
<li><a href="#cnn">CNN式</a></li>
<li><a href="#_9">复数式</a></li>
<li><a href="#_10">融合式</a></li>
</ul>
</li>
<li><a href="#_11">文章内容小结</a></li>
<li><a href="#_12">公式推导与注释</a></li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>