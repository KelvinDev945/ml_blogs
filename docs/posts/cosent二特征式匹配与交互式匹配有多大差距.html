<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoSENT（二）：特征式匹配与交互式匹配有多大差距？ | ML & Math Blog Posts</title>
    <meta name="description" content="CoSENT（二）：特征式匹配与交互式匹配有多大差距？&para;
原文链接: https://spaces.ac.cn/archives/8860
发布日期: 

一般来说，文本匹配有交互式（Interaction-based）和特征式（Representation-based）两种实现方案，其中交互式是指将两个文本拼接在一起当成单文本进行分类，而特征式则是指两个句子分别由编码器编码为句向量后再...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering with equation numbering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        tags: 'ams',  // Enable equation numbering with AMS style
        tagSide: 'right',  // Place equation numbers on the right
        tagIndent: '0.8em',  // Indentation for equation numbers
        multlineWidth: '85%'
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=语义">语义</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #16 CoSENT（二）：特征式匹配与交互式匹配有多大差距？
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#16</span>
                CoSENT（二）：特征式匹配与交互式匹配有多大差距？
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> 2022-01-12</span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=语义" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 语义</span>
                </a>
                
                <a href="../index.html?tags=语义相似度" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 语义相似度</span>
                </a>
                
                <a href="../index.html?tags=对比学习" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 对比学习</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
                <a href="../index.html?tags=attention" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> attention</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="cosent">CoSENT（二）：特征式匹配与交互式匹配有多大差距？<a class="toc-link" href="#cosent" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/8860">https://spaces.ac.cn/archives/8860</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>一般来说，文本匹配有交互式（Interaction-based）和特征式（Representation-based）两种实现方案，其中交互式是指将两个文本拼接在一起当成单文本进行分类，而特征式则是指两个句子分别由编码器编码为句向量后再做简单的融合处理（算cos值或者接一个浅层网络）。通常的结论是，交互式由于使得两个文本能够进行充分的比较，所以它准确性通常较好，但明显的缺点是在检索场景的效率较差；而特征式则可以提前计算并缓存好句向量，所以它有着较高的效率，但由于句子间的交互程度较浅，所以通常效果不如交互式。</p>
<p>上一篇文章笔者介绍了CoSENT，它本质上也是一种特征式方案，并且相比以往的特征式方案效果有所提高。于是笔者的好胜心就上来了：CoSENT能比得过交互式吗？特征式相比交互式的差距有多远呢？本文就来做个比较。</p>
<h2 id="_1">自动阈值<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h2>
<p>在文章<a href="/archives/8847">《CoSENT（一）：比Sentence-BERT更有效的句向量方案》</a>中，我们评测CoSENT所用的指标是Spearman系数，它是一个只依赖于预测结果相对顺序的指标，不依赖于阈值，比较适合检索场景的评测。但如果评测指标是accuracy或者F1这些分类指标，则必须确定一个阈值，将预测结果大于这个数的预测结果视为正、小于则为负，然后才能计算指标。在二分类的场景，我们用二分法就可以有效地确定这个阈值。</p>
<p>然而，搜索阈值确实并非二分类所独有，一般的多分类任务其实也存在着同样的需求，所以这里将这个问题展开来谈谈。比如对于$n$分类的预测分布$[p_1,p_2,\dots,p_n]$，我们一般是用概率最大的类别，即$\mathop{\text{argmax}}\,(p_1,p_2,\dots,p_n)$作为预测类别，但如果是类别不均衡的场景，这样做其实未必是最优的。我们可以通过验证集来搜索一个向量$[t_1,t_2,\cdots,t_n]$，然后用<br />
\begin{equation}\mathop{\text{argmax}}\,(p_1 t_1,p_2 t_2,\dots,p_n t_n)\end{equation}<br />
作为预测类别，这里的$[t_1,t_2,\cdots,t_n]$就相当于是多类别场景下的阈值。</p>
<p>那么，怎么搜索出$[t_1,t_2,\cdots,t_n]$呢？搜索目标自然是指标最大，但accuracy或者F1这些都是不可导的，因此梯度下降肯定是不考虑了；而又因为待搜索参数是一个多维向量，所以二分法也不大好用。这里介绍一种名为“Powell法”的求解方案。Powell法的数学细节比较多，这里不打算展开，简单来说，Powell法是一种求解低维无约束优化的算法，它不需要梯度，并且效率也相对较高，这里低维指的是待优化参数通常不超过100个（你总不能指望它去求解神经网络）。最关键是，Powell法在Scipy中有现成实现，在<code>scipy.optimize.minimize</code>中指定<code>method='Powell'</code>即可调用它。</p>
<p>对于上述问题，参考代码如下：</p>
<pre class="highlight"><code>import numpy as np
from scipy.optimize import minimize

def loss(t):
    &quot;&quot;&quot;这里的y_true.shape=[batch_size],
    y_pred.shape=[batch_size, num_classes]
    &quot;&quot;&quot;
    t = (np.tanh(t) + 1) / 2
    return -np.mean(y_true == (y_pred * t[None]).argmax(1))

options = {'xtol': 1e-10, 'ftol': 1e-10, 'maxiter': 100000}
result = minimize(
    loss, np.zeros_like(y_pred[:1]), method='Powell', options=options
)
thresholds = (np.tanh(result.x) + 1) / 2
</code></pre>

<h2 id="_2">实验结果<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>有了自动确定阈值的方法后，我们就可以检验分类性能了。笔者在ATEC、BQ、LCQMC、PAWSX这4个数据集上做了实验，分别对比了CoSENT、Sentence-BERT和交互式（记为Interact）三种方案的效果。公平起见，每种方法都用Powell法在验证集上确定最优阈值，然后用该阈值报告测试集的效果，哪怕交互式的也是如此。</p>
<blockquote>
<p><strong>实验代码：<a href="https://github.com/bojone/CoSENT/tree/main/accuracy">https://github.com/bojone/CoSENT/tree/main/accuracy</a></strong></p>
</blockquote>
<p>实验结果如下（指标是accuracy）：<br />
\begin{array}{c|cccc|c}
\hline
&amp; \text{ATEC} &amp; \text{BQ} &amp; \text{LCQMC} &amp; \text{PAWSX} &amp; \text{Avg}\\
\hline
\text{BERT+CoSENT} &amp; \textbf{85.81} &amp; 83.24 &amp; 86.67 &amp; 76.30 &amp; 83.00 \\
\text{Sentence-BERT} &amp; 84.93 &amp; 82.46 &amp; 87.42 &amp; 65.33 &amp; 80.04\\
\text{BERT+Interact} &amp; 85.49 &amp; \textbf{83.88} &amp; \textbf{87.80} &amp; \textbf{81.30} &amp; \textbf{84.62} \\
\hline
\text{RoBERTa+CoSENT} &amp; 85.93 &amp; 83.42 &amp; 87.63 &amp; 76.55 &amp; 83.38 \\
\text{Sentence-RoBERTa} &amp; 85.34 &amp; 82.52 &amp; 88.14 &amp; 68.35 &amp; 81.09 \\
\text{RoBERTa+Interact} &amp; \textbf{86.04} &amp; \textbf{83.62} &amp; \textbf{88.22} &amp; \textbf{83.33} &amp; \textbf{85.30} \\
\hline
\end{array}</p>
<p>实验结果显示，从效果上来看，交互式确实是“王者”地位，但是特征式（CoSENT和Sentence-BERT/RoBERTa）的效果差距并没有笔者想象中大。客观来说，在ATEC和BQ两个任务上，交互式Interact与特征式CoSENT并无显著差异，而在LCQMC任务上，交互式Interact与特征式Sentence-BERT/RoBERTa并无显著差异。</p>
<p>唯一拉开明显差距的是PAWSX，在<a href="/archives/8321">《无监督语义相似度哪家强？我们做了个比较全面的评测》</a>、<a href="/archives/8348">《中文任务还是SOTA吗？我们给SimCSE补充了一些实验》</a>中我们可以发现，几乎所有无监督句向量方法都在PAWSX上失效。为什么呢？因为PAWSX的负样本几乎全是“对抗样本”，就是字面重叠度非常高但语义却不同的负样本。所以，对于这种无监督方法“全线崩溃”的“高难”负样本，哪怕用标注数据去训练，也自然需要更深层的交互才能更好地识别出来。</p>
<h2 id="_3">理论极限<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>有些读者可能会好奇：能否通过理论分析出特征式方案的理论极限呢？可能让人意外的是，这个分析其实不难，而答案是：</p>
<blockquote>
<p>理论上来说，交互式能做到的效果，特征式“几乎”都能做到。</p>
</blockquote>
<p>怎么得到这个结果呢？事实上用本博客以往介绍过的文章就足够了。首先，我们假定样本对的相似度在0～1之间，并且样本对是无序的，即$\text{sim}(x,y)=\text{sim}(y,x)$，那么如果有$n$个样本，那么我们每两个样本之间算相似度（不管实际的相似度是怎么算来的），就得到一个相似度矩阵$S$，它是一个“正定对称矩阵”（或者严格点，是半正定）。按照线性代数的结果，正定对称矩阵的SVD分解必然是$S=U\Lambda U^{\top}$的形式，其中$U$是正交矩阵而$\Lambda$是对角阵，那么我们有$S=U\Lambda U^{\top}=(U\sqrt{\Lambda})(U\sqrt{\Lambda})^{\top}$。这就表明了，正定对称矩阵一定可以分解为$S=BB^{\top}$的形式，这等价于说，每个样本$i$可以表示为一个$n$维向量$v_i$，使得$S_{i,j}=\langle x_i, y_j\rangle$。</p>
<p>至此，所有的结果都是有理论保证并且精确相等的，只不过目前的“$n$维向量”实在是太大了，所以接下来应该往降维角度想。此时，我们去年介绍过的“JL引理”（参考<a href="/archives/8679">《让人惊叹的Johnson-Lindenstrauss引理：理论篇》</a>）就可以登场了，它告诉我们，别管原来是多少维的，$n$个向量都可以降到$\mathcal{O}(\log n)$维，而保持内积近似不变，在<a href="/archives/8706">《让人惊叹的Johnson-Lindenstrauss引理：应用篇》</a>中我们还近似估计了这个量级应该是$8\log n$左右，所以对于BERT base的768维向量来说，理论上通过内积来拟合上百万个样本的两两相似度都不成问题。所以，基于内积的、维度达到几百维的“特征式”方案，理论上是可以相当精确地达到交互式效果的。</p>
<p>那为什么在PAWSX这样的困难数据集上两者有明显差异呢？个人认为这是“神经网络和cos指标的连续性”与“文本匹配天然存在的对抗性”之间的矛盾造成的。</p>
<p>神经网络本身就是一个连续函数，然后编码器负责将句子压缩到一个句向量中，其结果的连续性必然是非常好的，这里的连续性，指的是句子的微小改动，导致句向量的改动也是微小的；同时，cos的连续性也非常好，即如果$\Delta v$比较小，那么$\cos(u,v)$和$\cos(u, v+\Delta v)$的差距也很小。所以，总的来说就是“特征式”的方案连续性会非常好。但问题是，人设计出来的语言天然存在对抗性，即字面上的微小改动能导致标注结果的巨大变化，经典的就是加个“不”字导致所谓的“语义反转”，说白了就是连续性并不好。</p>
<p>于是，在此类任务之下，连续性非常好的“特征式”方案要去拟合对抗性明显的数据集，就会非常困难。当然，前面我们已经分析过理论上是可以拟合的，所以实际上是拟合确实能拟合，但需要训练比较多的epoch来“磨”掉特征式方案原有的连续性，但比较多的epoch也造成了更严重的过拟合。因此，CoSENT的训练loss也能降到接近于0（说明拟合能力没问题），但是验证集的效果没有交互式的好。至于交互式，模型一开始就同时接触到了两个样本，在后面的层中模型可以自行拟合和放大差异，从而在交互式方案中连续性与对抗性的矛盾并没有那么严重，因而效果更好。</p>
<h2 id="_4">文章小结<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h2>
<p>本文从理论和实验两个角度地探讨了特征式匹配与交互式匹配的效果差距，此外还讨论了多分类问题中阈值的自动搜索问题。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/8860">https://spaces.ac.cn/archives/8860</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Jan. 12, 2022). 《CoSENT（二）：特征式匹配与交互式匹配有多大差距？ 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/8860">https://spaces.ac.cn/archives/8860</a></p>
<p>@online{kexuefm-8860,<br />
title={CoSENT（二）：特征式匹配与交互式匹配有多大差距？},<br />
author={苏剑林},<br />
year={2022},<br />
month={Jan},<br />
url={\url{https://spaces.ac.cn/archives/8860}},<br />
} </p>
<hr />
<h2 id="_5">公式推导与注释<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h2>
<p>TODO: 添加详细的数学公式推导和注释</p>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="cosent一比sentence-bert更有效的句向量方案.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#15 CoSENT（一）：比Sentence-BERT更有效的句向量方案</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="多任务学习漫谈一以损失之名.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#17 多任务学习漫谈（一）：以损失之名</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#cosent">CoSENT（二）：特征式匹配与交互式匹配有多大差距？</a><ul>
<li><a href="#_1">自动阈值</a></li>
<li><a href="#_2">实验结果</a></li>
<li><a href="#_3">理论极限</a></li>
<li><a href="#_4">文章小结</a></li>
<li><a href="#_5">公式推导与注释</a></li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>