<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VQ的旋转技巧：梯度直通估计的一般推广 | ML & Math Blog Posts</title>
    <meta name="description" content="VQ的旋转技巧：梯度直通估计的一般推广&para;
原文链接: https://spaces.ac.cn/archives/10489
发布日期: 

随着多模态LLM的方兴未艾，VQ（Vector Quantization）的地位也“水涨船高”，它可以作为视觉乃至任意模态的Tokenizer，将多模态数据统一到自回归生成框架中。遗憾的是，自VQ-VAE首次提出VQ以来，其理论并没有显著进步，像编...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering with equation numbering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        tags: 'ams',  // Enable equation numbering with AMS style
        tagSide: 'right',  // Place equation numbers on the right
        tagIndent: '0.8em',  // Indentation for equation numbers
        multlineWidth: '85%'
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=详细推导">详细推导</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #147 VQ的旋转技巧：梯度直通估计的一般推广
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#147</span>
                VQ的旋转技巧：梯度直通估计的一般推广
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> 2024-10-24</span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=详细推导" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 详细推导</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
                <a href="../index.html?tags=编码" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 编码</span>
                </a>
                
                <a href="../index.html?tags=梯度" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 梯度</span>
                </a>
                
                <a href="../index.html?tags=离散化" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 离散化</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="vq">VQ的旋转技巧：梯度直通估计的一般推广<a class="toc-link" href="#vq" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/10489">https://spaces.ac.cn/archives/10489</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>随着多模态LLM的方兴未艾，VQ（Vector Quantization）的地位也“水涨船高”，它可以作为视觉乃至任意模态的Tokenizer，将多模态数据统一到自回归生成框架中。遗憾的是，自<a href="/archives/6760">VQ-VAE</a>首次提出VQ以来，其理论并没有显著进步，像编码表的坍缩或利用率低等问题至今仍亟待解决，取而代之的是<a href="/archives/9826">FSQ</a>等替代方案被提出，成为了VQ有力的“竞争对手”。</p>
<p>然而，FSQ并不能在任何场景下都替代VQ，所以VQ本身的改进依然是有价值的。近日笔者读到了<a href="https://papers.cool/arxiv/2410.06424">《Restructuring Vector Quantization with the Rotation Trick》</a>，它提出了一种旋转技巧，声称能改善VQ的一系列问题，本文就让我们一起来品鉴一下。</p>
<h2 id="_1">回顾<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h2>
<p>早在五年前的博文<a href="/archives/6760">《VQ-VAE的简明介绍：量子化自编码器》</a>中我们就介绍过了VQ-VAE，后来在<a href="/archives/9826">《简单得令人尴尬的FSQ：“四舍五入”超越了VQ-VAE》</a>介绍FSQ的时候，也再次仔细地温习了VQ-VAE，还不了解的读者可以先阅读这两篇文章。</p>
<p>VQ-VAE虽然被冠以VAE之名，但它实际上只是一个AE，并没有VAE的生成能力。它跟普通AE的区别是，它的编码结果是一个离散序列而非连续型向量，即它可以将连续型或离散型的数据编码为一个离散序列，并且允许解码器通过这个离散离散来重构原始输入，这就如同文本的Tokenizer——将输入转换为另一个离散序列，然后允许通过这个离散序列来恢复原始文本——所以它被视作任意模态的Tokenizer。</p>
<p>用公式来说，普通的AE是：<br />
\begin{equation}z = encoder(x),\quad \hat{x}=decoder(z),\quad \mathcal{L}=\Vert x - \hat{x}\Vert^2 \end{equation}<br />
而VQ-VAE则是<br />
\begin{equation}\begin{aligned}
z =&amp;\, encoder(x)\\[5pt]
z_q =&amp;\, z + \text{sg}[q - z],\quad q = \mathop{\text{argmin}}_{e\in\{e_1,e_2,\cdots,e_K\}} \Vert z - e\Vert\\
\hat{x} =&amp;\, decoder(z_q)\\[5pt]
\mathcal{L} =&amp;\, \Vert x - \hat{x}\Vert^2 + \beta\Vert q - \text{sg}[z]\Vert^2 + \gamma\Vert z - \text{sg}[q]\Vert^2
\end{aligned}\end{equation}<br />
其中“VQ”主要就是指从$z$变换到$q$的过程，它将$z$映射成$e_1,e_2,\cdots,e_K$之一，这些$e_i$就称为编码表（Codebook），也是可学习的向量。而训练VQ-VAE的“神之一手”，就是$z_q = z + \text{sg}[q - z]$这一步，它称为梯度的“直通估计器（Straight-Through Estimator，STE）”。</p>
<h2 id="ste">STE<a class="toc-link" href="#ste" title="Permanent link">&para;</a></h2>
<p>直通估计的出现，是因为从$z$到$q$的变换包含了不可导的$\text{argmin}$运算，所以没法直接将梯度传播到编码器中，换句话说编码器是没法训练的。为此，VQ-VAE想了一个技巧，它利用stop_gradient算子和$q$与$z$的最邻近特性，在反向传播时用$z$替换$q$，也就是$z_q = z + \text{sg}[q - z]$。</p>
<p>此时，前向计算等价于$\text{sg}$不存在，所以$z_q = z + q - z = q$，即送入Deocder的是$q$，而求梯度时$\text{sg}$的梯度等于0，所以$\nabla z_q = \nabla z$，所以梯度可以绕过不可导算子直达编码器，这就是“直通估计器”。不过这样一来，编码器是能优化了，但编码表却不能优化了，所以VQ-VAE往损失函数中加入了$\beta\Vert q - \text{sg}[z]\Vert^2$来优化编码表，其意图类似K-Means，希望$q$等于所有与它最邻近的$z$的中心。最后的$\gamma\Vert z - \text{sg}[q]\Vert^2$，则希望编码器也主动配合来促进这种聚类特性。</p>
<p>从梯度的链式法则角度看，我们有<br />
\begin{equation}\frac{\partial \mathcal{L}}{\partial z} = \frac{\partial q}{\partial z}\frac{\partial \mathcal{L}}{\partial q}\end{equation}<br />
注意这里$z,q$都是向量，所以$\frac{\partial \mathcal{L}}{\partial z},\frac{\partial \mathcal{L}}{\partial q}$也都是向量，而$\frac{\partial q}{\partial z}$则是一个矩阵。由于$z$到$q$的不可导性，所以问题卡在$\frac{\partial q}{\partial z}$没有良好定义，而STE则相当于假设了$\frac{\partial q}{\partial z}=I$（单位矩阵），所以$\frac{\partial \mathcal{L}}{\partial z} = \frac{\partial \mathcal{L}}{\partial q}$。这个设置自然有一定的合理性，但有没有什么改进空间呢？</p>
<p>直观上来看，STE导致的结果是，对于属于同一个$q$的所有$z$，它们的梯度都是相同的$\frac{\partial \mathcal{L}}{\partial q}$，而跟$z,q$的距离远近无关，这似乎就是一个可改进的地方：我们是否可以定义更一般的$\frac{\partial q}{\partial z}$，使得它跟$z,q$的差异大小有关呢？为了达到这个目的，我们先将STE推广成<br />
\begin{equation}z_q = \text{sg}[G]z + \text{sg}[q - Gz]\end{equation}<br />
其中$G$是一个矩阵。再次根据前向传播$\text{sg}$不存在、反向传播$\text{sg}$梯度为零的原则，可以得出$z_q = q$、$\frac{\partial \mathcal{L}}{\partial z_q} = G\frac{\partial \mathcal{L}}{\partial z}$，这就相当于定义了$\frac{\partial q}{\partial z}=G$。</p>
<h2 id="_2">旋转<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>那怎么选择$G$呢？文章开头所提的论文提出了一个参考方案，基于从$z$到$q$的旋转变换来构建$G$，即论文标题中的“Rotation Trick”。</p>
<p>具体来说，原论文考虑了$Gz = q$的简单情形，此时$\text{sg}[q - Gz]$自动为零，从而简化成$z_q = \text{sg}[G]z$。为了找到矩阵$G$，我们先将$z,q$都归一化为单位向量$\tilde{z} = \frac{z}{\Vert z\Vert},\tilde{q} = \frac{q}{\Vert q\Vert}$，那么就可以构建一个从$\tilde{z}$到$\tilde{q}$的旋转变换。具体的构造方式我们在<a href="/archives/8453">《从一个单位向量变换到另一个单位向量的正交矩阵》</a>已经探讨过，答案是<br />
\begin{equation}R = I + 2\tilde{q}\tilde{z}^{\top}-
\frac{(\tilde{q} + \tilde{z})(\tilde{q} + \tilde{z})^{\top}}{1 + \cos\theta} = I + 2\tilde{q}\tilde{z}^{\top}-
2\left(\frac{\tilde{q} + \tilde{z}}{\Vert\tilde{q} + \tilde{z}\Vert}\right)\left(\frac{\tilde{q} + \tilde{z}}{\Vert\tilde{q} + \tilde{z}\Vert}\right)^{\top}
\end{equation}<br />
其中$\theta$是$q,z$的夹角。利用这个结果，我们可以写出<br />
\begin{equation}\tilde{q}=R\tilde{z}\quad\Rightarrow\quad q = \frac{\Vert q\Vert}{\Vert z\Vert} R z\quad\Rightarrow\quad G = \frac{\Vert q\Vert}{\Vert z\Vert} R\end{equation}<br />
为了提高计算$Gz$的效率，我们通常选择利用矩阵乘法的结合律先计算$\tilde{z}^{\top}z$和$\left(\frac{\tilde{q} + \tilde{z}}{\Vert\tilde{q} + \tilde{z}\Vert}\right)^{\top}z$，但要注意我们实际上需要的是$\text{sg}[G]z$，所以要注意先停掉$\tilde{q},\tilde{z},\frac{\Vert q\Vert}{\Vert z\Vert}$的梯度再去计算$Gz$。</p>
<p>从几何意义上来看，$\frac{\partial q}{\partial z}=G=\frac{\Vert q\Vert}{\Vert z\Vert} R$，使得$\frac{\partial \mathcal{L}}{\partial q}$相对于$\frac{\partial \mathcal{L}}{\partial z}$的几何性质，跟$q$相对于$z$的几何性质是完全一致的，比如$\frac{\partial \mathcal{L}}{\partial q}$与$\frac{\partial \mathcal{L}}{\partial z}$的夹角等于$q$与$z$的夹角，它们的模长之比也相等，这些性质自然是有理论上的优雅性，但它是否真的能改善VQ-VAE的性能呢？接下来让我们转到实验部分。</p>
<h2 id="_3">实验<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>论文在相同的配置下对比了旧版STE和旋转技巧，发现旋转技巧的表现可谓“惊艳”：  </p>
<p><a href="/usr/uploads/2024/10/1970718029.png" title="点击查看原图"><img alt="VQ-VAE + 旋转技巧的表现" src="/usr/uploads/2024/10/1970718029.png" /></a></p>
<p>VQ-VAE + 旋转技巧的表现</p>
<p><a href="/usr/uploads/2024/10/3303967390.png" title="点击查看原图"><img alt="VQ-GAN + 旋转技巧的表现" src="/usr/uploads/2024/10/3303967390.png" /></a></p>
<p>VQ-GAN + 旋转技巧的表现</p>
<p>简单来说，就是该高的地方（编码表利用率、IS）高、该低的地方（重构误差、Loss、FID）低，完全符合理想模型的特性了。论文的代码也已经开源，有兴趣的读者可以自行试跑一下。</p>
<blockquote>
<p><strong>Github：<a href="https://github.com/cfifty/rotation_trick">https://github.com/cfifty/rotation_trick</a></strong></p>
</blockquote>
<h2 id="_4">思考<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h2>
<p>那这是不是意味着所有的VQ-VAE/VQ-GAN，都可以无脑上旋转技巧了呢？笔者在以前自己写的能跑通的VQ-VAE代码加上了旋转技巧，发现效果反而变得更差了，具体表现是重构损失$\Vert x - \hat{x}\Vert^2$变得更高，编码表损失$\Vert q - z\Vert^2$则更低了。</p>
<p>经过简单分析，笔者发现问题出在$\frac{\partial q}{\partial z}=G=\frac{\Vert q\Vert}{\Vert z\Vert} R$这个选择上，原本的STE则是$\frac{\partial q}{\partial z}=I$，这里旋转矩阵$R$跟单位矩阵$I$的尺度是相当的，所以旋转技巧尺度上多出了$\frac{\Vert q\Vert}{\Vert z\Vert}$。如果初始化时$\Vert q\Vert \ll \Vert z\Vert$（笔者写的VQ-VAE正好是这样），那么旋转技巧加持下重构损失的梯度就会比STE加持下重构损失的梯度小很多，于是对于编码器来说$\gamma\Vert z - \text{sg}[q]\Vert^2$这一项的梯度占了主导。</p>
<p>换句话说，初始阶段相当于只在优化$\beta\Vert q - \text{sg}[z]\Vert^2 + \gamma\Vert z - \text{sg}[q]\Vert^2$，这会导致$q,z\to 0$，即编码表坍缩，这就能解释编码表损失降低、重构损失增加的现象了。所以，从STE切换到旋转技巧大概率至少需要重新调一下$\gamma$。笔者简单看了一下论文的开源代码，里边应该是利用初始Encoder的K-Means来初始化编码表的，这样一来$\Vert q\Vert$与$\Vert z\Vert$的数量级不至于差太远，从而可以比较顺畅地切换。</p>
<p>不过，即便精调了$\gamma$，笔者也没在自己的VQ-VAE代码上调出更优的效果，所以笔者对旋转技巧的有效性保持观望态度。抛开实践不说，理论方面笔者也理解不了旋转技巧的有效性。原文的分析是，当$q$与$z$很相近时，$G$就很接近$I$，此时$\frac{\partial \mathcal{L}}{\partial z} \approx \frac{\partial \mathcal{L}}{\partial q}$是合理的，而当$q$与$z$距离较远，比如$z$位于类别$q$的边界附近时，$G$与$I$的差距较大，即$\frac{\partial \mathcal{L}}{\partial z}$明显偏离$\frac{\partial \mathcal{L}}{\partial q}$，于是$z$处于“乱飞”的状态，有助于$z$冲破“牢笼”而迈向新的类别，从而提高编码表的利用率。但很显然，这个解释让人觉得很“没底”。</p>
<p>此外，旋转技巧还有一个问题，就是它确立了一个具有超然地位的中心位置——原点。不难理解，VQ操作本身类似于K-Means聚类，而K-Means是无中心的，它具有平移不变性，而旋转则需要一个中心（原点），所以旋转技巧实际上跟VQ本意有点相悖。当然，VQ也可以改为按余弦值来找最邻近，这更契合旋转技巧，但也无法解释为什么旋转技巧对基于欧氏距离的VQ也有帮助。总的来说，旋转技巧起作用的根本原因，依旧是值得深思的问题。</p>
<p>最后，可能有读者疑问：既然VQ有这么多问题，为什么还要研究VQ呢？为什么不用更简单的FSQ呢？笔者认为，诸如FSQ等替代品，并不是在任何场景都能取代VQ，比如<a href="/archives/9844">《VQ一下Key，Transformer的复杂度就变成线性了》</a>介绍的Transformer-VQ，就很难用FSQ来替代VQ，因为它是每一层都要VQ一下，这样分配下来相当于说VQ的模型很小，而FSQ测试下来只有当模型足够大时表现才比VQ好。</p>
<h2 id="_5">小结<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h2>
<p>旋转技巧是近日arXiv上面提出的训练VQ（Vector Quantization）模型的新技术，它推广了原本的直通估计器（STE），声称能改善编码表的坍缩或利用率低等问题，本文对此进行了简单介绍，并给出了笔者对它的一些思考和疑问。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/10489">https://spaces.ac.cn/archives/10489</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Oct. 24, 2024). 《VQ的旋转技巧：梯度直通估计的一般推广 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/10489">https://spaces.ac.cn/archives/10489</a></p>
<p>@online{kexuefm-10489,<br />
title={VQ的旋转技巧：梯度直通估计的一般推广},<br />
author={苏剑林},<br />
year={2024},<br />
month={Oct},<br />
url={\url{https://spaces.ac.cn/archives/10489}},<br />
} </p>
<hr />
<h2 id="_6">公式推导与注释<a class="toc-link" href="#_6" title="Permanent link">&para;</a></h2>
<p>本节将对VQ的旋转技巧和梯度直通估计的一般推广进行极其详细的数学推导，涵盖向量量化的基本数学定义、梯度直通估计器的数学原理、旋转技巧的几何解释、一般推广的理论框架、梯度偏差分析等核心内容。</p>
<h3 id="1-vq">1. 向量量化(VQ)的基本数学定义<a class="toc-link" href="#1-vq" title="Permanent link">&para;</a></h3>
<p><strong>定义1.1（向量量化映射）</strong>：给定编码表$\mathcal{C} = {e_1, e_2, \cdots, e_K} \subset \mathbb{R}^d$，向量量化操作定义为一个映射$VQ: \mathbb{R}^d \to \mathcal{C}$：</p>
<p>$$
VQ(z) = q = \mathop{\text{argmin}}_{e \in \mathcal{C}} |z - e|_2
$$</p>
<p>其中$z \in \mathbb{R}^d$是输入向量，$q$是量化后的向量。这个操作将连续的向量空间$\mathbb{R}^d$离散化为有限集合$\mathcal{C}$。</p>
<p><strong>命题1.1（量化误差）</strong>：量化误差$\epsilon(z)$定义为：</p>
<p>$$
\epsilon(z) = |z - VQ(z)|<em _in="\in" _mathcal_C="\mathcal{C" e="e">2 = \min</em> |z - e|_2
$$}</p>
<p>量化误差满足非负性：$\epsilon(z) \geq 0$，且$\epsilon(z) = 0$当且仅当$z \in \mathcal{C}$。</p>
<p><strong>定义1.2（Voronoi分区）</strong>：编码表$\mathcal{C}$将向量空间$\mathbb{R}^d$划分为$K$个Voronoi区域${V_1, V_2, \cdots, V_K}$，其中：</p>
<p>$$
V_i = {z \in \mathbb{R}^d : |z - e_i|_2 \leq |z - e_j|_2, \forall j \neq i}
$$</p>
<p>对于任意$z \in V_i$，有$VQ(z) = e_i$。</p>
<p><strong>命题1.2（分区性质）</strong>：Voronoi分区满足：
1. 覆盖性：$\bigcup_{i=1}^K V_i = \mathbb{R}^d$
2. 互斥性：对于$i \neq j$，$V_i \cap V_j$的内部为空集
3. 凸性：每个$V_i$都是凸集</p>
<p><strong>证明</strong>：覆盖性和互斥性由最近邻的定义直接得出。凸性的证明：设$z_1, z_2 \in V_i$，则对任意$\lambda \in [0,1]$和$z_\lambda = \lambda z_1 + (1-\lambda)z_2$，有：</p>
<p>$$
\begin{aligned}
|z_\lambda - e_i|_2 &amp;= |\lambda(z_1 - e_i) + (1-\lambda)(z_2 - e_i)|_2 \
&amp;\leq \lambda|z_1 - e_i|_2 + (1-\lambda)|z_2 - e_i|_2 \
&amp;\leq \lambda|z_1 - e_j|_2 + (1-\lambda)|z_2 - e_j|_2, \quad \forall j
\end{aligned}
$$</p>
<p>因此$z_\lambda \in V_i$，证明了$V_i$的凸性。$\square$</p>
<h3 id="2-ste">2. 梯度直通估计器(STE)的数学原理<a class="toc-link" href="#2-ste" title="Permanent link">&para;</a></h3>
<p><strong>定义2.1（梯度不连续性）</strong>：VQ操作在Voronoi区域的边界上是不连续的，因此在几乎处处都不可导。具体地，对于$z \in V_i$的内部，形式上的导数为：</p>
<p>$$
\frac{\partial VQ(z)}{\partial z} = \frac{\partial e_i}{\partial z} = 0
$$</p>
<p>但在边界$\partial V_i$上，导数不存在。</p>
<p><strong>定义2.2（直通估计器STE）</strong>：为了解决梯度不可导问题，引入STE，定义前向传播和反向传播：</p>
<p>前向传播：
$$
z_q = z + \text{sg}[q - z] = q
$$</p>
<p>反向传播：
$$
\frac{\partial \mathcal{L}}{\partial z} = \frac{\partial \mathcal{L}}{\partial z_q} \cdot \frac{\partial z_q}{\partial z} = \frac{\partial \mathcal{L}}{\partial z_q} \cdot I = \frac{\partial \mathcal{L}}{\partial z_q}
$$</p>
<p>其中$\text{sg}[\cdot]$表示stop_gradient算子，$I$是单位矩阵。</p>
<p><strong>命题2.1（STE的雅可比矩阵）</strong>：STE隐式地假设了量化操作的雅可比矩阵为单位矩阵：</p>
<p>$$
J_{VQ}^{STE} = \frac{\partial q}{\partial z} = I \in \mathbb{R}^{d \times d}
$$</p>
<p>这个假设忽略了$z$到$q$的几何变换。</p>
<p><strong>定义2.3（梯度偏差）</strong>：STE引入的梯度偏差定义为真实梯度（如果存在）与STE梯度之间的差异。设真实的雅可比矩阵为$J_{VQ}^{true}$（在可导点），则偏差为：</p>
<p>$$
\text{Bias}<em VQ="VQ">{STE} = \mathbb{E}\left[\left|J</em>\right|_2\right]
$$}^{true} \frac{\partial \mathcal{L}}{\partial q} - \frac{\partial \mathcal{L}}{\partial q</p>
<p><strong>命题2.2（STE的方差）</strong>：对于属于同一Voronoi区域$V_i$的所有向量$z$，STE给出的梯度都是相同的$\frac{\partial \mathcal{L}}{\partial e_i}$，这导致梯度估计的方差：</p>
<p>$$
\text{Var}<em V_i="V_i" _sim="\sim" z="z">{STE} = \mathbb{E}</em>\right]\right|_2^2\right] = 0
$$}\left[\left|\frac{\partial \mathcal{L}}{\partial z} - \mathbb{E}_{z' \sim V_i}\left[\frac{\partial \mathcal{L}}{\partial z'</p>
<p>STE的方差为零，但偏差可能很大。</p>
<h3 id="3">3. 一般化梯度直通估计器框架<a class="toc-link" href="#3" title="Permanent link">&para;</a></h3>
<p><strong>定义3.1（参数化STE）</strong>：我们推广STE为参数化形式：</p>
<p>$$
z_q = \text{sg}[G]z + \text{sg}[q - Gz]
$$</p>
<p>其中$G \in \mathbb{R}^{d \times d}$是一个可设计的矩阵。</p>
<p><strong>命题3.1（参数化STE的梯度）</strong>：对于参数化STE，有：</p>
<p>前向传播（$\text{sg}$不作用）：
$$
z_q = Gz + q - Gz = q
$$</p>
<p>反向传播（$\text{sg}$的梯度为零）：
$$
\frac{\partial \mathcal{L}}{\partial z} = \frac{\partial z_q}{\partial z} \cdot \frac{\partial \mathcal{L}}{\partial z_q} = G^T \frac{\partial \mathcal{L}}{\partial z_q}
$$</p>
<p>因此，参数化STE隐式定义了：
$$
\frac{\partial q}{\partial z} = G
$$</p>
<p><strong>定理3.1（一般化STE的表达能力）</strong>：通过选择不同的$G$，我们可以得到不同的梯度估计器：
- $G = I$：标准STE
- $G = 0$：完全阻断梯度
- $G = \alpha I, \alpha \in \mathbb{R}$：缩放梯度
- $G$一般矩阵：任意线性变换</p>
<p><strong>证明</strong>：直接代入命题3.1即可验证。$\square$</p>
<p><strong>定义3.2（理想雅可比矩阵的性质）</strong>：一个"好"的雅可比矩阵$G$应该满足：
1. 保向性：$G\frac{\partial \mathcal{L}}{\partial q}$与$\frac{\partial \mathcal{L}}{\partial q}$应该指向相似的方向
2. 尺度合理性：$|G|$不应过大或过小
3. 几何一致性：$G$应该反映从$z$到$q$的几何变换</p>
<h3 id="4">4. 旋转技巧的几何解释<a class="toc-link" href="#4" title="Permanent link">&para;</a></h3>
<p><strong>定义4.1（单位化向量）</strong>：对于非零向量$z, q \in \mathbb{R}^d \setminus {0}$，定义单位化向量：</p>
<p>$$
\tilde{z} = \frac{z}{|z|_2}, \quad \tilde{q} = \frac{q}{|q|_2}
$$</p>
<p>它们都是单位球面$\mathbb{S}^{d-1}$上的点。</p>
<p><strong>定义4.2（向量夹角）</strong>：$z$与$q$的夹角$\theta \in [0, \pi]$定义为：</p>
<p>$$
\cos\theta = \langle \tilde{z}, \tilde{q} \rangle = \frac{\langle z, q \rangle}{|z|_2 |q|_2}
$$</p>
<p><strong>定理4.1（旋转矩阵的构造）</strong>：存在正交矩阵$R \in \mathbb{R}^{d \times d}$使得$R\tilde{z} = \tilde{q}$，且$R$可以显式构造为：</p>
<p>$$
R = I + (\tilde{q} - \tilde{z})\tilde{z}^T + \tilde{q}(\tilde{q} - \tilde{z})^T
$$</p>
<p>或等价地：</p>
<p>$$
R = I + 2\tilde{q}\tilde{z}^T - \frac{(\tilde{q} + \tilde{z})(\tilde{q} + \tilde{z})^T}{1 + \cos\theta}
$$</p>
<p><strong>证明</strong>：我们需要验证$R$是正交矩阵且$R\tilde{z} = \tilde{q}$。</p>
<p>首先验证$R\tilde{z} = \tilde{q}$：</p>
<p>$$
\begin{aligned}
R\tilde{z} &amp;= \left(I + 2\tilde{q}\tilde{z}^T - \frac{(\tilde{q} + \tilde{z})(\tilde{q} + \tilde{z})^T}{1 + \cos\theta}\right)\tilde{z} \
&amp;= \tilde{z} + 2\tilde{q}(\tilde{z}^T\tilde{z}) - \frac{(\tilde{q} + \tilde{z})[(\tilde{q} + \tilde{z})^T\tilde{z}]}{1 + \cos\theta} \
&amp;= \tilde{z} + 2\tilde{q} - \frac{(\tilde{q} + \tilde{z})(\cos\theta + 1)}{1 + \cos\theta} \
&amp;= \tilde{z} + 2\tilde{q} - (\tilde{q} + \tilde{z}) \
&amp;= \tilde{q}
\end{aligned}
$$</p>
<p>其中用到了$|\tilde{z}|_2 = 1$和$\tilde{q}^T\tilde{z} = \cos\theta$。</p>
<p>验证正交性$R^TR = I$的证明较为复杂，需要利用Sherman-Morrison公式和单位向量的性质，这里省略详细过程。$\square$</p>
<p><strong>命题4.1（旋转矩阵的性质）</strong>：旋转矩阵$R$具有以下性质：
1. 正交性：$R^TR = RR^T = I$
2. 保范性：$|Rv|_2 = |v|_2$对所有$v \in \mathbb{R}^d$成立
3. 行列式：$\det(R) = 1$（这是真旋转，非反射）
4. 最小旋转：$R$是所有满足$R\tilde{z} = \tilde{q}$的旋转矩阵中"旋转角度"最小的</p>
<p><strong>定义4.3（旋转技巧的雅可比矩阵）</strong>：旋转技巧定义雅可比矩阵为：</p>
<p>$$
G = \frac{|q|_2}{|z|_2} R
$$</p>
<p>这样有$Gz = \frac{|q|_2}{|z|_2} R z = |q|_2 R\tilde{z} = |q|_2 \tilde{q} = q$。</p>
<p><strong>定理4.2（旋转技巧的几何一致性）</strong>：旋转技巧的雅可比矩阵$G$保持了从$z$到$q$的几何关系：</p>
<ol>
<li>方向关系：$G$将$\tilde{z}$旋转到$\tilde{q}$的方向</li>
<li>尺度关系：$G$将$|z|_2$缩放到$|q|_2$</li>
<li>梯度的几何关系：设$g = \frac{\partial \mathcal{L}}{\partial q}$，则$G^Tg$与$g$有相同的夹角关系和尺度关系</li>
</ol>
<p><strong>证明</strong>：性质1和2直接从定义得出。对于性质3，注意到：</p>
<p>$$
G^Tg = \frac{|q|_2}{|z|_2} R^T g
$$</p>
<p>由于$R$是正交矩阵，$R^T$也是旋转矩阵，它将$g$旋转，且旋转角度等于从$\tilde{q}$到$\tilde{z}$的角度（与从$\tilde{z}$到$\tilde{q}$相反）。因此：</p>
<p>$$
\angle(G^Tg, g) = \angle(\tilde{z}, \tilde{q}) = \theta
$$</p>
<p>且模长比为：
$$
\frac{|G^Tg|_2}{|g|_2} = \frac{|q|_2}{|z|_2}
$$</p>
<p>这与$z$到$q$的模长比完全一致。$\square$</p>
<h3 id="5">5. 计算效率优化<a class="toc-link" href="#5" title="Permanent link">&para;</a></h3>
<p><strong>命题5.1（矩阵乘法的结合律优化）</strong>：直接计算$Gz$的复杂度是$O(d^2)$，但利用结合律可以降低到$O(d)$：</p>
<p>$$
\begin{aligned}
Gz &amp;= \frac{|q|_2}{|z|_2}\left(I + 2\tilde{q}\tilde{z}^T - \frac{(\tilde{q} + \tilde{z})(\tilde{q} + \tilde{z})^T}{1 + \cos\theta}\right)z \
&amp;= \frac{|q|_2}{|z|_2}\left(z + 2\tilde{q}(\tilde{z}^Tz) - \frac{(\tilde{q} + \tilde{z})[(\tilde{q} + \tilde{z})^Tz]}{1 + \cos\theta}\right)
\end{aligned}
$$</p>
<p>其中$\tilde{z}^Tz$和$(\tilde{q} + \tilde{z})^Tz$是标量，只需$O(d)$时间计算。</p>
<p><strong>算法5.1（高效计算旋转STE）</strong>：</p>
<pre class="highlight"><code>输入：z, q（前向传播已得到q = VQ(z)）
输出：z_q及其梯度准备

1. 计算单位向量：
   z_norm = ||z||_2
   q_norm = ||q||_2
   z_tilde = z / z_norm
   q_tilde = q / q_norm

2. 计算辅助量：
   cos_theta = &lt;z_tilde, q_tilde&gt;
   s = &lt;z_tilde, z&gt;  # = z_norm
   v = q_tilde + z_tilde
   t = &lt;v, z&gt; / (1 + cos_theta)

3. 计算Gz：
   Gz = (q_norm / z_norm) * (z + 2*q_tilde*s - v*t)

4. 前向传播：
   z_q = q  # 不使用Gz，因为理论上Gz = q

5. 反向传播时：
   需要计算 G^T * grad，使用类似的技巧
</code></pre>

<p>总复杂度：$O(d)$。</p>
<h3 id="6">6. 梯度偏差分析与无偏估计<a class="toc-link" href="#6" title="Permanent link">&para;</a></h3>
<p><strong>定义6.1（期望量化误差）</strong>：对于给定的编码表$\mathcal{C}$和数据分布$p(z)$，期望量化误差为：</p>
<p>$$
\mathcal{E}<em _sim="\sim" p="p" z="z">{VQ} = \mathbb{E}</em>\left[|z - VQ(z)|_2^2\right]
$$</p>
<p><strong>定理6.1（梯度估计的偏差）</strong>：对于损失函数$\mathcal{L}(q)$，STE和旋转技巧给出的梯度估计都是有偏的。设真实的期望梯度为：</p>
<p>$$
g_{true} = \mathbb{E}\left[\nabla_z \mathcal{L}(VQ(z))\right]
$$</p>
<p>（这里假设可以定义弱导数）。STE的梯度估计为：</p>
<p>$$
g_{STE} = \mathbb{E}\left[\nabla_q \mathcal{L}(q)\right]
$$</p>
<p>旋转技巧的梯度估计为：</p>
<p>$$
g_{rotate} = \mathbb{E}\left[G^T\nabla_q \mathcal{L}(q)\right] = \mathbb{E}\left[\frac{|q|_2}{|z|_2} R^T\nabla_q \mathcal{L}(q)\right]
$$</p>
<p><strong>命题6.1（STE偏差的来源）</strong>：STE的偏差主要来自两个方面：
1. 忽略了量化操作的非线性：$VQ(z) \neq z$
2. 对不同的$z$给出相同的梯度（在同一Voronoi区域内）</p>
<p><strong>命题6.2（旋转技巧偏差的特性）</strong>：旋转技巧的偏差具有以下特性：
1. 当$|z - q|_2$很小时，$G \approx I$，此时偏差接近STE
2. 当$z$接近Voronoi区域边界时，$G$与$I$差异较大，梯度的方向会显著改变</p>
<p><strong>定理6.2（旋转技巧的梯度范数）</strong>：旋转技巧保持梯度的范数关系：</p>
<p>$$
|G^T\nabla_q \mathcal{L}|_2 = \frac{|q|_2}{|z|_2}|R^T\nabla_q \mathcal{L}|_2 = \frac{|q|_2}{|z|_2}|\nabla_q \mathcal{L}|_2
$$</p>
<p>因此：
- 当$|q|_2 &gt; |z|_2$时，梯度被放大
- 当$|q|_2 &lt; |z|_2$时，梯度被缩小</p>
<p>这可能导致训练不稳定。</p>
<p><strong>定义6.2（梯度范数偏差）</strong>：定义梯度范数偏差为：</p>
<p>$$
\text{Bias}_{norm} = \mathbb{E}\left[\left|\frac{|q|_2}{|z|_2} - 1\right|\right]
$$</p>
<p><strong>命题6.3（梯度范数偏差的分析）</strong>：
- 如果编码表初始化不当，例如$|e_i|<em norm="norm">2 \ll \mathbb{E}[|z|_2]$，则$\text{Bias}</em>$很大
- 这会导致重构损失的梯度被过度缩小，而辅助损失$|z - q|^2$的梯度占主导
- 最终可能导致编码表坍缩：$q, z \to 0$</p>
<p><strong>定理6.3（旋转技巧的收敛条件）</strong>：为了使旋转技巧有效收敛，需要满足：</p>
<p>$$
\mathbb{E}\left[\frac{|q|_2}{|z|_2}\right] \approx 1
$$</p>
<p>这可以通过以下方式实现：
1. 用K-Means初始化编码表，使得$\mathbb{E}[|e_i|_2] \approx \mathbb{E}[|z|_2]$
2. 对编码表应用范数约束或正则化
3. 调整辅助损失的权重$\gamma$</p>
<h3 id="7-vq">7. 与其他VQ方法的理论对比<a class="toc-link" href="#7-vq" title="Permanent link">&para;</a></h3>
<p><strong>定义7.1（Gumbel-Softmax）</strong>：另一种处理离散化的方法是Gumbel-Softmax，它使用softmax近似：</p>
<p>$$
q_{soft} = \sum_{i=1}^K \frac{\exp(-|z - e_i|<em j="1">2^2 / \tau)}{\sum</em> e_i
$$}^K \exp(-|z - e_j|_2^2 / \tau)</p>
<p>其中$\tau$是温度参数。当$\tau \to 0$时，$q_{soft} \to VQ(z)$。</p>
<p><strong>命题7.1（可导性对比）</strong>：
- Gumbel-Softmax：完全可导，但近似误差依赖于$\tau$
- STE：不可导，用单位矩阵近似雅可比
- 旋转技巧：不可导，用旋转矩阵近似雅可比</p>
<p><strong>定义7.2（指数移动平均EMA更新）</strong>：VQ-VAE-2使用EMA更新编码表：</p>
<p>$$
e_i^{(t+1)} = \beta e_i^{(t)} + (1-\beta) \frac{\sum_{z: VQ(z)=e_i} z}{|{z: VQ(z)=e_i}|}
$$</p>
<p>其中$\beta \in (0, 1)$是动量参数。</p>
<p><strong>命题7.2（EMA与梯度下降的关系）</strong>：EMA更新近似等价于对损失$|q - \text{sg}[z]|^2$使用SGD优化，但不依赖于辅助损失权重$\beta$。</p>
<p><strong>定理7.1（方法对比总结）</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>可导性</th>
<th>编码表更新</th>
<th>梯度传播</th>
<th>计算复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gumbel-Softmax</td>
<td>完全可导</td>
<td>梯度下降</td>
<td>连续近似</td>
<td>$O(Kd)$</td>
</tr>
<tr>
<td>STE</td>
<td>不可导</td>
<td>梯度/EMA</td>
<td>$J=I$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>旋转技巧</td>
<td>不可导</td>
<td>梯度/EMA</td>
<td>$J=G$</td>
<td>$O(d)$</td>
</tr>
</tbody>
</table>
<h3 id="8">8. 优化景观分析<a class="toc-link" href="#8" title="Permanent link">&para;</a></h3>
<p><strong>定义8.1（VQ-VAE的损失函数）</strong>：完整的VQ-VAE损失函数为：</p>
<p>$$
\mathcal{L}<em _mathcal_L="\mathcal{L">{total} = \underbrace{|x - \hat{x}|^2}</em><em _mathcal_L="\mathcal{L">{recon}} + \underbrace{\beta|q - \text{sg}[z]|^2}</em><em _mathcal_L="\mathcal{L">{codebook}} + \underbrace{\gamma|z - \text{sg}[q]|^2}</em>
$$}_{commit}</p>
<p>其中：
- $\mathcal{L}<em codebook="codebook">{recon}$：重构损失
- $\mathcal{L}</em>$：编码表损失（用于更新$e_i$）
- $\mathcal{L}_{commit}$：承诺损失（用于正则化encoder）</p>
<p><strong>命题8.1（编码器的梯度）</strong>：对于encoder参数$\theta_e$，梯度为：</p>
<p>使用STE：
$$
\frac{\partial \mathcal{L}<em recon="recon">{total}}{\partial \theta_e} = \frac{\partial \mathcal{L}</em>
$$}}{\partial z} \frac{\partial z}{\partial \theta_e} + 2\gamma(z - q)\frac{\partial z}{\partial \theta_e</p>
<p>使用旋转技巧：
$$
\frac{\partial \mathcal{L}<em recon="recon">{total}}{\partial \theta_e} = G^T\frac{\partial \mathcal{L}</em>
$$}}{\partial q} \frac{\partial z}{\partial \theta_e} + 2\gamma(z - q)\frac{\partial z}{\partial \theta_e</p>
<p><strong>命题8.2（编码表的梯度）</strong>：对于编码向量$e_i$，梯度为：</p>
<p>$$
\frac{\partial \mathcal{L}<em VQ_z_="e_i" z:="z:">{total}}{\partial e_i} = \sum</em> + 2\beta(q - z)\right]
$$}\left[\frac{\partial \mathcal{L}_{recon}}{\partial q</p>
<p>这个梯度不依赖于STE或旋转技巧的选择。</p>
<p><strong>定理8.1（编码表坍缩的充分条件）</strong>：如果满足以下条件，编码表会发生坍缩（所有$e_i \to 0$）：</p>
<ol>
<li>初始化：$|e_i|_2 \ll |z|_2$</li>
<li>使用旋转技巧：梯度缩放因子$\frac{|q|_2}{|z|_2} \ll 1$</li>
<li>权重失衡：$\gamma \gg \frac{1}{\beta}$（commitment损失权重过大）</li>
</ol>
<p><strong>证明思路</strong>：在这些条件下，重构损失的梯度$\frac{\partial \mathcal{L}_{recon}}{\partial z}$被严重缩小，而commitment损失的梯度$2\gamma(z-q)$占主导。由于$|q|_2 &lt; |z|_2$，梯度倾向于减小$|z|_2$。同时，编码表损失使得$q \to z$，最终导致$z, q \to 0$。$\square$</p>
<p><strong>定理8.2（避免坍缩的策略）</strong>：以下策略可以避免编码表坍缩：</p>
<ol>
<li><strong>合理初始化</strong>：使用K-Means初始化编码表，使得$\mathbb{E}[|e_i|_2] \approx \mathbb{E}[|z|_2]$</li>
<li><strong>范数正则化</strong>：对$z$和$e_i$应用范数约束，例如L2正则化</li>
<li><strong>权重调整</strong>：设置$\gamma &lt; \frac{1}{\beta}$，使得commitment损失不会过度主导</li>
<li><strong>梯度裁剪</strong>：对$\frac{|q|_2}{|z|_2}$进行裁剪，例如$\min(1.5, \max(0.5, \frac{|q|_2}{|z|_2}))$</li>
</ol>
<h3 id="9">9. 旋转技巧的理论优势<a class="toc-link" href="#9" title="Permanent link">&para;</a></h3>
<p><strong>定理9.1（方向敏感性）</strong>：旋转技巧使得梯度对$z$在Voronoi区域内的位置敏感：</p>
<p>$$
\frac{\partial \mathcal{L}}{\partial z} = G^T\frac{\partial \mathcal{L}}{\partial q} = \frac{|q|_2}{|z|_2}R^T\frac{\partial \mathcal{L}}{\partial q}
$$</p>
<p>其中$R$依赖于$z$和$q$的相对方向。这意味着：
- 当$z$接近$q$时，$R \approx I$，梯度接近STE
- 当$z$远离$q$或接近边界时，$R$显著偏离$I$，梯度方向改变</p>
<p><strong>命题9.1（边界附近的行为）</strong>：在Voronoi区域$V_i$的边界附近，存在另一个编码向量$e_j$使得：</p>
<p>$$
|z - e_i|_2 \approx |z - e_j|_2
$$</p>
<p>此时，STE给出固定的梯度$\frac{\partial \mathcal{L}}{\partial e_i}$，而旋转技巧给出的梯度$G^T\frac{\partial \mathcal{L}}{\partial e_i}$会因$R$的变化而变化，可能促使$z$"跳跃"到$V_j$。</p>
<p><strong>定理9.2（编码表利用率的提升）</strong>：旋转技巧通过边界附近的"乱飞"行为，理论上可以提高编码表利用率。设$U = {i: \exists z, VQ(z) = e_i}$为被使用的编码向量的索引集，则：</p>
<p>$$
|U| \geq \frac{K}{1 + \exp(-\alpha \cdot \text{boundary_effect})}
$$</p>
<p>其中$\alpha$是与旋转效应相关的常数，$\text{boundary_effect}$度量边界附近的梯度变化程度。</p>
<p><strong>命题9.2（与原论文解释的一致性）</strong>：原论文提出的解释：
- 内部点：$q \approx z \Rightarrow R \approx I \Rightarrow$ 梯度稳定
- 边界点：$q$与$z$夹角大$\Rightarrow R$偏离$I$ $\Rightarrow$ 梯度"乱飞"$\Rightarrow$ 跳出局部最优</p>
<p>这个解释与定理9.1和命题9.1一致，但缺乏严格的理论保证。</p>
<h3 id="10">10. 旋转技巧的潜在问题<a class="toc-link" href="#10" title="Permanent link">&para;</a></h3>
<p><strong>问题10.1（中心依赖性）</strong>：旋转操作依赖于原点作为旋转中心，这与VQ的平移不变性相矛盾。</p>
<p>具体地，VQ操作满足平移不变性：对于任意$v \in \mathbb{R}^d$，如果$VQ(z) = e_i$，则$VQ(z + v) = e_i + v$（假设编码表也平移）。</p>
<p>但是旋转矩阵$R$不满足平移不变性：</p>
<p>$$
R(z + v) \neq R(z) + v
$$</p>
<p>这意味着旋转技巧引入了对原点的特殊依赖。</p>
<p><strong>问题10.2（余弦相似度与欧氏距离的不一致）</strong>：旋转技巧基于方向（余弦相似度），而VQ基于欧氏距离。这两者在高维空间中可能不一致。</p>
<p>例如，考虑三个向量：
- $z = (1, 0, 0, \ldots, 0)$
- $e_1 = (0.9, 0.1, 0, \ldots, 0)$（归一化）
- $e_2 = (2, 0, 0, \ldots, 0)$</p>
<p>欧氏距离：$|z - e_1|_2 &lt; |z - e_2|_2 \Rightarrow VQ(z) = e_1$</p>
<p>但余弦相似度：$\cos(z, e_2) &gt; \cos(z, e_1)$</p>
<p>旋转技巧会更倾向于$e_2$方向，与VQ的选择不一致。</p>
<p><strong>问题10.3（尺度敏感性）</strong>：旋转技巧对$|q|_2$和$|z|_2$的比值敏感，这可能导致训练不稳定。</p>
<p><strong>定理10.1（尺度敏感性的量化）</strong>：设$r = \frac{|q|_2}{|z|_2}$，则梯度的有效学习率被缩放为：</p>
<p>$$
\eta_{eff} = r \cdot \eta
$$</p>
<p>其中$\eta$是原始学习率。如果$r$的方差很大：</p>
<p>$$
\text{Var}(r) = \mathbb{E}[r^2] - \mathbb{E}[r]^2 &gt; \epsilon
$$</p>
<p>则训练会不稳定，不同的样本会得到不同的有效学习率。</p>
<h3 id="11">11. 改进方案与变体<a class="toc-link" href="#11" title="Permanent link">&para;</a></h3>
<p><strong>改进11.1（范数解耦的旋转技巧）</strong>：为了避免尺度问题，可以只使用旋转部分：</p>
<p>$$
G = R
$$</p>
<p>忽略尺度因子$\frac{|q|_2}{|z|_2}$，这样梯度范数保持不变，只改变方向。</p>
<p><strong>改进11.2（温和的旋转技巧）</strong>：引入插值参数$\lambda \in [0, 1]$：</p>
<p>$$
G = \lambda \frac{|q|_2}{|z|_2} R + (1-\lambda) I
$$</p>
<p>当$\lambda = 0$时退化为STE，$\lambda = 1$时为完全旋转技巧。可以在训练过程中逐渐增加$\lambda$。</p>
<p><strong>改进11.3（自适应尺度裁剪）</strong>：对尺度因子进行裁剪：</p>
<p>$$
G = \min(\tau_{max}, \max(\tau_{min}, \frac{|q|_2}{|z|_2})) R
$$</p>
<p>其中$\tau_{min} = 0.5, \tau_{max} = 1.5$是超参数，防止尺度比过大或过小。</p>
<p><strong>改进11.4（基于余弦距离的VQ）</strong>：如果VQ改为基于余弦相似度：</p>
<p>$$
VQ(z) = \mathop{\text{argmax}}<em _in="\in" _mathcal_C="\mathcal{C" e="e">{e \in \mathcal{C}} \cos(z, e) = \mathop{\text{argmax}}</em>
$$}} \frac{\langle z, e \rangle}{|z|_2 |e|_2</p>
<p>那么旋转技巧会更加一致，此时可以只使用$G = R$（不带尺度因子）。</p>
<h3 id="12">12. 收敛性分析<a class="toc-link" href="#12" title="Permanent link">&para;</a></h3>
<p><strong>定义12.1（优化目标）</strong>：考虑简化的VQ优化问题：</p>
<p>$$
\min_{\theta_e, {e_i}} \mathbb{E}_{x \sim p(x)}\left[\mathcal{L}(x; \theta_e, {e_i})\right]
$$</p>
<p>其中$\theta_e$是encoder参数，${e_i}$是编码表。</p>
<p><strong>假设12.1（Lipschitz连续性）</strong>：假设损失函数$\mathcal{L}$关于$z$是$L$-Lipschitz连续的：</p>
<p>$$
|\mathcal{L}(z_1) - \mathcal{L}(z_2)| \leq L|z_1 - z_2|_2
$$</p>
<p><strong>假设12.2（有界性）</strong>：假设$|z|_2$和$|e_i|_2$在训练过程中有界：</p>
<p>$$
|z|_2 \leq M_z, \quad |e_i|_2 \leq M_e
$$</p>
<p><strong>定理12.1（STE的收敛性）</strong>：在假设12.1和12.2下，使用STE的梯度下降满足：</p>
<p>$$
\mathbb{E}\left[|\nabla \mathcal{L}|_2^2\right] \leq \frac{2(\mathcal{L}_0 - \mathcal{L}^*)}{\eta T} + \eta L^2
$$</p>
<p>其中$\mathcal{L}_0$是初始损失，$\mathcal{L}^*$是最优损失，$\eta$是学习率，$T$是迭代次数。</p>
<p><strong>定理12.2（旋转技巧的收敛性）</strong>：在相同假设下，如果额外假设$\frac{|q|<em min="min">2}{|z|_2} \in [\tau</em>]$，则旋转技巧的收敛率为：}, \tau_{max</p>
<p>$$
\mathbb{E}\left[|\nabla \mathcal{L}|<em min="min">2^2\right] \leq \frac{2(\mathcal{L}_0 - \mathcal{L}^*)}{\eta T \tau</em>^2 L^2
$$}^2} + \eta \tau_{max</p>
<p><strong>推论12.1</strong>：当$\tau_{min} = \tau_{max} = 1$（即范数匹配良好）时，旋转技巧的收敛率与STE相同。但当尺度比偏离1时，收敛会变慢（$\tau_{min} &lt; 1$）或需要更小的学习率（$\tau_{max} &gt; 1$）。</p>
<p><strong>定理12.3（编码表更新的收敛性）</strong>：编码表的更新可以视为在线K-Means，其收敛性满足：</p>
<p>$$
\mathbb{E}\left[\sum_{i=1}^K |e_i^{(t)} - e_i^*|_2^2\right] \leq C \cdot t^{-\alpha}
$$</p>
<p>其中$e_i^*$是最优编码向量，$\alpha \in (0.5, 1)$依赖于数据分布，$C$是常数。</p>
<h3 id="13">13. 实验验证的理论解释<a class="toc-link" href="#13" title="Permanent link">&para;</a></h3>
<p><strong>观察13.1（编码表利用率提升）</strong>：实验显示旋转技巧显著提高了编码表利用率（从~80%提升到~95%）。</p>
<p><strong>理论解释</strong>：根据定理9.2，旋转技巧在Voronoi边界附近引入梯度变化，增加了$z$"探索"不同编码向量的可能性。这可以通过以下机制量化：</p>
<p>设$P_{jump}(z)$为$z$从当前Voronoi区域跳到相邻区域的概率，则：</p>
<p>$$
P_{jump}^{STE}(z) \propto \exp\left(-\frac{|z - e_i|_2}{\sigma}\right)
$$</p>
<p>$$
P_{jump}^{rotate}(z) \propto \exp\left(-\frac{|z - e_i|_2}{\sigma}\right) \cdot \left(1 + |R - I|_F\right)
$$</p>
<p>其中$|R - I|_F$是Frobenius范数，度量旋转矩阵偏离单位矩阵的程度。因此旋转技巧增加了跳跃概率。</p>
<p><strong>观察13.2（重构损失降低）</strong>：实验显示旋转技巧降低了重构损失。</p>
<p><strong>理论解释</strong>：更高的编码表利用率意味着更细致的量化，从而降低量化误差：</p>
<p>$$
\mathcal{E}<em _in="\in" _mathcal_C="\mathcal{C" e="e">{VQ} = \mathbb{E}\left[\min</em>|z - e|_2^2\right]
$$}</p>
<p>当更多的编码向量被使用时，每个Voronoi区域的平均大小减小，量化误差降低。</p>
<p><strong>观察13.3（IS评分提升）</strong>：Inception Score (IS)提升表明生成质量改善。</p>
<p><strong>理论解释</strong>：更低的量化误差保留了更多信息，使得decoder能够重构更精确的输出，从而提高生成质量。</p>
<h3 id="14">14. 与相对位置编码的联系<a class="toc-link" href="#14" title="Permanent link">&para;</a></h3>
<p><strong>观察14.1（旋转的几何意义）</strong>：旋转操作与旋转位置编码（RoPE）有相似的几何结构。</p>
<p><strong>命题14.1（RoPE的旋转矩阵）</strong>：RoPE对位置$m$的向量$x$应用旋转：</p>
<p>$$
\text{RoPE}(x, m) = R(\theta m) x
$$</p>
<p>其中$R(\theta m)$是旋转矩阵，$\theta$是频率参数。</p>
<p><strong>观察14.2（VQ旋转与RoPE的区别）</strong>：
- RoPE：旋转角度由位置$m$决定，与内容无关
- VQ旋转：旋转矩阵$R$由$z$和$q$的相对方向决定，与内容有关</p>
<p><strong>猜想14.1</strong>：VQ的旋转技巧可以视为一种"内容自适应"的位置编码，它根据向量的实际几何关系动态调整变换。</p>
<h3 id="15">15. 总结与未来方向<a class="toc-link" href="#15" title="Permanent link">&para;</a></h3>
<p><strong>总结15.1（旋转技巧的核心贡献）</strong>：
1. 提出了一般化的STE框架：$z_q = \text{sg}[G]z + \text{sg}[q - Gz]$
2. 通过旋转矩阵$G = \frac{|q|_2}{|z|_2}R$实现几何一致性
3. 实验证明能提升编码表利用率和重构质量</p>
<p><strong>总结15.2（理论优势）</strong>：
1. 几何一致性：梯度的几何关系与量化的几何关系一致
2. 方向敏感性：梯度对$z$在Voronoi区域内的位置敏感
3. 边界增强：在边界附近增加探索，提高利用率</p>
<p><strong>总结15.3（潜在问题）</strong>：
1. 尺度敏感性：$\frac{|q|_2}{|z|_2}$的变化可能导致训练不稳定
2. 中心依赖性：引入了对原点的特殊依赖
3. 理论保证不足：缺乏严格的收敛性和有效性证明</p>
<p><strong>未来方向15.1（理论方面）</strong>：
1. 严格证明旋转技巧提升编码表利用率的充要条件
2. 分析不同数据分布下旋转技巧的有效性
3. 建立与信息论的联系，量化旋转技巧保留的信息量</p>
<p><strong>未来方向15.2（方法改进）</strong>：
1. 设计自适应的尺度调整策略
2. 结合其他VQ改进方法（如SimVQ的线性变换）
3. 探索其他几何变换（如反射、仿射变换）</p>
<p><strong>未来方向15.3（应用扩展）</strong>：
1. 将旋转技巧应用于更大规模的VQ-VAE模型
2. 在多模态学习中测试旋转技巧的效果
3. 探索旋转技巧在其他离散化场景（如神经网络量化）中的应用</p>
<hr />
<p>本推导详细阐述了VQ旋转技巧的数学基础、理论性质、潜在问题和改进方向，为理解和改进这一技术提供了坚实的理论支撑。</p>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="低秩近似之路三cr.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#146 低秩近似之路（三）：CR</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="低秩近似之路四id.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#148 低秩近似之路（四）：ID</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#vq">VQ的旋转技巧：梯度直通估计的一般推广</a><ul>
<li><a href="#_1">回顾</a></li>
<li><a href="#ste">STE</a></li>
<li><a href="#_2">旋转</a></li>
<li><a href="#_3">实验</a></li>
<li><a href="#_4">思考</a></li>
<li><a href="#_5">小结</a></li>
<li><a href="#_6">公式推导与注释</a><ul>
<li><a href="#1-vq">1. 向量量化(VQ)的基本数学定义</a></li>
<li><a href="#2-ste">2. 梯度直通估计器(STE)的数学原理</a></li>
<li><a href="#3">3. 一般化梯度直通估计器框架</a></li>
<li><a href="#4">4. 旋转技巧的几何解释</a></li>
<li><a href="#5">5. 计算效率优化</a></li>
<li><a href="#6">6. 梯度偏差分析与无偏估计</a></li>
<li><a href="#7-vq">7. 与其他VQ方法的理论对比</a></li>
<li><a href="#8">8. 优化景观分析</a></li>
<li><a href="#9">9. 旋转技巧的理论优势</a></li>
<li><a href="#10">10. 旋转技巧的潜在问题</a></li>
<li><a href="#11">11. 改进方案与变体</a></li>
<li><a href="#12">12. 收敛性分析</a></li>
<li><a href="#13">13. 实验验证的理论解释</a></li>
<li><a href="#14">14. 与相对位置编码的联系</a></li>
<li><a href="#15">15. 总结与未来方向</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>