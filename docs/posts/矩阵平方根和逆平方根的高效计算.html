<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>矩阵平方根和逆平方根的高效计算 | ML & Math Blog Posts</title>
    <meta name="description" content="矩阵平方根和逆平方根的高效计算&para;
原文链接: https://spaces.ac.cn/archives/11158
发布日期: 

设$\boldsymbol{P}\in\mathbb{R}^{n\times n}$是一个特征值都是非负实数的$n$阶方阵，本文来讨论它的平方根$\boldsymbol{P}^{1/2}$和逆平方根$\boldsymbol{P}^{-1/2}$的计算。
基...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=详细推导">详细推导</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #209 矩阵平方根和逆平方根的高效计算
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#209</span>
                矩阵平方根和逆平方根的高效计算
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> 2025-07-19</span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=详细推导" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 详细推导</span>
                </a>
                
                <a href="../index.html?tags=代数" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 代数</span>
                </a>
                
                <a href="../index.html?tags=迭代" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 迭代</span>
                </a>
                
                <a href="../index.html?tags=矩阵" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 矩阵</span>
                </a>
                
                <a href="../index.html?tags=线性" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 线性</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="_1">矩阵平方根和逆平方根的高效计算<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/11158">https://spaces.ac.cn/archives/11158</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>设$\boldsymbol{P}\in\mathbb{R}^{n\times n}$是一个特征值都是非负实数的$n$阶方阵，本文来讨论它的平方根$\boldsymbol{P}^{1/2}$和逆平方根$\boldsymbol{P}^{-1/2}$的计算。</p>
<h2 id="_2">基本概念<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>矩阵$\boldsymbol{P}$的平方根，指的是满足$\boldsymbol{X}^2=\boldsymbol{P}$的矩阵$\boldsymbol{X}$。我们知道正数都有两个平方根，因此不难想象矩阵平方根一般也不唯一。不过，“算术平方根”是唯一的，一个正数的算术平方根是正的那个平方根，类似地，我们将$\boldsymbol{P}$的特征值全是非负数的那个平方根称为算术平方根。本文要求的矩阵平方根，默认都是指算术平方根。</p>
<p>本文的计算依赖于我们在<a href="/archives/11056">《矩阵符号函数mcsgn能计算什么？》</a>讨论过的矩阵符号函数：<br />
\begin{equation}\newcommand{mcsgn}{\mathop{\text{mcsgn}}}\mcsgn(\boldsymbol{M}) = (\boldsymbol{M}^2)^{-1/2}\boldsymbol{M}= \boldsymbol{M}(\boldsymbol{M}^2)^{-1/2}<br />
\end{equation}<br />
简单来说，它就是把任意矩阵$\boldsymbol{M}\in\mathbb{R}^{n\times n}$的特征值变成对应的符号函数的新矩阵。假设$\boldsymbol{M}$的特征值都是实数，那么$\mcsgn$可以通过Newton-Schulz迭代高效计算：<br />
\begin{equation}\newcommand{tr}{\mathop{\text{tr}}}\boldsymbol{X}<em t_1="t+1">0 = \frac{\boldsymbol{M}}{\sqrt{\tr(\boldsymbol{M}^2)}},\qquad \boldsymbol{X}</em>} = a_{t+1}\boldsymbol{X<em t_1="t+1">t + b</em>}\boldsymbol{X<em t_1="t+1">t^3 + c</em>}\boldsymbol{X}_t^5\end{equation<br />
其中$\frac{\boldsymbol{M}}{\sqrt{\tr(\boldsymbol{M}^2)}}$是为了将$\boldsymbol{X}_0$的特征值都缩放到$[-1,1]$内，而$a_t,b_t,c_t$是<a href="/archives/10996">《msign算子的Newton-Schulz迭代（下）》</a>所推导的系数：<br />
\begin{array}{c|ccc}<br />
\hline<br />
t &amp; a\times 1.01 &amp; b\times 1.01^3 &amp; c\times 1.01^5 \\<br />
\hline<br />
\quad 1\quad &amp; 8.28721 &amp; -23.5959 &amp; 17.3004 \\<br />
2 &amp; 4.10706 &amp; -2.94785 &amp; 0.544843 \\<br />
3 &amp; 3.94869 &amp; -2.9089 &amp; 0.551819 \\<br />
4 &amp; 3.31842 &amp; -2.48849 &amp; 0.510049 \\<br />
5 &amp; 2.30065 &amp; -1.6689 &amp; 0.418807 \\<br />
6 &amp; 1.8913 &amp; 1.268 &amp; 0.376804 \\<br />
7 &amp; 1.875 &amp; -1.25 &amp; 0.375 \\<br />
8 &amp; 1.875 &amp; -1.25 &amp; 0.375 \\<br />
\hline<br />
\end{array}<br />
实际上，当$\boldsymbol{M}$的特征值全都是实数时，$\mcsgn$的计算原理跟另一种矩阵符号函数$\newcommand{msign}{\mathop{\text{msign}}}\msign$是相通的。</p>
<h2 id="_3">计算原理<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>接下来计算的出发点是恒等式<br />
\begin{equation}\mcsgn\left(\begin{bmatrix}\boldsymbol{0} &amp; \boldsymbol{A} \\ \boldsymbol{B} &amp; \boldsymbol{0}\end{bmatrix}\right)=\begin{bmatrix}\boldsymbol{0} &amp; \boldsymbol{A}(\boldsymbol{B}\boldsymbol{A})^{-1/2} \\ \boldsymbol{B}(\boldsymbol{A}\boldsymbol{B})^{-1/2} &amp; \boldsymbol{0}\end{bmatrix}\label{eq:core}\end{equation}<br />
直接代入$\mcsgn$的定义就可以验证上式成立（注：$\boldsymbol{A},\boldsymbol{B}$未必是方阵）。接下来我们要确定什么情况下左端求$\mcsgn$的矩阵的特征值全都是实数。设$\lambda$是它的一个非零特征值，那么<br />
\begin{equation}0=\det\left(\lambda\boldsymbol{I} - \begin{bmatrix}\boldsymbol{0} &amp; \boldsymbol{A} \\ \boldsymbol{B} &amp; \boldsymbol{0} \end{bmatrix}\right) = \det\left(\begin{bmatrix}\lambda\boldsymbol{I} &amp; -\boldsymbol{A} \\ -\boldsymbol{B} &amp; \lambda\boldsymbol{I} \end{bmatrix}\right) = \det(\lambda^2 \boldsymbol{I} - \boldsymbol{A}\boldsymbol{B})\end{equation}<br />
即$\lambda^2$是矩阵$\boldsymbol{A}\boldsymbol{B}$的特征值。这意味着上述分块矩阵的全体特征值都是实数，当且仅当$\boldsymbol{A}\boldsymbol{B}$的全体特征值非负。</p>
<p>直接对原矩阵进行迭代自然是可以的，但会比较浪费计算，我们可以利用它的反对角线结构来降低计算量。因为<br />
\begin{equation}<br />
\begin{bmatrix}\boldsymbol{0} &amp; \boldsymbol{Y} \\<br />
\boldsymbol{Z} &amp; \boldsymbol{0}\end{bmatrix}^3 = \begin{bmatrix}\boldsymbol{0} &amp; (\boldsymbol{Y}\boldsymbol{Z})\boldsymbol{Y} \\<br />
\boldsymbol{Z}(\boldsymbol{Y}\boldsymbol{Z}) &amp; \boldsymbol{0}\end{bmatrix},\quad<br />
\begin{bmatrix}\boldsymbol{0} &amp; \boldsymbol{Y} \\<br />
\boldsymbol{Z} &amp; \boldsymbol{0}\end{bmatrix}^5 = \begin{bmatrix}\boldsymbol{0} &amp; (\boldsymbol{Y}\boldsymbol{Z})^2\boldsymbol{Y} \\<br />
\boldsymbol{Z}(\boldsymbol{Y}\boldsymbol{Z})^2 &amp; \boldsymbol{0}\end{bmatrix} \\<br />
\end{equation}<br />
我们可以得到迭代<br />
\begin{gather}<br />
\boldsymbol{Y}<em t_1="t+1">{t+1} = (a</em>}\boldsymbol{I} + b_{t+1}\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t + c</em>}(\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t)^2)\boldsymbol{Y}_t \label{eq:r1} \\[6pt]<br />
\boldsymbol{Z}</em>} = \boldsymbol{Z<em t_1="t+1">t(a</em>}\boldsymbol{I} + b_{t+1}\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t + c</em>}(\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t)^2) \label{eq:r2}<br />
\end{gather}<br />
那么$\boldsymbol{Y}_t\to \boldsymbol{A}(\boldsymbol{B}\boldsymbol{A})^{-1/2},\boldsymbol{Z}_t\to \boldsymbol{B}(\boldsymbol{A}\boldsymbol{B})^{-1/2}$。特别地，将上面两式相乘可以得到$\boldsymbol{Y}_t\boldsymbol{Z}_t$的递归<br />
\begin{equation}\boldsymbol{Y}</em>}\boldsymbol{Z<em t_1="t+1">{t+1} = (a</em>}\boldsymbol{I} + b_{t+1}\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t + c</em>}(\boldsymbol{Y}_t\boldsymbol{Z}_t)^2)^2\boldsymbol{Y}_t\boldsymbol{Z}_t\label{eq:r3}\end{equation</p>
<h2 id="_4">求平方根<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h2>
<p>现在正式进入平方根的计算。由于假设了$\boldsymbol{P}$的特征值非负，我们总可以通过除以$\tr(\boldsymbol{P})$进一步将它的特征值压缩到$0\sim 1$之间，因此不失一般性，我们假设$\boldsymbol{P}$的特征值都在$[0,1]$内，这样就可以直接用Newton-Schulz迭代计算$\mcsgn$了。</p>
<p>将$\boldsymbol{A}=\boldsymbol{P},\boldsymbol{B}=\boldsymbol{I}$代入到式$\eqref{eq:core}$，可以得到<br />
\begin{equation}\mcsgn\left(\begin{bmatrix}\boldsymbol{0} &amp; \boldsymbol{P} \\ \boldsymbol{I} &amp; \boldsymbol{0}\end{bmatrix}\right)=\begin{bmatrix}\boldsymbol{0} &amp; \boldsymbol{P}^{1/2} \\ \boldsymbol{P}^{-1/2} &amp; \boldsymbol{0}\end{bmatrix}\end{equation}<br />
非常神奇，理论上通过只需要$\mcsgn$一次，就可以把平方根和逆平方根都求出来，也就是按照式$\eqref{eq:r1}$和$\eqref{eq:r2}$迭代，我们就可以同时完成两个任务！</p>
<p>然而，实际上没有这么理想。如果$\boldsymbol{P}$有非常接近于0的奇异值，那么$\boldsymbol{P}^{-1/2}$是会数值爆炸的（相当于出现了$1/\sqrt{0}$），但$\boldsymbol{P}^{1/2}$并不会，所以假设我们只关心$\boldsymbol{P}^{1/2}$的值，同时计算$\boldsymbol{P}^{1/2},\boldsymbol{P}^{-1/2}$反而会增加数值不稳定性。这时候更好的办法是通过式$\eqref{eq:r1}$和$\eqref{eq:r3}$来迭代，只计算$\boldsymbol{P}^{1/2}$：<br />
\begin{gather}<br />
\boldsymbol{Y}<em t_1="t+1">0 = \boldsymbol{P}, \quad \boldsymbol{Y}_0\boldsymbol{Z}_0 = \boldsymbol{P} \notag\\[6pt]<br />
\boldsymbol{Y}</em>} = (a_{t+1}\boldsymbol{I} + b_{t+1}\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t + c</em>}(\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t)^2)\boldsymbol{Y}_t \\[6pt]<br />
\boldsymbol{Y}</em>}\boldsymbol{Z<em t_1="t+1">{t+1} = (a</em>}\boldsymbol{I} + b_{t+1}\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t + c</em>}(\boldsymbol{Y<em t_to_infty="t\to\infty">t\boldsymbol{Z}_t)^2)^2\boldsymbol{Y}_t\boldsymbol{Z}_t \\[6pt]<br />
\lim</em>\notag} \boldsymbol{Y}_t = \boldsymbol{P}^{1/2<br />
\end{gather}<br />
由于$\boldsymbol{Z}_t$的极限是$\boldsymbol{P}^{-1/2}$，所以$\boldsymbol{Y}_t\boldsymbol{Z}_t$的极限是$\boldsymbol{I}$，因此迭代$\boldsymbol{Y}_t\boldsymbol{Z}_t$更不容易出现数值风险。参考代码如下：</p>
<pre class="highlight"><code>import numpy as np

def abc(steps):
    coefs = [
        (8.287212018145622, -23.59588651909882, 17.300387312530923),
        (4.107059111542197, -2.9478499167379084, 0.54484310829266),
        (3.9486908534822938, -2.908902115962947, 0.5518191394370131),
        (3.3184196573706055, -2.488488024314878, 0.5100489401237208),
        (2.3006520199548186, -1.6689039845747518, 0.4188073119525678),
        (1.8913014077874002, -1.2679958271945908, 0.37680408948524996),
        (1.875, -1.25, 0.375)
    ]
    for a, b, c in coefs[:steps] + max(steps - 7, 0) * coefs[-1:]:
        yield a / 1.01, b / 1.01**3, c / 1.01**5

def msqrt(P, steps=6):
    Y = YZ = P / (t := np.trace(P))
    I = np.eye(P.shape[0])
    for a, b, c in abc(steps):
        W = a * I + b * YZ + c * YZ @ YZ
        Y, YZ = W @ Y, W @ W @ YZ
    return Y * t**0.5

d = 100
P = (x := np.random.randn(d, d) / d**0.5) @ x.T
np.abs(msqrt(P) @ msqrt(P) - P).mean()  # ~= 2e-4
</code></pre>

<h2 id="_5">逆平方根<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h2>
<p>如果我们必须要显式地求出逆平方根$\boldsymbol{P}^{-1/2}$，那么就没什么好办法了，该爆炸的始终都会爆炸，这时候不管是式$\eqref{eq:r2},\eqref{eq:r1}$组合还是式$\eqref{eq:r2},\eqref{eq:r3}$组合，效果都应该差不多，不过后者应该会相对稳定一点：<br />
\begin{gather}<br />
\boldsymbol{Z}<em t_1="t+1">0 = \boldsymbol{I}, \quad \boldsymbol{Y}_0\boldsymbol{Z}_0 = \boldsymbol{P} \notag\\[6pt]<br />
\boldsymbol{Z}</em>} = \boldsymbol{Z<em t_1="t+1">t(a</em>}\boldsymbol{I} + b_{t+1}\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t + c</em>}(\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t)^2)\label{eq:r2-rsqrt} \\[6pt]<br />
\boldsymbol{Y}</em>}\boldsymbol{Z<em t_1="t+1">{t+1} = (a</em>}\boldsymbol{I} + b_{t+1}\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t + c</em>}(\boldsymbol{Y<em t_to_infty="t\to\infty">t\boldsymbol{Z}_t)^2)^2\boldsymbol{Y}_t\boldsymbol{Z}_t\label{eq:r3-rsqrt} \\[6pt]<br />
\lim</em>\notag} \boldsymbol{Z}_t = \boldsymbol{P}^{-1/2<br />
\end{gather}</p>
<p>参考代码如下：</p>
<pre class="highlight"><code>def mrsqrt(P, steps=6):
    YZ = P / (t := np.trace(P))
    Z = I = np.eye(P.shape[0])
    for a, b, c in abc(steps):
        W = a * I + b * YZ + c * YZ @ YZ
        Z, YZ = Z @ W, W @ W @ YZ
    return Z / t**0.5

d = 100
P = (x := np.random.randn(d, d) / d**0.5) @ x.T
np.abs(mrsqrt(P) @ mrsqrt(P) @ P - np.eye(d)).mean()  # ~= 5e-4
</code></pre>

<h2 id="_6">矩阵相乘<a class="toc-link" href="#_6" title="Permanent link">&para;</a></h2>
<p>不过在大多数时候，求$\boldsymbol{P}^{-1/2}$只是一个中间步骤，求完之后通常还要跟另一个矩阵做乘法。设矩阵$\boldsymbol{G}\in\mathbb{R}^{m\times n}$，我们需要计算$\boldsymbol{G}\boldsymbol{P}^{-1/2}$，如果我们能将$\boldsymbol{G}\boldsymbol{P}^{-1/2}$作为一个整体的迭代对象，那么相比单独求出$\boldsymbol{P}^{-1/2}$然后再执行矩阵乘法，往往有更好的数值稳定性。</p>
<p>让我们仔细观察式$\eqref{eq:r2-rsqrt}$和$\eqref{eq:r3-rsqrt}$，不难看出，当我们将$\boldsymbol{Y}<em t_1="t+1">t\boldsymbol{Z}_t$视为一个整体时，它的迭代式$\eqref{eq:r3-rsqrt}$其实是独立于$\boldsymbol{Z}_t$的，所以$\boldsymbol{Z}_t$的式$\eqref{eq:r2-rsqrt}$本质上就只是一个线性递归！我们在它左边乘以一个矩阵，并不改变迭代形式，只需要修改一下初始值，于是得到<br />
\begin{gather}<br />
\boldsymbol{Z}_0 = \boldsymbol{G}, \quad \boldsymbol{Y}_0\boldsymbol{Z}_0 = \boldsymbol{P} \notag\\[6pt]<br />
\boldsymbol{Z}</em>} = \boldsymbol{Z<em t_1="t+1">t(a</em>}\boldsymbol{I} + b_{t+1}\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t + c</em>}(\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t)^2) \label{eq:r2-final} \\[6pt]<br />
\boldsymbol{Y}</em>}\boldsymbol{Z<em t_1="t+1">{t+1} = (a</em>}\boldsymbol{I} + b_{t+1}\boldsymbol{Y<em t_1="t+1">t\boldsymbol{Z}_t + c</em>}(\boldsymbol{Y<em t_to_infty="t\to\infty">t\boldsymbol{Z}_t)^2)^2\boldsymbol{Y}_t\boldsymbol{Z}_t \label{eq:r3-final}\\[6pt]<br />
\lim</em>\notag} \boldsymbol{Z}_t = \boldsymbol{G}\boldsymbol{P}^{-1/2<br />
\end{gather}</p>
<p>参考代码：</p>
<pre class="highlight"><code>import scipy as sp

def matmul_mrsqrt(G, P, steps=6):
    YZ = P / (t := np.trace(P))
    Z, I = G, np.eye(P.shape[0])
    for a, b, c in abc(steps):
        W = a * I + b * YZ + c * YZ @ YZ
        Z, YZ = Z @ W, W @ W @ YZ
    return Z / t**0.5

d = 100
P = (x := np.random.randn(d, d) / d**0.5) @ x.T
G = np.random.randn(2 * d, d) / d**0.5
X = matmul_mrsqrt(G, P)
np.abs(X @ sp.linalg.sqrtm(P) - G).mean()  # ~= 1e-4
</code></pre>

<p>现在，让我们回过头来看求平方根的算法，不难看出它其实就是$\boldsymbol{G}=\boldsymbol{P}$时本节迭代的另一个等价写法，即$\boldsymbol{P}^{1/2}=\boldsymbol{P}\boldsymbol{P}^{-1/2}$。所以，虽然我们看上去式分开了三节来讨论了三个迭代，但它们本质上都是最后一个迭代的特例！</p>
<h2 id="_7">终极推广<a class="toc-link" href="#_7" title="Permanent link">&para;</a></h2>
<p>最后，我们还可以将它推广到$\boldsymbol{Q}^{-1/2}\boldsymbol{G}\boldsymbol{P}^{-1/2}$的计算，其中$\boldsymbol{Q}\in\mathbb{R}^{m\times m}$是另一个特征值非负的矩阵，结果如下：<br />
\begin{gather}<br />
\boldsymbol{G}<em t_1="t+1">0 = \boldsymbol{G}, \quad \boldsymbol{Q}_0 = \boldsymbol{Q},\quad \boldsymbol{P}_0 = \boldsymbol{P} \notag\\[6pt]<br />
\boldsymbol{G}</em>} = (a_{t+1}\boldsymbol{I} + b_{t+1}\boldsymbol{Q<em t_1="t+1">t + c</em>}\boldsymbol{Q<em t_1="t+1">t^2)\boldsymbol{G}_t(a</em>}\boldsymbol{I} + b_{t+1}\boldsymbol{P<em t_1="t+1">t + c</em>}\boldsymbol{P<em t_1="t+1">t^2) \\[6pt]<br />
\boldsymbol{Q}</em>} = (a_{t+1}\boldsymbol{I} + b_{t+1}\boldsymbol{Q<em t_1="t+1">t + c</em>}\boldsymbol{Q<em t_1="t+1">t^2)^2\boldsymbol{Q}_t \\[6pt]<br />
\boldsymbol{P}</em>} = (a_{t+1}\boldsymbol{I} + b_{t+1}\boldsymbol{P<em t_1="t+1">t + c</em>}\boldsymbol{P<em t_to_infty="t\to\infty">t^2)^2\boldsymbol{P}_t \\[6pt]<br />
\lim</em>\notag} \boldsymbol{G}_t = \boldsymbol{Q}^{-1/2}\boldsymbol{G}\boldsymbol{P}^{-1/2<br />
\end{gather}</p>
<p>参考代码：</p>
<pre class="highlight"><code>def mrsqrt_matmul_mrsqrt(Q, G, P, steps=6):
    Q = Q / (t1 := np.trace(Q))
    P = P / (t2 := np.trace(P))
    I1, I2 = np.eye(Q.shape[0]), np.eye(P.shape[0])
    for a, b, c in abc(steps):
        W1 = a * I1 + b * Q + c * Q @ Q
        W2 = a * I2 + b * P + c * P @ P
        G, Q, P = W1 @ G @ W2, W1 @ W1 @ Q, W2 @ W2 @ P
    return G / (t1 * t2) **0.5

d = 100
Q = (x := np.random.randn(2 * d, 2 * d) / (2 * d)**0.5) @ x.T
P = (x := np.random.randn(d, d) / d**0.5) @ x.T
G = np.random.randn(2 * d, d) / d**0.5
X = mrsqrt_matmul_mrsqrt(Q, G, P)
np.abs(sp.linalg.sqrtm(Q) @ X @ sp.linalg.sqrtm(P) - G).mean()  # ~= 2e-3
</code></pre>

<p>请读者根据前几节的结果自行完成证明。</p>
<p>对于<a href="https://papers.cool/arxiv/1802.09568">Shampoo优化器</a>，我们需要求$\boldsymbol{Q}^{-1/4}\boldsymbol{G}\boldsymbol{P}^{-1/4}$，目前看来比较可行的方案是分别先求出$\boldsymbol{Q}^{1/2}$和$\boldsymbol{P}^{1/2}$，然后代入上述迭代中求$(\boldsymbol{Q}^{1/2})^{-1/2}\boldsymbol{G}(\boldsymbol{P}^{1/2})^{-1/2}$。看上去计算量比较大，但实际上在Optimizer的Update阶段，算力往往不是瓶颈，只要算法可以充分并行，那么时间并不会明显增加，刚好$\boldsymbol{Q}^{1/2}$和$\boldsymbol{P}^{1/2}$的计算可以并行，迭代过程中两个W1、W2也可以并行，因此应该还能接受。</p>
<p>当然，比Muon慢是肯定的，毕竟Shampoo复杂度增加了这么多，总不能一点代价都不用付出（后续见<a href="/archives/11175">《矩阵r次方根和逆r次方根的高效计算》</a>）。</p>
<h2 id="_8">文章小结<a class="toc-link" href="#_8" title="Permanent link">&para;</a></h2>
<p>本文提出了将矩阵的平方根和逆平方根转化为$\mcsgn$形式，利用它的Newton-Schulz迭代来实现高效计算的过程。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/11158">https://spaces.ac.cn/archives/11158</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Jul. 19, 2025). 《矩阵平方根和逆平方根的高效计算 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/11158">https://spaces.ac.cn/archives/11158</a></p>
<p>@online{kexuefm-11158,<br />
title={矩阵平方根和逆平方根的高效计算},<br />
author={苏剑林},<br />
year={2025},<br />
month={Jul},<br />
url={\url{https://spaces.ac.cn/archives/11158}},<br />
} </p>
<hr />
<h2 id="_9">公式推导与注释<a class="toc-link" href="#_9" title="Permanent link">&para;</a></h2>
<h3 id="1">1. 矩阵平方根的定义与存在性理论<a class="toc-link" href="#1" title="Permanent link">&para;</a></h3>
<p><strong>定义1.1</strong> (矩阵平方根)<br />
对于矩阵$\boldsymbol{A}\in\mathbb{R}^{n\times n}$，若存在矩阵$\boldsymbol{X}\in\mathbb{R}^{n\times n}$使得<br />
$$\boldsymbol{X}^2 = \boldsymbol{A}$$<br />
则称$\boldsymbol{X}$为$\boldsymbol{A}$的一个平方根，记作$\boldsymbol{X}=\boldsymbol{A}^{1/2}$。</p>
<p><strong>定理1.1</strong> (平方根存在性)<br />
设$\boldsymbol{A}\in\mathbb{R}^{n\times n}$，若$\boldsymbol{A}$的所有特征值$\lambda_i$满足$\Re(\lambda_i)\geq 0$且对于$\Re(\lambda_i)=0$的特征值，其对应的Jordan块大小为1，则$\boldsymbol{A}$存在唯一的主平方根$\boldsymbol{X}$，且$\boldsymbol{X}$的特征值$\mu_i$满足$\mu_i^2=\lambda_i$且$\Re(\mu_i)\geq 0$。</p>
<p><strong>证明</strong>：对于对角化矩阵，设$\boldsymbol{A}=\boldsymbol{V}\boldsymbol{\Lambda}\boldsymbol{V}^{-1}$，其中$\boldsymbol{\Lambda}=\text{diag}(\lambda_1,\ldots,\lambda_n)$。定义<br />
$$\boldsymbol{X}=\boldsymbol{V}\boldsymbol{\Lambda}^{1/2}\boldsymbol{V}^{-1}$$<br />
其中$\boldsymbol{\Lambda}^{1/2}=\text{diag}(\sqrt{\lambda_1},\ldots,\sqrt{\lambda_n})$，取算术平方根。显然<br />
$$\boldsymbol{X}^2=\boldsymbol{V}\boldsymbol{\Lambda}^{1/2}\boldsymbol{V}^{-1}\boldsymbol{V}\boldsymbol{\Lambda}^{1/2}\boldsymbol{V}^{-1}=\boldsymbol{V}\boldsymbol{\Lambda}\boldsymbol{V}^{-1}=\boldsymbol{A}$$</p>
<p><strong>推论1.1</strong> (正定矩阵的平方根)<br />
若$\boldsymbol{P}\in\mathbb{R}^{n\times n}$是对称正定矩阵（即$\boldsymbol{P}=\boldsymbol{P}^T$且所有特征值$\lambda_i&gt;0$），则$\boldsymbol{P}$存在唯一的对称正定平方根$\boldsymbol{P}^{1/2}$，满足<br />
$$(\boldsymbol{P}^{1/2})^2=\boldsymbol{P},\quad \boldsymbol{P}^{1/2}=(\boldsymbol{P}^{1/2})^T,\quad \boldsymbol{P}^{1/2}\succ 0$$</p>
<h3 id="2-schur">2. Schur分解方法的完整推导<a class="toc-link" href="#2-schur" title="Permanent link">&para;</a></h3>
<p><strong>定理2.1</strong> (Schur分解)<br />
任意矩阵$\boldsymbol{A}\in\mathbb{C}^{n\times n}$都可以分解为<br />
$$\boldsymbol{A}=\boldsymbol{Q}\boldsymbol{T}\boldsymbol{Q}^H$$<br />
其中$\boldsymbol{Q}$是酉矩阵（$\boldsymbol{Q}^H\boldsymbol{Q}=\boldsymbol{I}$），$\boldsymbol{T}$是上三角矩阵，对角线元素为$\boldsymbol{A}$的特征值。</p>
<p><strong>算法2.1</strong> (基于Schur分解的平方根计算)</p>
<p>设$\boldsymbol{A}=\boldsymbol{Q}\boldsymbol{T}\boldsymbol{Q}^H$是Schur分解，要求$\boldsymbol{X}=\boldsymbol{A}^{1/2}$，我们设<br />
$$\boldsymbol{X}=\boldsymbol{Q}\boldsymbol{U}\boldsymbol{Q}^H$$<br />
其中$\boldsymbol{U}$也是上三角矩阵。由$\boldsymbol{X}^2=\boldsymbol{A}$得<br />
$$\boldsymbol{Q}\boldsymbol{U}\boldsymbol{Q}^H\boldsymbol{Q}\boldsymbol{U}\boldsymbol{Q}^H=\boldsymbol{Q}\boldsymbol{T}\boldsymbol{Q}^H$$<br />
$$\boldsymbol{U}^2=\boldsymbol{T}$$</p>
<p>现在问题转化为求上三角矩阵$\boldsymbol{T}$的平方根$\boldsymbol{U}$。设$\boldsymbol{U}=(u_{ij})$，$\boldsymbol{T}=(t_{ij})$，由$\boldsymbol{U}^2=\boldsymbol{T}$的第$(i,j)$元素：<br />
$$\sum_{k=1}^{n}u_{ik}u_{kj}=t_{ij}$$</p>
<p>由于$\boldsymbol{U}$和$\boldsymbol{T}$都是上三角，当$i&gt;j$时左右两边都为0。对于$i\leq j$：</p>
<p><strong>第一步</strong>：对角元素（$i=j$）<br />
$$u_{ii}^2=t_{ii}\quad\Rightarrow\quad u_{ii}=\sqrt{t_{ii}}$$</p>
<p><strong>第二步</strong>：非对角元素（$i&lt;j$），利用上三角性质<br />
$$\sum_{k=i}^{j}u_{ik}u_{kj}=t_{ij}$$<br />
$$u_{ii}u_{ij}+\sum_{k=i+1}^{j-1}u_{ik}u_{kj}+u_{ij}u_{jj}=t_{ij}$$<br />
$$(u_{ii}+u_{jj})u_{ij}=-\sum_{k=i+1}^{j-1}u_{ik}u_{kj}+t_{ij}$$<br />
$$u_{ij}=\frac{t_{ij}-\sum_{k=i+1}^{j-1}u_{ik}u_{kj}}{u_{ii}+u_{jj}}$$</p>
<p>这给出了一个递推算法：先计算对角元素，然后按列从左到右、从上到下计算非对角元素。</p>
<p><strong>计算复杂度分析</strong>：<br />
- Schur分解：$O(n^3)$（QR算法）<br />
- 求解$\boldsymbol{U}$：对角线$O(n)$，每个非对角元素需要$O(j-i)$次运算，总计$O(n^3)$<br />
- 总复杂度：$O(n^3)$</p>
<h3 id="3-newton">3. Newton迭代法的详细推导<a class="toc-link" href="#3-newton" title="Permanent link">&para;</a></h3>
<p><strong>定理3.1</strong> (Newton迭代的收敛性)<br />
考虑方程$f(\boldsymbol{X})=\boldsymbol{X}^2-\boldsymbol{A}=\boldsymbol{0}$，Newton迭代格式为<br />
$$\boldsymbol{X}_{k+1}=\boldsymbol{X}_k-[f'(\boldsymbol{X}_k)]^{-1}f(\boldsymbol{X}_k)$$</p>
<p>对于矩阵函数$f(\boldsymbol{X})=\boldsymbol{X}^2-\boldsymbol{A}$，其Fréchet导数为<br />
$$f'(\boldsymbol{X})[\boldsymbol{H}]=\boldsymbol{X}\boldsymbol{H}+\boldsymbol{H}\boldsymbol{X}$$</p>
<p><strong>推导</strong>：设$f(\boldsymbol{X}+\boldsymbol{H})=(\boldsymbol{X}+\boldsymbol{H})^2-\boldsymbol{A}$，展开得<br />
\begin{align}<br />
f(\boldsymbol{X}+\boldsymbol{H})&amp;=\boldsymbol{X}^2+\boldsymbol{X}\boldsymbol{H}+\boldsymbol{H}\boldsymbol{X}+\boldsymbol{H}^2-\boldsymbol{A}\<br />
&amp;=f(\boldsymbol{X})+\boldsymbol{X}\boldsymbol{H}+\boldsymbol{H}\boldsymbol{X}+O(|\boldsymbol{H}|^2)<br />
\end{align}</p>
<p>因此$f'(\boldsymbol{X})[\boldsymbol{H}]=\boldsymbol{X}\boldsymbol{H}+\boldsymbol{H}\boldsymbol{X}$。</p>
<p>Newton迭代要求解<br />
$$\boldsymbol{X}<em k="k">{k}\boldsymbol{H}+\boldsymbol{H}\boldsymbol{X}</em>^2$$}=\boldsymbol{A}-\boldsymbol{X}_{k</p>
<p>这是Sylvester方程。对于可逆的$\boldsymbol{X}_k$，一个特殊解为<br />
$$\boldsymbol{H}=\frac{1}{2}\boldsymbol{X}_k^{-1}(\boldsymbol{A}-\boldsymbol{X}_k^2)$$</p>
<p>验证：<br />
\begin{align}<br />
\boldsymbol{X}_k\boldsymbol{H}+\boldsymbol{H}\boldsymbol{X}_k&amp;=\frac{1}{2}(\boldsymbol{A}-\boldsymbol{X}_k^2)+\frac{1}{2}\boldsymbol{X}_k^{-1}(\boldsymbol{A}-\boldsymbol{X}_k^2)\boldsymbol{X}_k\<br />
&amp;=\frac{1}{2}(\boldsymbol{A}-\boldsymbol{X}_k^2)+\frac{1}{2}(\boldsymbol{X}_k^{-1}\boldsymbol{A}\boldsymbol{X}_k-\boldsymbol{X}_k)\<br />
&amp;=\boldsymbol{A}-\boldsymbol{X}_k^2\quad\text{（当}\boldsymbol{X}_k\text{与}\boldsymbol{A}\text{可交换时）}<br />
\end{align}</p>
<p>对于一般情况，Newton迭代格式为<br />
$$\boldsymbol{X}_{k+1}=\boldsymbol{X}_k+\frac{1}{2}\boldsymbol{X}_k^{-1}(\boldsymbol{A}-\boldsymbol{X}_k^2)=\frac{1}{2}(\boldsymbol{X}_k+\boldsymbol{A}\boldsymbol{X}_k^{-1})$$</p>
<p><strong>定理3.2</strong> (Newton迭代的二次收敛)<br />
设$\boldsymbol{X}<em k_1="k+1">k$收敛到$\boldsymbol{A}^{1/2}$，定义误差$\boldsymbol{E}_k=\boldsymbol{X}_k-\boldsymbol{A}^{1/2}$，则<br />
$$|\boldsymbol{E}</em>_k|^2)$$}|=O(|\boldsymbol{E</p>
<p><strong>证明</strong>：设$\boldsymbol{X}<em><em>=\boldsymbol{A}^{1/2}$，则<br />
\begin{align}<br />
\boldsymbol{E}<em k_1="k+1">{k+1}&amp;=\boldsymbol{X}</em>_}-\boldsymbol{X</em>=\frac{1}{2}(\boldsymbol{X}_k+\boldsymbol{A}\boldsymbol{X}_k^{-1})-\boldsymbol{X}</em><em>\<br />
&amp;=\frac{1}{2}\boldsymbol{X}<em>k^{-1}(\boldsymbol{X}_k^2+\boldsymbol{A}-2\boldsymbol{X}</em></em>\boldsymbol{X}<em>k)\<br />
&amp;=\frac{1}{2}\boldsymbol{X}_k^{-1}(\boldsymbol{X}_k^2-\boldsymbol{X}</em><em>^2-2\boldsymbol{X}_</em>\boldsymbol{X}<em>k+2\boldsymbol{X}</em><em>^2)\<br />
&amp;=\frac{1}{2}\boldsymbol{X}<em>k^{-1}[(\boldsymbol{X}_k-\boldsymbol{X}</em></em>)^2+2\boldsymbol{X}<em><em>(\boldsymbol{X}_</em>-\boldsymbol{X}_k)]\<br />
&amp;=\frac{1}{2}\boldsymbol{X}_k^{-1}(\boldsymbol{E}_k^2-2\boldsymbol{X}</em><em>\boldsymbol{E}<em>k)\<br />
&amp;=\frac{1}{2}\boldsymbol{X}_k^{-1}\boldsymbol{E}_k(\boldsymbol{E}_k-2\boldsymbol{X}</em></em>)<br />
\end{align}</p>
<p>因此$|\boldsymbol{E}<em>{k+1}|\leq \frac{1}{2}|\boldsymbol{X}_k^{-1}||\boldsymbol{E}_k||\boldsymbol{E}_k-2\boldsymbol{X}</em>*|=O(|\boldsymbol{E}_k|^2)$。</p>
<h3 id="4-denman-beavers">4. Denman-Beavers算法的详细分析<a class="toc-link" href="#4-denman-beavers" title="Permanent link">&para;</a></h3>
<p><strong>算法4.1</strong> (Denman-Beavers迭代)<br />
Denman-Beavers算法同时迭代$\boldsymbol{Y}<em k_1="k+1">k\to\boldsymbol{A}^{1/2}$和$\boldsymbol{Z}_k\to\boldsymbol{A}^{-1/2}$：<br />
\begin{align}<br />
\boldsymbol{Y}_0&amp;=\boldsymbol{A},\quad \boldsymbol{Z}_0=\boldsymbol{I}\<br />
\boldsymbol{Y}</em>}&amp;=\frac{1}{2}(\boldsymbol{Y<em k_1="k+1">k+\boldsymbol{Z}_k^{-1})\<br />
\boldsymbol{Z}</em>)}&amp;=\frac{1}{2}(\boldsymbol{Z}_k+\boldsymbol{Y}_k^{-1<br />
\end{align}</p>
<p><strong>定理4.1</strong> (Denman-Beavers的收敛性)<br />
若$\boldsymbol{A}$的特征值满足$|\lambda_i-1|&lt;1$（即特征值在以1为中心、半径为1的圆内），则Denman-Beavers迭代收敛，且满足不变量<br />
$$\boldsymbol{Y}<em k-1="k-1">k\boldsymbol{Z}_k=\boldsymbol{Y}</em>$$}\boldsymbol{Z}_{k-1}=\cdots=\boldsymbol{Y}_0\boldsymbol{Z}_0=\boldsymbol{A</p>
<p><strong>证明</strong>：首先验证不变量。由定义<br />
\begin{align}<br />
\boldsymbol{Y}<em k_1="k+1">{k+1}\boldsymbol{Z}</em>)\}&amp;=\frac{1}{4}(\boldsymbol{Y}_k+\boldsymbol{Z}_k^{-1})(\boldsymbol{Z}_k+\boldsymbol{Y}_k^{-1<br />
&amp;=\frac{1}{4}(\boldsymbol{Y}_k\boldsymbol{Z}_k+\boldsymbol{Y}_k\boldsymbol{Y}_k^{-1}+\boldsymbol{Z}_k^{-1}\boldsymbol{Z}_k+\boldsymbol{Z}_k^{-1}\boldsymbol{Y}_k^{-1})\<br />
&amp;=\frac{1}{4}(\boldsymbol{Y}_k\boldsymbol{Z}_k+\boldsymbol{I}+\boldsymbol{I}+(\boldsymbol{Y}_k\boldsymbol{Z}_k)^{-1})<br />
\end{align}</p>
<p>若$\boldsymbol{Y}<em k_1="k+1">k\boldsymbol{Z}_k=\boldsymbol{A}$，则<br />
$$\boldsymbol{Y}</em>)$$}\boldsymbol{Z}_{k+1}=\frac{1}{4}(\boldsymbol{A}+2\boldsymbol{I}+\boldsymbol{A}^{-1</p>
<p>这看起来不等于$\boldsymbol{A}$！让我们重新考虑。实际上，Denman-Beavers有另一种形式，定义$\boldsymbol{M}<em k_1="k+1">k=\boldsymbol{Y}_k\boldsymbol{Z}_k$，则有<br />
$$\boldsymbol{M}</em>_k^2)$$}=\frac{1}{2}(\boldsymbol{I}+\boldsymbol{M</p>
<p>这个迭代会使$\boldsymbol{M}_k\to\boldsymbol{I}$（当初值的特征值在适当范围内）。</p>
<p><strong>改进形式</strong>：为了保持$\boldsymbol{Y}<em k_1="k+1">k\boldsymbol{Z}_k=\boldsymbol{A}$，我们使用<br />
\begin{align}<br />
\boldsymbol{Y}</em>}&amp;=\frac{1}{2}\boldsymbol{Y<em k_1="k+1">k(\boldsymbol{I}+\boldsymbol{Z}_k\boldsymbol{Y}_k)^{-1}\<br />
\boldsymbol{Z}</em>_k}&amp;=\frac{1}{2}(\boldsymbol{I}+\boldsymbol{Z}_k\boldsymbol{Y}_k)^{-1}\boldsymbol{Z<br />
\end{align}</p>
<p>或等价地<br />
\begin{align}<br />
\boldsymbol{Y}<em k_1="k+1">{k+1}&amp;=\boldsymbol{Y}_k(\boldsymbol{I}+\boldsymbol{M}_k^{-1})^{-1}\<br />
\boldsymbol{M}</em>}&amp;=\boldsymbol{M}_k(\boldsymbol{I}+\boldsymbol{M}_k^{-1})^{-2<br />
\end{align}<br />
其中$\boldsymbol{M}_k=\boldsymbol{Z}_k\boldsymbol{Y}_k$。</p>
<p><strong>定理4.2</strong> (二次收敛性)<br />
设$\boldsymbol{M}_k$的特征值记为$\mu_i^{(k)}$，则<br />
$$\mu_i^{(k+1)}=\frac{\mu_i^{(k)}}{(1+\mu_i^{(k)-1})^2}=\frac{\mu_i^{(k)}}{(\mu_i^{(k)}+1)^2/\mu_i^{(k)}}=\frac{(\mu_i^{(k)})^2}{(\mu_i^{(k)}+1)^2}$$</p>
<p>当$\mu_i^{(k)}\approx 1$时，设$\mu_i^{(k)}=1+\epsilon_k$，则<br />
$$\mu_i^{(k+1)}=\frac{(1+\epsilon_k)^2}{(2+\epsilon_k)^2}=\frac{1+2\epsilon_k+\epsilon_k^2}{4+4\epsilon_k+\epsilon_k^2}\approx 1-\frac{1}{2}\epsilon_k+O(\epsilon_k^2)$$</p>
<p>这表明误差以二次速度收敛到0。</p>
<h3 id="5-halley">5. Halley迭代的高阶收敛性<a class="toc-link" href="#5-halley" title="Permanent link">&para;</a></h3>
<p><strong>定理5.1</strong> (Halley迭代公式)<br />
Halley方法是Newton方法的三阶推广。对于$f(\boldsymbol{X})=\boldsymbol{X}^2-\boldsymbol{A}$，Halley迭代为<br />
$$\boldsymbol{X}_{k+1}=\boldsymbol{X}_k-\frac{f(\boldsymbol{X}_k)}{f'(\boldsymbol{X}_k)-\frac{1}{2}f(\boldsymbol{X}_k)f''(\boldsymbol{X}_k)/f'(\boldsymbol{X}_k)}$$</p>
<p>对于矩阵平方根，简化后的Halley迭代为<br />
$$\boldsymbol{X}_{k+1}=\boldsymbol{X}_k(\boldsymbol{I}+\boldsymbol{C}_k)(\boldsymbol{I}+3\boldsymbol{C}_k)^{-1}$$<br />
其中$\boldsymbol{C}_k=\boldsymbol{X}_k^{-1}(\boldsymbol{A}-\boldsymbol{X}_k^2)\boldsymbol{X}_k^{-1}$。</p>
<p><strong>推导</strong>：设$\boldsymbol{R}<em k_1="k+1">k=\boldsymbol{I}-\boldsymbol{X}_k^{-1}\boldsymbol{A}\boldsymbol{X}_k^{-1}$为残差，则Newton迭代可写为<br />
$$\boldsymbol{X}</em>_k)$$}=\boldsymbol{X}_k(\boldsymbol{I}+\frac{1}{2}\boldsymbol{R</p>
<p>Halley迭代在Newton基础上增加了二阶修正：<br />
$$\boldsymbol{X}_{k+1}=\boldsymbol{X}_k(\boldsymbol{I}+\frac{1}{2}\boldsymbol{R}_k+\frac{3}{8}\boldsymbol{R}_k^2)$$</p>
<p>可以验证这等价于<br />
$$\boldsymbol{X}_{k+1}=\boldsymbol{X}_k\frac{\boldsymbol{I}+3\boldsymbol{C}_k}{\boldsymbol{I}+\boldsymbol{C}_k}$$<br />
其中使用了$(1+x)^{-1}\approx 1-x+x^2-\cdots$的展开。</p>
<p><strong>定理5.2</strong> (三次收敛性)<br />
Halley迭代满足<br />
$$|\boldsymbol{E}_{k+1}|=O(|\boldsymbol{E}_k|^3)$$</p>
<p><strong>证明</strong> (简要)：Taylor展开到三阶，利用$f(\boldsymbol{X}_<em>)=0$，$f'(\boldsymbol{X}_</em>)$非奇异，以及Halley修正项精确抵消了二阶项，可以证明误差满足三次关系。</p>
<h3 id="6">6. 逆平方根的数值稳定算法<a class="toc-link" href="#6" title="Permanent link">&para;</a></h3>
<p><strong>问题6.1</strong> (逆平方根的数值挑战)<br />
计算$\boldsymbol{A}^{-1/2}$时，若$\boldsymbol{A}$有接近0的特征值，则$\boldsymbol{A}^{-1/2}$的对应特征值趋于无穷，导致数值不稳定。</p>
<p><strong>算法6.1</strong> (Newton-Schulz逆平方根迭代)<br />
设$\boldsymbol{A}$的特征值在$(0,\kappa^2]$范围内，归一化使其在$(0,1]$。Newton-Schulz迭代：<br />
$$\boldsymbol{X}<em _max="\max">0=\frac{1}{\sqrt{\lambda</em>_k^2)$$}(\boldsymbol{A})}}\boldsymbol{I},\quad \boldsymbol{X}_{k+1}=\frac{1}{2}\boldsymbol{X}_k(3\boldsymbol{I}-\boldsymbol{A}\boldsymbol{X</p>
<p><strong>推导</strong>：要求$\boldsymbol{X}^2\boldsymbol{A}=\boldsymbol{I}$，即$f(\boldsymbol{X})=\boldsymbol{I}-\boldsymbol{A}\boldsymbol{X}^2=\boldsymbol{0}$。</p>
<p>Fréchet导数：$f'(\boldsymbol{X})[\boldsymbol{H}]=-\boldsymbol{A}(\boldsymbol{X}\boldsymbol{H}+\boldsymbol{H}\boldsymbol{X})=-2\boldsymbol{A}\boldsymbol{X}\boldsymbol{H}$（对称情况）</p>
<p>Newton迭代：<br />
\begin{align}<br />
\boldsymbol{X}_{k+1}&amp;=\boldsymbol{X}_k-[f'(\boldsymbol{X}_k)]^{-1}f(\boldsymbol{X}_k)\<br />
&amp;=\boldsymbol{X}_k+\frac{1}{2}(\boldsymbol{A}\boldsymbol{X}_k)^{-1}(\boldsymbol{I}-\boldsymbol{A}\boldsymbol{X}_k^2)\<br />
&amp;=\boldsymbol{X}_k+\frac{1}{2}\boldsymbol{X}_k\boldsymbol{A}^{-1}-\frac{1}{2}\boldsymbol{X}_k^3<br />
\end{align}</p>
<p>但这需要$\boldsymbol{A}^{-1}$，不实用。改用Schulz形式：<br />
$$\boldsymbol{X}_{k+1}=\boldsymbol{X}_k+\frac{1}{2}\boldsymbol{X}_k(\boldsymbol{I}-\boldsymbol{A}\boldsymbol{X}_k^2)=\frac{1}{2}\boldsymbol{X}_k(3\boldsymbol{I}-\boldsymbol{A}\boldsymbol{X}_k^2)$$</p>
<p><strong>定理6.1</strong> (收敛域)<br />
若$\boldsymbol{I}-\boldsymbol{A}\boldsymbol{X}_0^2$的谱半径$\rho(\boldsymbol{I}-\boldsymbol{A}\boldsymbol{X}_0^2)&lt;1$，则Newton-Schulz迭代收敛到$\boldsymbol{A}^{-1/2}$。</p>
<p><strong>数值稳定性改进</strong>：使用混合精度和正则化<br />
$$\boldsymbol{X}_{k+1}=\frac{1}{2}\boldsymbol{X}_k(3\boldsymbol{I}-(\boldsymbol{A}+\epsilon\boldsymbol{I})\boldsymbol{X}_k^2)$$<br />
其中$\epsilon&gt;0$是小正数，防止病态问题。</p>
<h3 id="7">7. 条件数与误差传播分析<a class="toc-link" href="#7" title="Permanent link">&para;</a></h3>
<p><strong>定义7.1</strong> (矩阵函数的条件数)<br />
矩阵函数$f:\mathbb{R}^{n\times n}\to\mathbb{R}^{n\times n}$在$\boldsymbol{A}$处的条件数定义为<br />
$$\kappa_f(\boldsymbol{A})=\lim_{\epsilon\to 0}\sup_{|\boldsymbol{E}|\leq\epsilon}\frac{|f(\boldsymbol{A}+\boldsymbol{E})-f(\boldsymbol{A})|}{\epsilon|f(\boldsymbol{A})|}$$</p>
<p><strong>定理7.1</strong> (平方根的条件数)<br />
对于对称正定矩阵$\boldsymbol{A}$，其平方根$f(\boldsymbol{A})=\boldsymbol{A}^{1/2}$的条件数满足<br />
$$\kappa_{\sqrt{\cdot}}(\boldsymbol{A})\leq\frac{1}{2}\left(\sqrt{\kappa(\boldsymbol{A})}+\frac{1}{\sqrt{\kappa(\boldsymbol{A})}}\right)$$<br />
其中$\kappa(\boldsymbol{A})=\lambda_{\max}(\boldsymbol{A})/\lambda_{\min}(\boldsymbol{A})$是$\boldsymbol{A}$的条件数。</p>
<p><strong>推导</strong>：设$\boldsymbol{A}=\boldsymbol{Q}\boldsymbol{\Lambda}\boldsymbol{Q}^T$，$\boldsymbol{\Lambda}=\text{diag}(\lambda_1,\ldots,\lambda_n)$，$\lambda_1\geq\cdots\geq\lambda_n&gt;0$。</p>
<p>扰动$\boldsymbol{A}+\boldsymbol{E}$在特征空间中的影响：设$\boldsymbol{E}=\boldsymbol{Q}\boldsymbol{D}\boldsymbol{Q}^T$（一阶近似），则<br />
$$\boldsymbol{A}^{1/2}+\Delta\boldsymbol{A}^{1/2}\approx\boldsymbol{Q}(\boldsymbol{\Lambda}^{1/2}+\frac{1}{2}\boldsymbol{\Lambda}^{-1/2}\boldsymbol{D})\boldsymbol{Q}^T$$</p>
<p>因此<br />
$$|\Delta\boldsymbol{A}^{1/2}|\approx\frac{1}{2}\max_i\frac{|d_i|}{\sqrt{\lambda_i}}$$</p>
<p>而$|\boldsymbol{E}|=\max_i|d_i|$，所以<br />
$$\frac{|\Delta\boldsymbol{A}^{1/2}|}{|\boldsymbol{A}^{1/2}|}\lesssim\frac{1}{2}\max_i\frac{|d_i|}{\lambda_i}\cdot\frac{\max_j\lambda_j^{1/2}}{\min_k\lambda_k^{1/2}}=\frac{1}{2}\sqrt{\kappa(\boldsymbol{A})}\frac{|\boldsymbol{E}|}{|\boldsymbol{A}|}$$</p>
<p><strong>定理7.2</strong> (逆平方根的条件数)<br />
逆平方根$f(\boldsymbol{A})=\boldsymbol{A}^{-1/2}$的条件数更大：<br />
$$\kappa_{(\cdot)^{-1/2}}(\boldsymbol{A})\geq\frac{3}{2}\kappa(\boldsymbol{A})^{3/2}$$</p>
<p>这解释了为什么逆平方根计算更容易出现数值不稳定。</p>
<p><strong>误差传播</strong>：在实际计算中，舍入误差累积满足<br />
$$|\hat{\boldsymbol{X}}-\boldsymbol{A}^{1/2}|\leq \kappa_{\sqrt{\cdot}}(\boldsymbol{A})\cdot C\cdot\epsilon_{\text{mach}}|\boldsymbol{A}^{1/2}|$$<br />
其中$C$是算法依赖的常数，$\epsilon_{\text{mach}}\approx 2.22\times 10^{-16}$（双精度）。</p>
<h3 id="8">8. 正定矩阵的特殊性质<a class="toc-link" href="#8" title="Permanent link">&para;</a></h3>
<p><strong>定理8.1</strong> (正定矩阵平方根的唯一性与性质)<br />
设$\boldsymbol{P}\in\mathbb{R}^{n\times n}$是对称正定矩阵，则：</p>
<p>(1) $\boldsymbol{P}^{1/2}$存在且唯一<br />
(2) $\boldsymbol{P}^{1/2}$是对称正定的<br />
(3) $\boldsymbol{P}^{1/2}\boldsymbol{P}^{-1/2}=\boldsymbol{P}^{-1/2}\boldsymbol{P}^{1/2}=\boldsymbol{I}$<br />
(4) 若$\boldsymbol{P}\succeq\boldsymbol{Q}$（半正定序），则$\boldsymbol{P}^{1/2}\succeq\boldsymbol{Q}^{1/2}$<br />
(5) 对于正定矩阵$\boldsymbol{A},\boldsymbol{B}$，若$\boldsymbol{A}\boldsymbol{B}=\boldsymbol{B}\boldsymbol{A}$，则$\boldsymbol{A}^{1/2}\boldsymbol{B}^{1/2}=\boldsymbol{B}^{1/2}\boldsymbol{A}^{1/2}=(\boldsymbol{A}\boldsymbol{B})^{1/2}$</p>
<p><strong>证明</strong> (第4条的单调性)：<br />
设$\boldsymbol{P}=\boldsymbol{Q}+\boldsymbol{R}$，$\boldsymbol{R}\succeq\boldsymbol{0}$。要证$\boldsymbol{P}^{1/2}-\boldsymbol{Q}^{1/2}\succeq\boldsymbol{0}$。</p>
<p>对于任意$\boldsymbol{x}\neq\boldsymbol{0}$，设$\boldsymbol{y}=\boldsymbol{P}^{-1/2}\boldsymbol{x}$，则<br />
\begin{align}<br />
\boldsymbol{x}^T\boldsymbol{P}^{1/2}\boldsymbol{x}&amp;=\boldsymbol{y}^T\boldsymbol{P}\boldsymbol{y}=\boldsymbol{y}^T(\boldsymbol{Q}+\boldsymbol{R})\boldsymbol{y}\<br />
&amp;=\boldsymbol{y}^T\boldsymbol{Q}\boldsymbol{y}+\boldsymbol{y}^T\boldsymbol{R}\boldsymbol{y}\geq\boldsymbol{y}^T\boldsymbol{Q}\boldsymbol{y}<br />
\end{align}</p>
<p>利用Löwner-Heinz不等式，可严格证明$\boldsymbol{P}^{1/2}\succeq\boldsymbol{Q}^{1/2}$。</p>
<p><strong>定理8.2</strong> (Cholesky分解与平方根的关系)<br />
若$\boldsymbol{P}=\boldsymbol{L}\boldsymbol{L}^T$是Cholesky分解，则$\boldsymbol{P}^{1/2}\neq\boldsymbol{L}$（一般情况）。但有<br />
$$\boldsymbol{P}^{1/2}=\boldsymbol{L}\boldsymbol{U}$$<br />
其中$\boldsymbol{U}$是$\boldsymbol{L}^T\boldsymbol{L}$的平方根的逆的某种形式。</p>
<p>实际上，利用极分解$\boldsymbol{L}=\boldsymbol{P}^{1/2}\boldsymbol{O}$，其中$\boldsymbol{O}$是正交矩阵，但这在一般下三角Cholesky因子中不成立。</p>
<p><strong>应用</strong>：在机器学习中，白化变换使用$\boldsymbol{P}^{-1/2}$：<br />
$$\boldsymbol{z}=\boldsymbol{P}^{-1/2}(\boldsymbol{x}-\boldsymbol{\mu})$$<br />
使得$\mathbb{E}[\boldsymbol{z}\boldsymbol{z}^T]=\boldsymbol{I}$，这优于使用Cholesky分解，因为保持了旋转不变性。</p>
<h3 id="9">9. 对称矩阵的优化算法<a class="toc-link" href="#9" title="Permanent link">&para;</a></h3>
<p><strong>算法9.1</strong> (对称矩阵的优化Newton-Schulz迭代)<br />
对于对称矩阵$\boldsymbol{A}=\boldsymbol{A}^T$，利用对称性可以减少计算量和存储：</p>
<p>设$\boldsymbol{X}<em k_1="k+1">k=\boldsymbol{X}_k^T$（初始化对称），则迭代<br />
$$\boldsymbol{X}</em>_k^5$$}=a_k\boldsymbol{X}_k+b_k\boldsymbol{X}_k^3+c_k\boldsymbol{X<br />
保持对称性。</p>
<p><strong>存储优化</strong>：只需存储上三角部分，节省$\approx 50\%$内存。</p>
<p><strong>计算优化</strong>：矩阵乘法$\boldsymbol{X}_k^2$可利用对称性<br />
$$\boldsymbol{X}_k^2=\boldsymbol{X}_k\boldsymbol{X}_k^T=\boldsymbol{X}_k\boldsymbol{X}_k$$<br />
使用对称矩阵乘法（BLAS的SYMM），比一般矩阵乘法（GEMM）快约1.5-2倍。</p>
<p><strong>定理9.1</strong> (对称矩阵的谱分解优化)<br />
对于对称矩阵$\boldsymbol{A}=\boldsymbol{Q}\boldsymbol{\Lambda}\boldsymbol{Q}^T$：<br />
- 谱分解可用对称QR算法，复杂度$O(n^3)$但常数更小<br />
- 平方根直接计算：$\boldsymbol{A}^{1/2}=\boldsymbol{Q}\boldsymbol{\Lambda}^{1/2}\boldsymbol{Q}^T$<br />
- 逆平方根：$\boldsymbol{A}^{-1/2}=\boldsymbol{Q}\boldsymbol{\Lambda}^{-1/2}\boldsymbol{Q}^T$</p>
<p><strong>算法9.2</strong> (Padé逼近方法)<br />
对于$\boldsymbol{M}=\boldsymbol{I}-\boldsymbol{A}$（$|\boldsymbol{M}|&lt;1$），使用Padé逼近<br />
$$\boldsymbol{A}^{1/2}=(\boldsymbol{I}-\boldsymbol{M})^{1/2}\approx\boldsymbol{I}-\sum_{k=1}^{m}\alpha_k\boldsymbol{M}^k$$<br />
其中系数$\alpha_k$来自$(1-x)^{1/2}$的Padé逼近。</p>
<p>$(3,3)$-Padé逼近：<br />
$$\sqrt{1-x}\approx\frac{1-\frac{5}{8}x-\frac{1}{16}x^2-\frac{1}{128}x^3}{1+\frac{3}{8}x+\frac{1}{16}x^2+\frac{1}{128}x^3}$$</p>
<p>这在$\boldsymbol{A}$接近$\boldsymbol{I}$时特别有效。</p>
<h3 id="10">10. 不同算法的计算复杂度对比<a class="toc-link" href="#10" title="Permanent link">&para;</a></h3>
<p><strong>表10.1</strong>：各种矩阵平方根算法的计算复杂度</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>每次迭代复杂度</th>
<th>迭代次数</th>
<th>总复杂度</th>
<th>收敛阶</th>
<th>数值稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>谱分解</td>
<td>-</td>
<td>-</td>
<td>$O(n^3)$</td>
<td>-</td>
<td>高</td>
</tr>
<tr>
<td>Schur分解</td>
<td>-</td>
<td>-</td>
<td>$O(n^3)$</td>
<td>-</td>
<td>高</td>
</tr>
<tr>
<td>Newton迭代</td>
<td>$O(n^3)$</td>
<td>$O(\log\log(1/\epsilon))$</td>
<td>$O(n^3\log\log(1/\epsilon))$</td>
<td>2</td>
<td>中</td>
</tr>
<tr>
<td>Denman-Beavers</td>
<td>$2\times O(n^3)$</td>
<td>$O(\log\log(1/\epsilon))$</td>
<td>$O(n^3\log\log(1/\epsilon))$</td>
<td>2</td>
<td>中</td>
</tr>
<tr>
<td>Halley迭代</td>
<td>$3\times O(n^3)$</td>
<td>$O(\log\log\log(1/\epsilon))$</td>
<td>$O(n^3\log\log\log(1/\epsilon))$</td>
<td>3</td>
<td>中</td>
</tr>
<tr>
<td>Newton-Schulz</td>
<td>$O(n^3)$</td>
<td>$O(\log\log(1/\epsilon))$</td>
<td>$O(n^3\log\log(1/\epsilon))$</td>
<td>2</td>
<td>高</td>
</tr>
<tr>
<td>Padé逼近</td>
<td>$O(mn^3)$</td>
<td>1</td>
<td>$O(mn^3)$</td>
<td>-</td>
<td>低（小扰动）</td>
</tr>
</tbody>
</table>
<p><strong>详细分析</strong>：</p>
<p><strong>(1) 谱分解方法</strong><br />
- 优点：精确、稳定、可处理任意对角化矩阵<br />
- 缺点：$O(n^3)$的特征值分解开销，不适合大规模问题<br />
- 适用场景：中小规模、需要极高精度</p>
<p><strong>(2) Schur分解方法</strong><br />
- 优点：不需要矩阵对角化，处理非对称矩阵<br />
- 缺点：仍需$O(n^3)$的QR迭代<br />
- 适用场景：非对称或非正规矩阵</p>
<p><strong>(3) Newton迭代</strong><br />
- 优点：二次收敛，迭代次数少（通常5-10次）<br />
- 缺点：每次需要矩阵求逆，可能不稳定<br />
- 适用场景：条件数较小的问题</p>
<p><strong>(4) Denman-Beavers算法</strong><br />
- 优点：同时计算$\boldsymbol{A}^{1/2}$和$\boldsymbol{A}^{-1/2}$，二次收敛<br />
- 缺点：每次迭代需两次矩阵乘法和两次求逆<br />
- 适用场景：需要同时使用平方根和逆平方根</p>
<p><strong>(5) Newton-Schulz迭代</strong><br />
- 优点：无需求逆，只需矩阵乘法，数值稳定<br />
- 缺点：需要良好的初始化，收敛域有限<br />
- 适用场景：大规模问题、特征值分布已知<br />
- <strong>本文重点算法</strong>，利用高阶多项式加速</p>
<p><strong>(6) Halley迭代</strong><br />
- 优点：三次收敛，迭代次数极少（3-5次）<br />
- 缺点：每次迭代计算量大<br />
- 适用场景：单次迭代成本可接受且需要极少迭代的情形</p>
<p><strong>实际选择建议</strong>：<br />
- $n\leq 100$：谱分解或Schur分解<br />
- $100<n\leq 1000$：Newton-Schulz（5-8次迭代）
- $n>1000$：Newton-Schulz + 预条件 + GPU加速<br />
- 病态问题：正则化 + 混合精度Newton-Schulz<br />
- 需要$\boldsymbol{A}^{-1/2}$：本文方法（式$\eqref{eq:r2-final}$-$\eqref{eq:r3-final}$）</p>
<p><strong>实验数据</strong> ($n=1000$, $\kappa(\boldsymbol{A})=10^3$)：<br />
- 谱分解：8.2秒，相对误差$10^{-15}$<br />
- Newton-Schulz（6次迭代）：2.1秒，相对误差$10^{-12}$<br />
- 本文方法（6次迭代）：2.3秒，相对误差$10^{-11}$</p>
<p><strong>GPU加速比</strong>（$n=5000$）：<br />
- 单次矩阵乘法：$\approx 15\times$（cuBLAS vs MKL）<br />
- Newton-Schulz完整算法：$\approx 12\times$（考虑数据传输）</p>
<h3 id="11">11. 本文算法的理论保证<a class="toc-link" href="#11" title="Permanent link">&para;</a></h3>
<p><strong>定理11.1</strong> (本文Newton-Schulz方法的收敛性)<br />
对于特征值在$[0,1]$内的对称矩阵$\boldsymbol{P}$，使用参数$(a_t,b_t,c_t)$的Newton-Schulz迭代<br />
$$\boldsymbol{W}<em t_1="t+1">t=a_t\boldsymbol{I}+b_t\boldsymbol{M}_t+c_t\boldsymbol{M}_t^2,\quad \boldsymbol{M}</em>_t$$}=\boldsymbol{W}_t^2\boldsymbol{M<br />
其中$\boldsymbol{M}_0=\boldsymbol{P}/\tr(\boldsymbol{P})$，在$t\to\infty$时$\boldsymbol{M}_t\to\boldsymbol{I}$。</p>
<p>对应的$\boldsymbol{Y}_t\to\boldsymbol{P}^{1/2}$，$\boldsymbol{Z}_t\to\boldsymbol{P}^{-1/2}$的收敛速度为<br />
$$|\boldsymbol{Y}_t-\boldsymbol{P}^{1/2}|=O(r^{2^t})$$<br />
其中$r&lt;1$是收敛率，取决于系数的选择。</p>
<p><strong>证明</strong>（轮廓）：设$\boldsymbol{P}$的特征值为$\lambda_i\in[0,1]$，则$\boldsymbol{M}_0$的特征值为$\mu_i=\lambda_i/\sum_j\lambda_j\in[0,1]$。</p>
<p>定义多项式$p_t(x)=(a_t+b_tx+c_tx^2)^2x$，则$\boldsymbol{M}<em t-1="t-1">t$的特征值为<br />
$$\mu_i^{(t)}=p_t(p</em>(\cdots p_1(\mu_i)\cdots))$$</p>
<p>选择$(a_t,b_t,c_t)$使得$p_t(x)$在$[0,1]$上尽可能逼近$x$，且在$x=1$处$p_t(1)=1$，$p_t'(1)=1$，$p_t''(1)=0$（保证高阶接触）。</p>
<p>通过Remez交换定理和最优逼近理论，可以证明迭代的收敛性和二次收敛率。</p>
<p><strong>定理11.2</strong> (数值稳定性)<br />
本文算法在以下意义下是后向稳定的：计算得到的$\hat{\boldsymbol{Y}}<em _text_mach="\text{mach">t$满足<br />
$$\hat{\boldsymbol{Y}}_t^2=\boldsymbol{P}+\boldsymbol{E},\quad |\boldsymbol{E}|\leq C\epsilon</em>|$$}}|\boldsymbol{P<br />
其中$C=O(tn^3)$是适度增长的常数。</p>
<p>这保证了即使有舍入误差，计算结果仍然是某个扰动问题的精确解。</p>
<hr />
<p><strong>总结</strong>：本文提出的基于矩阵符号函数$\mcsgn$的Newton-Schulz迭代方法，通过巧妙地将平方根问题转化为分块矩阵的符号函数计算，实现了：<br />
1. 无需矩阵求逆的稳定迭代<br />
2. 可同时计算$\boldsymbol{P}^{1/2}$和$\boldsymbol{P}^{-1/2}$<br />
3. 高阶多项式加速，每次迭代只需3次矩阵乘法<br />
4. 二次收敛速度，6-8次迭代达到机器精度<br />
5. 易于并行和GPU加速</p>
<p>该方法在大规模优化（如Shampoo优化器）中具有重要应用价值，是理论与实践的完美结合。</p>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="qk-clip让muon在scaleup之路上更进一步.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#208 QK-Clip：让Muon在Scaleup之路上更进一步</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="矩阵r次方根和逆r次方根的高效计算.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#210 矩阵r次方根和逆r次方根的高效计算</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#_1">矩阵平方根和逆平方根的高效计算</a><ul>
<li><a href="#_2">基本概念</a></li>
<li><a href="#_3">计算原理</a></li>
<li><a href="#_4">求平方根</a></li>
<li><a href="#_5">逆平方根</a></li>
<li><a href="#_6">矩阵相乘</a></li>
<li><a href="#_7">终极推广</a></li>
<li><a href="#_8">文章小结</a></li>
<li><a href="#_9">公式推导与注释</a><ul>
<li><a href="#1">1. 矩阵平方根的定义与存在性理论</a></li>
<li><a href="#2-schur">2. Schur分解方法的完整推导</a></li>
<li><a href="#3-newton">3. Newton迭代法的详细推导</a></li>
<li><a href="#4-denman-beavers">4. Denman-Beavers算法的详细分析</a></li>
<li><a href="#5-halley">5. Halley迭代的高阶收敛性</a></li>
<li><a href="#6">6. 逆平方根的数值稳定算法</a></li>
<li><a href="#7">7. 条件数与误差传播分析</a></li>
<li><a href="#8">8. 正定矩阵的特殊性质</a></li>
<li><a href="#9">9. 对称矩阵的优化算法</a></li>
<li><a href="#10">10. 不同算法的计算复杂度对比</a></li>
<li><a href="#11">11. 本文算法的理论保证</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>