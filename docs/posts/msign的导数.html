<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>msign的导数 | ML & Math Blog Posts</title>
    <meta name="description" content="msign的导数
原文链接: https://spaces.ac.cn/archives/11025
发布日期: 

这篇文章我们来推导$\newcommand{msign}{\mathop{\text{msign}}}\msign$算子的求导公式。如果读者想要像《Test-Time Training Done Right》一样，将TTT和Muon结合起来，那么本文可能会对你有帮助。
两种定义
本...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- MathJax for math rendering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">msign的导数</h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> </span>
                
                <span class="ms-3">
                    <i class="fas fa-link"></i>
                    <a href="https://spaces.ac.cn/archives/11025" target="_blank">原文链接</a>
                </span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <span class="tag"><i class="fas fa-tag"></i> 微积分</span>
                <span class="tag"><i class="fas fa-tag"></i> 矩阵</span>
                <span class="tag"><i class="fas fa-tag"></i> 梯度</span>
                <span class="tag"><i class="fas fa-tag"></i> muon</span>
                <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                
            </div>
            
        </header>

        <!-- Post Body -->
        <div class="post-content">
            <h1 id="msign">msign的导数</h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/11025">https://spaces.ac.cn/archives/11025</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>这篇文章我们来推导$\newcommand{msign}{\mathop{\text{msign}}}\msign$算子的求导公式。如果读者想要像<a href="https://papers.cool/arxiv/2505.23884">《Test-Time Training Done Right》</a>一样，将<a href="https://papers.cool/arxiv/2407.04620">TTT</a>和<a href="/archives/10592">Muon</a>结合起来，那么本文可能会对你有帮助。</p>
<h2 id="_1">两种定义</h2>
<p>本文依然假设大家已经对$\msign$有所了解，如果还没有，可以先移步阅读<a href="/archives/10592">《Muon优化器赏析：从向量到矩阵的本质跨越》</a>和<a href="/archives/10922">《msign算子的Newton-Schulz迭代（上）》</a>。现设有矩阵$\boldsymbol{M}\in\mathbb{R}^{n\times m}$，那么<br />
\begin{equation}\boldsymbol{U},\boldsymbol{\Sigma},\boldsymbol{V}^{\top} = \text{SVD}(\boldsymbol{M}) \quad\Rightarrow\quad \msign(\boldsymbol{M}) = \boldsymbol{U}<em _:_:r_="[:,:r]">{[:,:r]}\boldsymbol{V}</em>}^{\top}\end{equation<br />
其中$\boldsymbol{U}\in\mathbb{R}^{n\times n},\boldsymbol{\Sigma}\in\mathbb{R}^{n\times m},\boldsymbol{V}\in\mathbb{R}^{m\times m}$，$r$是$\boldsymbol{M}$的秩。简单来说，$\msign$就是把矩阵的所有非零奇异值都变成1后所得的新矩阵。基于SVD，我们还可以证明<br />
\begin{equation}\msign(\boldsymbol{M}) = (\boldsymbol{M}\boldsymbol{M}^{\top})^{-1/2}\boldsymbol{M}= \boldsymbol{M}(\boldsymbol{M}^{\top}\boldsymbol{M})^{-1/2}\end{equation}<br />
这里的$^{-1/2}$的矩阵的$1/2$次幂的逆，由于$\boldsymbol{M}\boldsymbol{M}^{\top}$和$\boldsymbol{M}^{\top}\boldsymbol{M}$是（半）正定对称的，所以$1/2$次幂总是可求，但逆未必，不可逆的时候我们可以用“<a href="/archives/10366">伪逆</a>”。$\msign$这个名字，源于上式与实数符号函数$\newcommand{sign}{\mathop{\text{sign}}}\sign(x) = x/\sqrt{x^2}$的相似性。然而，我们之前也提到过，符号函数还有<a href="https://en.wikipedia.org/wiki/Matrix_sign_function">另一个矩阵版</a>，这里称为$\newcommand{mcsgn}{\mathop{\text{mcsgn}}}\newcommand{csgn}{\mathop{\text{csgn}}}\mcsgn$：<br />
\begin{equation}\mcsgn(\boldsymbol{M}) = \boldsymbol{M}(\boldsymbol{M}^2)^{-1/2}\end{equation}<br />
即$\msign$的$\boldsymbol{M}^{\top}\boldsymbol{M}$换成了$\boldsymbol{M}^2$。由于只有方阵才能算平方，所以这种定义只适用于方阵。在一篇文章内引入两种相似但不同的定义是容易引起混淆的，但很不幸，后面的计算中两种定义都需要用到，所以不得不同时出现。</p>
<p>$\mcsgn$具备相似不变性，如果$\boldsymbol{M}=\boldsymbol{P}\boldsymbol{\Lambda}\boldsymbol{P}^{-1}$，那么$\mcsgn(\boldsymbol{M})=\boldsymbol{P}\mcsgn(\boldsymbol{\Lambda})\boldsymbol{P}^{-1}$。进一步地，如果$\boldsymbol{\Lambda}$是对角阵（在复数域内几乎总是可以做到），那么有<br />
\begin{equation}\mcsgn(\boldsymbol{M}) = \boldsymbol{P}\csgn(\boldsymbol{\Lambda})\boldsymbol{P}^{-1}\end{equation}<br />
$\csgn(\boldsymbol{\Lambda})$表示对角线的元素都取$\csgn$，其中$\csgn(z) = z/\sqrt{z^2}$是符号函数的复数版，如果$z$的实部非零那么它等于$\sign(\mathop{\text{Re}}[z])$。这样看来，$\msign$和$\mcsgn$的区别在于，前者是在奇异值分解基础上对奇异值取符号函数，后者是在特征值分解基础上对特征值取符号函数。当$\boldsymbol{M}$是对称矩阵时，它们是相等的。</p>
<h2 id="_2">同一计算</h2>
<p>目前而言，$\msign$的数值计算主要靠如下格式的“Newton-Schulz迭代”：<br />
\begin{equation}\boldsymbol{X}<em t_1="t+1">0 = \frac{\boldsymbol{M}}{\Vert\boldsymbol{M}\Vert_F},\qquad \boldsymbol{X}</em>} = a_{t+1}\boldsymbol{X<em t_1="t+1">t + b</em>}\boldsymbol{X<em t_1="t+1">t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t) + c</em>}\boldsymbol{X}_t(\boldsymbol{X}_t^{\top}\boldsymbol{X}_t)^2\end{equation<br />
至于系数的选择，这我们在<a href="/archives/10922">《msign算子的Newton-Schulz迭代（上）》</a>和<a href="/archives/10996">《msign算子的Newton-Schulz迭代（下）》</a>已经详细探讨过了，其中出自下篇的比较新的结果是：<br />
$$\begin{array}{c|ccc}<br />
\hline<br />
t &amp; a\times 1.01 &amp; b\times 1.01^3 &amp; c\times 1.01^5 \\<br />
\hline<br />
\quad 1\quad &amp; 8.28721 &amp; -23.5959 &amp; 17.3004 \\<br />
2 &amp; 4.10706 &amp; -2.94785 &amp; 0.544843 \\<br />
3 &amp; 3.94869 &amp; -2.9089 &amp; 0.551819 \\<br />
4 &amp; 3.31842 &amp; -2.48849 &amp; 0.510049 \\<br />
5 &amp; 2.30065 &amp; -1.6689 &amp; 0.418807 \\<br />
6 &amp; 1.8913 &amp; 1.268 &amp; 0.376804 \\<br />
7 &amp; 1.875 &amp; -1.25 &amp; 0.375 \\<br />
8 &amp; 1.875 &amp; -1.25 &amp; 0.375 \\<br />
\hline<br />
\end{array}$$<br />
这个结果的好处是可以任意截断和叠加，比如只保留前5行它就是最佳的5步迭代，保留前6行就是最佳6步迭代，并且近似程度是有保证地优于5步迭代，依此类推。</p>
<p>至于$\mcsgn$，它只是把$\msign$的$\boldsymbol{M}^{\top}\boldsymbol{M}$换成了$\boldsymbol{M}^2$，所以理论上也可以用Newton-Schulz迭代，但由于特征值可以是复数，因此一般的收敛会困难得多。不过，如果我们可以实现确认矩阵$\boldsymbol{M}$的特征值都是实数（比如本文后面要应用$\mcsgn$的分块三角矩阵），那么就可以复用$\msign$的迭代和系数：<br />
\begin{equation}\newcommand{tr}{\mathop{\text{tr}}}\boldsymbol{X}<em t_1="t+1">0 = \frac{\boldsymbol{M}}{\sqrt{\tr(\boldsymbol{M}^2)}},\qquad \boldsymbol{X}</em>} = a_{t+1}\boldsymbol{X<em t_1="t+1">t + b</em>}\boldsymbol{X<em t_1="t+1">t^3 + c</em>}\boldsymbol{X}_t^5\end{equation</p>
<h2 id="_3">推导过程</h2>
<p>下面正式进入主题——求$\boldsymbol{O}=\msign(\boldsymbol{M})$的导数。如果读者只是将Muon当成一个普通优化器用，那么本文多半跟你无关了。当我们需要参考TTT，用Muon优化器来构建RNN模型时，才需要$\msign$的导数，此时$\msign$在模型表现为前向传播，而要对整个模型反向传播，自然就涉及到了$\msign$的导数。</p>
<p>由于$\msign$是通过Newton-Schulz迭代计算的，实际上它可以直接反向传播，所以$\msign$的数值求导本身不是问题，但基于迭代反传意味着有很多中间状态要存，显存往往要爆炸，所以希望能得到导数的解析解来简化。另一方面，在<a href="/archives/10878">《SVD的导数》</a>中我们其实也求过$\msign$的导数，但那是基于SVD的表达式，而SVD并不是GPU高效的算法。</p>
<p>所以，我们的目的是寻求一个不依赖于SVD的、能够高效计算的结果。我们从恒等式<br />
\begin{equation}\boldsymbol{M} = \boldsymbol{O}\boldsymbol{M}^{\top}\boldsymbol{O}\end{equation}<br />
出发（由$\msign$的定义即可证明），两边微分得到<br />
\begin{equation}d\boldsymbol{M} = (d\boldsymbol{O})\boldsymbol{M}^{\top}\boldsymbol{O} + \boldsymbol{O}(d\boldsymbol{M}^{\top})\boldsymbol{O} + \boldsymbol{O}\boldsymbol{M}^{\top}(d\boldsymbol{O})\label{eq:dm-do}\end{equation}<br />
这个结果的难度在于无法简单地分离出$d\boldsymbol{M}=f(d\boldsymbol{O})$或$d\boldsymbol{O}=f(d\boldsymbol{M})$的形式，因此不大好看出$\nabla_{\boldsymbol{O}}\mathcal{L}$与$\nabla_{\boldsymbol{W}}\mathcal{L}$的关系（$\mathcal{L}$是损失函数）。这种情况下最好的办法是回归到矩阵求导的根本思路——“迹技巧”：</p>
<blockquote>
<p><strong>迹技巧（trace trick）</strong> 如果我们能找到跟$\boldsymbol{M}$同形状的矩阵$\boldsymbol{G}$满足 \begin{equation}d\mathcal{L}=\langle \boldsymbol{G}, d\boldsymbol{M}\rangle_F = \tr(\boldsymbol{G}^{\top} (d\boldsymbol{M}))\end{equation} 那么$\boldsymbol{G} = \nabla_{\boldsymbol{M}}\mathcal{L}$。</p>
</blockquote>
<p>迹技巧的要义是化矩阵/向量为标量，然后化标量为迹，继而可以利用迹的恒等式：<br />
\begin{equation}\tr(\boldsymbol{A}\boldsymbol{B}) = \tr(\boldsymbol{B}\boldsymbol{A}) = \tr(\boldsymbol{A}^{\top}\boldsymbol{B}^{\top}) = \tr(\boldsymbol{B}^{\top}\boldsymbol{A}^{\top})\end{equation}<br />
现在设$\boldsymbol{X}$是任意跟$\boldsymbol{M}$同形状矩阵，给式$\eqref{eq:dm-do}$两边乘$\boldsymbol{X}^{\top}$，然后求迹<br />
\begin{equation}\begin{aligned}<br />
\tr(\boldsymbol{X}^{\top}(d\boldsymbol{M})) =&amp;\, \tr(\boldsymbol{X}^{\top}(d\boldsymbol{O})\boldsymbol{M}^{\top}\boldsymbol{O}) + \tr(\boldsymbol{X}^{\top}\boldsymbol{O}(d\boldsymbol{M}^{\top})\boldsymbol{O}) + \tr(\boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top}(d\boldsymbol{O})) \\[7pt]<br />
=&amp;\, \tr(\boldsymbol{M}^{\top}\boldsymbol{O}\boldsymbol{X}^{\top}(d\boldsymbol{O})) + \tr(\boldsymbol{O}\boldsymbol{X}^{\top}\boldsymbol{O}(d\boldsymbol{M}^{\top})) + \tr(\boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top}(d\boldsymbol{O})) \\[7pt]<br />
=&amp;\, \tr(\boldsymbol{M}^{\top}\boldsymbol{O}\boldsymbol{X}^{\top}(d\boldsymbol{O})) + \tr(\boldsymbol{O}^{\top}\boldsymbol{X}\boldsymbol{O}^{\top}(d\boldsymbol{M})) + \tr(\boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top}(d\boldsymbol{O})) \\[7pt]<br />
\end{aligned}\end{equation}<br />
由此可得<br />
\begin{equation}\tr((\boldsymbol{X}^{\top} - \boldsymbol{O}^{\top}\boldsymbol{X}\boldsymbol{O}^{\top})(d\boldsymbol{M})) = \tr((\boldsymbol{M}^{\top}\boldsymbol{O}\boldsymbol{X}^{\top} + \boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top})(d\boldsymbol{O}))\end{equation}<br />
如果我们让$\boldsymbol{M}^{\top}\boldsymbol{O}\boldsymbol{X}^{\top} + \boldsymbol{X}^{\top}\boldsymbol{O}\boldsymbol{M}^{\top}=(\nabla_{\boldsymbol{O}}\mathcal{L})^{\top}$，那么上式便具有$d\mathcal{L}$的含义，那么根据迹技巧就有$\boldsymbol{X}^{\top} - \boldsymbol{O}^{\top}\boldsymbol{X}\boldsymbol{O}^{\top}=(\nabla_{\boldsymbol{M}}\mathcal{L})^{\top}$，这表明$\nabla_{\boldsymbol{M}}\mathcal{L}$和$\nabla_{\boldsymbol{O}}\mathcal{L}$的关系，由下述方程组描述<br />
\begin{gather}\boldsymbol{X} - \boldsymbol{O}\boldsymbol{X}^{\top}\boldsymbol{O} = \nabla_{\boldsymbol{M}}\mathcal{L} \label{eq:g-m}\\[7pt]<br />
\boldsymbol{X}\boldsymbol{O}^{\top}\boldsymbol{M} + \boldsymbol{M}\boldsymbol{O}^{\top}\boldsymbol{X} = \nabla_{\boldsymbol{O}}\mathcal{L}\label{eq:g-o}\end{gather}</p>
<h2 id="_4">理论形式</h2>
<p>所以，现在问题变成了，从式$\eqref{eq:g-o}$中解出$\boldsymbol{X}$，然后代入式$\eqref{eq:g-m}$得到$\nabla_{\boldsymbol{M}}\mathcal{L}$，即将$\nabla_{\boldsymbol{M}}\mathcal{L}$表示为$\nabla_{\boldsymbol{O}}\mathcal{L}$的函数，避免直接求$\nabla_{\boldsymbol{M}}\boldsymbol{O}$。很明显，唯一的难度就是方程$\eqref{eq:g-o}$的求解。</p>
<p>这一节我们先基于SVD求一个不那么实用的理论解，它可以帮助我们了解方程$\eqref{eq:g-o}$的性质，并且跟之前的结果对齐。设$\boldsymbol{X}=\boldsymbol{U}\boldsymbol{Y}\boldsymbol{V}^{\top}$，然后我们还有$\boldsymbol{O}^{\top}\boldsymbol{M} = (\boldsymbol{M}^{\top}\boldsymbol{M})^{1/2} = \boldsymbol{V}(\boldsymbol{\Sigma}^{\top}\boldsymbol{\Sigma})^{1/2}\boldsymbol{V}^{\top}$和$\boldsymbol{M}\boldsymbol{O}^{\top}=(\boldsymbol{M}\boldsymbol{M}^{\top})^{1/2} = \boldsymbol{U}(\boldsymbol{\Sigma}\boldsymbol{\Sigma}^{\top})^{1/2}\boldsymbol{U}^{\top}$，将这些等式代入方程$\eqref{eq:g-o}$得到<br />
\begin{equation}\boldsymbol{U}\boldsymbol{Y}(\boldsymbol{\Sigma}^{\top}\boldsymbol{\Sigma})^{1/2}\boldsymbol{V}^{\top} + \boldsymbol{U}(\boldsymbol{\Sigma}\boldsymbol{\Sigma}^{\top})^{1/2}\boldsymbol{Y}\boldsymbol{V}^{\top} = \nabla_{\boldsymbol{O}}\mathcal{L}\end{equation}<br />
即<br />
\begin{equation}\boldsymbol{Y}(\boldsymbol{\Sigma}^{\top}\boldsymbol{\Sigma})^{1/2} + (\boldsymbol{\Sigma}\boldsymbol{\Sigma}^{\top})^{1/2}\boldsymbol{Y} = \boldsymbol{U}^{\top}(\nabla_{\boldsymbol{O}}\mathcal{L})\boldsymbol{V}\label{eq:g-o-2}\end{equation}<br />
上式左端如果写成分量形式是$\boldsymbol{Y}<em i_j="i,j">{i,j}\sigma_j + \sigma_i \boldsymbol{Y}</em>} = (\sigma_i + \sigma_j)\boldsymbol{Y<em r_1="r+1">{i,j}$，其中$\sigma_1,\sigma_2,\cdots,\sigma_r$是$\boldsymbol{M}$的非零奇异值，而$0=\sigma</em>$是满秩方阵时，可以解得}=\sigma_{r+2}=\cdots$。很明显，如果当$\boldsymbol{M<br />
\begin{equation}\boldsymbol{Y} = (\boldsymbol{U}^{\top}(\nabla_{\boldsymbol{O}}\mathcal{L})\boldsymbol{V}) \oslash \boldsymbol{S}\end{equation}<br />
其中$\boldsymbol{S}_{i,j} = \sigma_i+\sigma_j$，$\oslash$是Hadamard除（逐位相除）。这时候我们将$\boldsymbol{X}=\boldsymbol{U}\boldsymbol{Y}\boldsymbol{V}^{\top}$代入式$\eqref{eq:g-m}$，就得到跟<a href="/archives/10878">《SVD的导数》</a>里边一致的结果。这个殊途同归也增强了我们的信心，看来至少到目前为止我们的推导都还是正确的。</p>
<p>若$\boldsymbol{M}$不满秩或不是方阵呢？此时如果右端的$\boldsymbol{U}^{\top}(\nabla_{\boldsymbol{O}}\mathcal{L})\boldsymbol{V}$“不配合”，那么方程$\eqref{eq:g-o-2}$无解。但方程$\eqref{eq:g-o-2}$是从实际问题得到的，所以它肯定有解，那么右端“必须配合”！怎样才是配合呢？如果$\boldsymbol{M}$的秩为$r$，那么矩阵$\boldsymbol{S}$只有$\boldsymbol{S}<em _boldsymbol_O="\boldsymbol{O">{[:r,:r]}$是非零的，为了使得方程$\eqref{eq:g-o-2}$有解，$(\boldsymbol{U}^{\top}(\nabla</em>)}}\mathcal{L})\boldsymbol{V<em 0="0" _epsilon_to="\epsilon\to">{[:r,:r]}$以外的部分只能是零。在这个条件下，我们可以写出<br />
\begin{equation}\boldsymbol{Y} = \lim</em>}\,\, (\boldsymbol{U}^{\top}(\nabla_{\boldsymbol{O}}\mathcal{L})\boldsymbol{V}) \oslash (\boldsymbol{S} + \epsilon) \end{equation<br />
这相当于说，我们可以给奇异值加些扰动，转化为全体奇异值非零的情况，计算完成后再让扰动趋于零，从而得到正确的结果。</p>
<h2 id="_5">高效求解</h2>
<p>上一节的SVD解往往只有理论价值，为了在GPU中高效计算，我们还需要寻求其他形式的解。引入记号$\boldsymbol{M}\boldsymbol{O}^{\top}=\boldsymbol{A},\boldsymbol{O}^{\top}\boldsymbol{M}=\boldsymbol{B},\nabla_{\boldsymbol{O}}\mathcal{L}=\boldsymbol{C}$，那么式$\eqref{eq:g-o}$实际上是一个<a href="https://en.wikipedia.org/wiki/Sylvester_equation">Sylvester方程</a>：<br />
\begin{equation}\boldsymbol{A}\boldsymbol{X}+\boldsymbol{X}\boldsymbol{B} = \boldsymbol{C}\end{equation}<br />
求解Sylvester方程的方法有很多，其中最精妙、对GPU最高效的，可能是基于$\mcsgn$（不是$\msign$）的求解方案（这里参考了<a href="https://papers.cool/arxiv/2201.08663">《Fast Differentiable Matrix Square Root》</a>）。首先，从上述方程出发，我们可以验证下式成立<br />
\begin{equation}\begin{bmatrix} \boldsymbol{A} &amp; -\boldsymbol{C} \\ \boldsymbol{0} &amp; -\boldsymbol{B}\end{bmatrix} = \begin{bmatrix} \boldsymbol{I} &amp; \boldsymbol{X} \\ \boldsymbol{0} &amp; \boldsymbol{I}\end{bmatrix}\begin{bmatrix} \boldsymbol{A} &amp; \boldsymbol{0} \\ \boldsymbol{0} &amp; -\boldsymbol{B}\end{bmatrix}\begin{bmatrix} \boldsymbol{I} &amp; \boldsymbol{X} \\ \boldsymbol{0} &amp; \boldsymbol{I}\end{bmatrix}^{-1}<br />
\end{equation}<br />
两边取$\mcsgn$，根据$\mcsgn$的性质，我们有<br />
\begin{equation}\mcsgn\left(\begin{bmatrix} \boldsymbol{A} &amp; -\boldsymbol{C} \\ \boldsymbol{0} &amp; -\boldsymbol{B}\end{bmatrix}\right) = \begin{bmatrix} \boldsymbol{I} &amp; \boldsymbol{X} \\ \boldsymbol{0} &amp; \boldsymbol{I}\end{bmatrix}\begin{bmatrix} \mcsgn(\boldsymbol{A}) &amp; \boldsymbol{0} \\ \boldsymbol{0} &amp; -\mcsgn(\boldsymbol{B})\end{bmatrix}\begin{bmatrix} \boldsymbol{I} &amp; \boldsymbol{X} \\ \boldsymbol{0} &amp; \boldsymbol{I}\end{bmatrix}^{-1}<br />
\end{equation}<br />
注意$\boldsymbol{A}=\boldsymbol{M}\boldsymbol{O}^{\top}=(\boldsymbol{M}\boldsymbol{M}^{\top})^{1/2}, \boldsymbol{B}=\boldsymbol{O}^{\top}\boldsymbol{M}=(\boldsymbol{M}^{\top}\boldsymbol{M})^{1/2}$，假设$\boldsymbol{M}$是满秩方阵，那么$\boldsymbol{A},\boldsymbol{B}$都是正定对称的，正定对称矩阵的$\mcsgn$都是方阵，所以<br />
\begin{equation}\mcsgn\left(\begin{bmatrix} \boldsymbol{A} &amp; -\boldsymbol{C} \\ \boldsymbol{0} &amp; -\boldsymbol{B}\end{bmatrix}\right) = \begin{bmatrix} \boldsymbol{I} &amp; \boldsymbol{X} \\ \boldsymbol{0} &amp; \boldsymbol{I}\end{bmatrix}\begin{bmatrix} \boldsymbol{I} &amp; \boldsymbol{0} \\ \boldsymbol{0} &amp; -\boldsymbol{I}\end{bmatrix}\begin{bmatrix} \boldsymbol{I} &amp; \boldsymbol{X} \\ \boldsymbol{0} &amp; \boldsymbol{I}\end{bmatrix}^{-1} = \begin{bmatrix} \boldsymbol{I} &amp; -2\boldsymbol{X} \\ \boldsymbol{0} &amp; -\boldsymbol{I}\end{bmatrix}<br />
\end{equation}<br />
最后的化简用到了等式$\begin{bmatrix} \boldsymbol{I} &amp; \boldsymbol{X} \\ \boldsymbol{0} &amp; \boldsymbol{I}\end{bmatrix}^{-1}=\begin{bmatrix} \boldsymbol{I} &amp; -\boldsymbol{X} \\ \boldsymbol{0} &amp; \boldsymbol{I}\end{bmatrix}$。从该结果可以看出，我们只需要对分块矩阵$\begin{bmatrix} \boldsymbol{A} &amp; -\boldsymbol{C} \\ \boldsymbol{0} &amp; -\boldsymbol{B}\end{bmatrix}$算$\mcsgn$，然后就可以从结果的右上角读出$\boldsymbol{X}$。$\mcsgn$可以通过Newton-Schulz迭代高效地计算，因此该方案是GPU友好的。</p>
<p>当$\boldsymbol{M}$不满秩或非方阵时，$\boldsymbol{A},\boldsymbol{B}$只是半正定的，这时候它们就$\mcsgn$就不是$\boldsymbol{I}$。不过，上一节的经验告诉我们，由于$\nabla_{\boldsymbol{O}}\mathcal{L}$“必须配合”，所以只需要给$\boldsymbol{\Sigma}$加点扰动，让它变成正定的情况即可解。这里给$\boldsymbol{\Sigma}$加扰动，相当于给$\boldsymbol{A},\boldsymbol{B}$加$\epsilon \boldsymbol{I}$，所以<br />
\begin{equation}\boldsymbol{X} = -\frac{1}{2} \left(\lim_{\epsilon\to 0}\,\, \mcsgn\left(\begin{bmatrix} \boldsymbol{A} + \epsilon \boldsymbol{I} &amp; -\boldsymbol{C} \\ \boldsymbol{0} &amp; -\boldsymbol{B} - \epsilon \boldsymbol{I}\end{bmatrix}\right)\right)_{[:n,n:]}<br />
\end{equation}<br />
实际计算时，就只能选择一个比较小的$\epsilon &gt; 0$来近似计算了，可以考虑$\epsilon=10^{-3}$，它在我们之前寻找Newton-Schulz迭代的下界范围内。</p>
<h2 id="_6">文章小结</h2>
<p>本文讨论了$\msign$算子的导数计算，如果你关心“TTT + Muon”的组合，那么本文也许对你有帮助。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/11025">https://spaces.ac.cn/archives/11025</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Jun. 13, 2025). 《msign的导数 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/11025">https://spaces.ac.cn/archives/11025</a></p>
<p>@online{kexuefm-11025,<br />
title={msign的导数},<br />
author={苏剑林},<br />
year={2025},<br />
month={Jun},<br />
url={\url{https://spaces.ac.cn/archives/11025}},<br />
} </p>
<hr />
<h2 id="_7">公式推导与注释</h2>
<p>TODO: 添加详细的数学公式推导和注释</p>
        </div>

        <!-- Back to Home -->
        <div class="text-center mt-5 mb-4">
            <a href="../index.html" class="btn btn-outline-primary">
                <i class="fas fa-arrow-left"></i> 返回首页
            </a>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>
</body>
</html>
