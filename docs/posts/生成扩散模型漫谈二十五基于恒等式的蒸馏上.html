<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上） | ML & Math Blog Posts</title>
    <meta name="description" content="生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上）&para;
原文链接: https://spaces.ac.cn/archives/10085
发布日期: 

今天我们分享一下论文《Score identity Distillation: Exponentially Fast Distillation of Pretrained Diffusion Models for One-Step Ge...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=生成模型">生成模型</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #196 生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上）
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#196</span>
                生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上）
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> </span>
                
                <span class="ms-3">
                    <i class="fas fa-link"></i>
                    <a href="https://spaces.ac.cn/archives/10085" target="_blank" rel="noopener">原文链接</a>
                </span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
                <a href="../index.html?tags=梯度" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 梯度</span>
                </a>
                
                <a href="../index.html?tags=扩散" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 扩散</span>
                </a>
                
                <a href="../index.html?tags=去噪" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 去噪</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="_1">生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上）<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/10085">https://spaces.ac.cn/archives/10085</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>今天我们分享一下论文<a href="https://papers.cool/arxiv/2404.04057">《Score identity Distillation: Exponentially Fast Distillation of Pretrained Diffusion Models for One-Step Generation》</a>，顾名思义，这是一篇探讨如何更快更好地蒸馏扩散模型的新论文。</p>
<p>即便没有做过蒸馏，大家应该也能猜到蒸馏的常规步骤：随机采样大量输入，然后用扩散模型生成相应结果作为输出，用这些输入输出作为训练数据对，来监督训练一个新模型。然而，众所周知作为教师的原始扩散模型通常需要多步（比如1000步）迭代才能生成高质量输出，所以且不论中间训练细节如何，该方案的一个显著缺点是生成训练数据太费时费力。此外，蒸馏之后的学生模型通常或多或少都有效果损失。</p>
<p>有没有方法能一次性解决这两个缺点呢？这就是上述论文试图要解决的问题。</p>
<h2 id="_2">重现江湖<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>论文将所提方案称为“Score identity Distillation（SiD）”，该名字取自它基于几个恒等式（Identity）来设计和推导了整个框架，取这个略显随意的名字大体是想突出恒等式变换在SiD中的关键作用，这确实是SiD的核心贡献。</p>
<p>至于SiD的训练思想，其实跟之前在<a href="/archives/7038">《从去噪自编码器到生成模型》</a>介绍过的论文<a href="https://papers.cool/arxiv/2001.02728">《Learning Generative Models using Denoising Density Estimators》</a>（简称“DDE”）几乎一模一样，甚至最终形式也有五六分相似。只不过当时扩散模型还未露头角，所以DDE是将其作为一种新的生成模型提出的，在当时反而显得非常小众。而在扩散模型流行的今天，它可以重新表述为一种扩散模型的蒸馏方法，因为它需要一个训练好的去噪自编码器——这正好是扩散模型的核心。</p>
<p>接下来笔者用自己的思路去介绍SiD。假设我们有一个在目标数据集训练好的教师扩散模型$\boldsymbol{\epsilon}_{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_theta="\boldsymbol{\theta">t,t)$，它需要多步采样才能生成高质量图片，我们的目标则是要训练一个单步采样的学生模型$\boldsymbol{x} = \boldsymbol{g}</em>^}}(\boldsymbol{z})$，也就是一个类似GAN的生成器，输入指定噪声$\boldsymbol{z}$就可以直接生成符合要求的图像。如果我们有很多的$(\boldsymbol{z},\boldsymbol{x})$对，那么直接监督训练就可以了（当然损失函数和其他细节还需要进一步确定，读者可以自行参考相关工作），但如果没有呢？肯定不是不能训，因为就算没有$\boldsymbol{\epsilon}_{\boldsymbol{\varphi</em>}(\boldsymbol{x}_t,t)$也能训，比如GAN，所以关键是怎么借助已经训练好的扩散模型提供更好的信号。</p>
<p>SiD及前作DDE使用了一个看上去很绕但是也很聪明的思路：</p>
<blockquote>
<p>如果$\boldsymbol{g}<em _boldsymbol_theta="\boldsymbol{\theta">{\boldsymbol{\theta}}(\boldsymbol{z})$产生的数据分布跟目标分布很相似，那么拿$\boldsymbol{g}</em>^}}(\boldsymbol{z})$生成的数据集去训练一个扩散模型$\boldsymbol{\epsilon}_{\boldsymbol{\psi<em>}(\boldsymbol{x}<em _boldsymbol_varphi="\boldsymbol{\varphi">t,t)$的话，它也应该跟$\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t,t)$很相似？</p>
</blockquote>
<h2 id="_3">初级形式<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>这个思路的聪明之处在于，它绕开了对教师模型生成样本的需求，也不需要训练教师模型的真实样本，因为“拿$\boldsymbol{g}<em _boldsymbol_theta="\boldsymbol{\theta">{\boldsymbol{\theta}}(\boldsymbol{z})$生成的数据集去训练一个扩散模型”只需要学生模型$\boldsymbol{g}</em>)$是一个单步模型，用它来生成数据时间上比较友好。}}(\boldsymbol{z})$生成的数据（简称“学生数据”），而$\boldsymbol{g}_{\boldsymbol{\theta}}(\boldsymbol{z</p>
<p>当然，这还只是思路，将其转换为实际可行的训练方案还有一段路要走。首先回顾一下扩散模型，我们采用<a href="/archives/9164">《生成扩散模型漫谈（三）：DDPM = 贝叶斯 + 去噪》</a>的形式，我们使用如下方式对输入$\boldsymbol{x}<em _boldsymbol_varphi="\boldsymbol{\varphi">0$进行加噪：<br />
\begin{equation}\boldsymbol{x}_t = \bar{\alpha}_t\boldsymbol{x}_0 + \bar{\beta}_t\boldsymbol{\varepsilon},\quad \boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})\end{equation}<br />
换言之$p(\boldsymbol{x}_t|\boldsymbol{x}_0)=\mathcal{N}(\boldsymbol{x}_t;\bar{\alpha}_t\boldsymbol{x}_0,\bar{\beta}_t^2 \boldsymbol{I})$。训练$\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}_t,t)$的方式则是去噪：<br />
\begin{equation}\boldsymbol{\varphi}^</em> = \mathop{\text{argmin}}<em _boldsymbol_x="\boldsymbol{x">{\boldsymbol{\varphi}} \mathbb{E}</em><em _boldsymbol_varphi="\boldsymbol{\varphi">0\sim \tilde{p}(\boldsymbol{x}_0),\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}</em>}}(\bar{\alpha<em _boldsymbol_theta="\boldsymbol{\theta">t\boldsymbol{x}_0 + \bar{\beta}_t\boldsymbol{\varepsilon},t) - \boldsymbol{\varepsilon}\Vert^2\right] \label{eq:d-real-data}\end{equation}<br />
这里的$\tilde{p}(\boldsymbol{x}_0)$就是教师模型的训练数据。同样地，如果我们想用$\boldsymbol{g}</em>)$的学生数据一个扩散模型，那么训练目标是}}(\boldsymbol{z<br />
\begin{equation}\begin{aligned}<br />
\boldsymbol{\psi}^<em> =&amp;\, \mathop{\text{argmin}}<em _boldsymbol_x="\boldsymbol{x">{\boldsymbol{\psi}} \mathbb{E}</em><em _boldsymbol_theta="\boldsymbol{\theta">0^{(g)}\sim p</em>}}(\boldsymbol{x<em _boldsymbol_psi="\boldsymbol{\psi">0^{(g)}),\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}</em>}}(\boldsymbol{x<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\varepsilon}\Vert^2\right] \\<br />
=&amp;\, \mathop{\text{argmin}}</em>}} \mathbb{E<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}</em>}}(\boldsymbol{x<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)},t) - \boldsymbol{\varepsilon}\Vert^2\right]<br />
\end{aligned}\label{eq:dloss}\end{equation}<br />
这里$\boldsymbol{x}_t^{(g)}=\bar{\alpha}_t\boldsymbol{x}_0^{(g)} + \bar{\beta}_t\boldsymbol{\varepsilon}=\bar{\alpha}_t\boldsymbol{g}</em>}}(\boldsymbol{z}) + \bar{\beta<em _boldsymbol_theta="\boldsymbol{\theta">t\boldsymbol{\varepsilon}$，是由学生数据加噪后的样本，学生数据的分布记为$p</em>$的期望。现在我们有两个扩散模型，它们之间的差异一定程度上衡量了教师模型和学生模型生成的数据分布差异，所以一个直观的想法是通过最小化它们之间的差异，来学习学生模型：}}(\boldsymbol{x}_0^{(g)})$；第二个等号用到了“$\boldsymbol{x}_0^{(g)}$直接由$\boldsymbol{z}$决定”的事实，所以对$\boldsymbol{x}_0^{(g)}$的期望等价于对$\boldsymbol{z<br />
\begin{equation}<br />
\boldsymbol{\theta}^</em> = \mathop{\text{argmin}}<em _boldsymbol_z="\boldsymbol{z">{\boldsymbol{\theta}} \underbrace{\mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon<em _mathcal_L="\mathcal{L">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t)\Vert^2\right]}</em>}_1}\label{eq:gloss-1}\end{equation<br />
注意式$\eqref{eq:dloss}$的优化依赖于$\boldsymbol{\theta}$，所以当$\boldsymbol{\theta}$通过式$\eqref{eq:gloss-1}$发生改变时，$\boldsymbol{\psi}^*$的值也随之改变，因此式$\eqref{eq:dloss}$和式$\eqref{eq:gloss-1}$实际上需要交替优化，类似GAN一样。</p>
<h2 id="_4">点睛之笔<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h2>
<p>谈到GAN，有读者可能会“闻之色变”，因为它是出了名的容易训崩。很遗憾，上述提出的式$\eqref{eq:dloss}$和式$\eqref{eq:gloss-1}$交替训练的方案同样有这个问题。首先它理论上是没有问题的，问题出现在理论与实践之间的gap，主要体现在两点：</p>
<blockquote>
<p>1、理论上要求先求出式$\eqref{eq:dloss}$的最优解，然后才去优化式$\eqref{eq:gloss-1}$，但实际上从训练成本考虑，我们并没有将它训练到最优就去优化式$\eqref{eq:gloss-1}$了；</p>
<p>2、理论上$\boldsymbol{\psi}^<em>$随$\boldsymbol{\theta}$而变，即应该写成$\boldsymbol{\psi}^</em>(\boldsymbol{\theta})$，从而在优化式$\eqref{eq:gloss-1}$时应该多出一项$\boldsymbol{\psi}^<em>(\boldsymbol{\theta})$对$\boldsymbol{\theta}$的梯度，但实际上在优化式$\eqref{eq:gloss-1}$时我们都只当$\boldsymbol{\psi}^</em>$是常数。</p>
</blockquote>
<p>这两个问题非常本质，它们也是GAN训练不稳定的根本原因，此前论文<a href="https://papers.cool/arxiv/2205.10146">《Revisiting GANs by Best-Response Constraint: Perspective, Methodology, and Application》</a>也特意从第2点出发改进了GAN的训练。看上去，这两个问题哪一个都无法解决，尤其是第1个，我们几乎不可能总是将$\boldsymbol{\psi}$求到最优，这在成本上是绝对无法接受的，至于第2个，在交替训练场景下我们也没什么好办法获得$\boldsymbol{\psi}^*(\boldsymbol{\theta})$的任何有效信息，从而更加不可能获得它关于$\boldsymbol{\theta}$的梯度。</p>
<p>幸运的是，对于上述扩散模型的蒸馏问题，SiD提出了一个有效缓解这两个问题的方案。SiD的想法可谓非常“朴素”：<strong>既然$\boldsymbol{\psi}^<em>$取近似值和$\boldsymbol{\psi}^</em>$当成常数都没法避免，那么唯一的办法就是通过恒等变换，尽量消除优化目标$\eqref{eq:gloss-1}$对$\boldsymbol{\psi}^*$的依赖了。</strong> 只要式$\eqref{eq:gloss-1}$对$\boldsymbol{\psi}^*$的依赖足够弱，那么上述两个问题带来的负面影响也能足够弱了。</p>
<p>这就是SiD的核心贡献，也是让人拍案叫绝的“点睛之笔”。</p>
<h2 id="_5">恒等变换<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h2>
<p>接下来我们具体来看做了什么恒等变换。我们先来看式$\eqref{eq:d-real-data}$，它的优化目标可以等价地改写成<br />
\begin{equation}\begin{aligned}<br />
&amp;\, \mathbb{E}<em _boldsymbol_varphi="\boldsymbol{\varphi">{\boldsymbol{x}_0\sim \tilde{p}(\boldsymbol{x}_0),\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}</em>}}(\bar{\alpha<em _boldsymbol_x="\boldsymbol{x">t\boldsymbol{x}_0 + \bar{\beta}_t\boldsymbol{\varepsilon},t) - \boldsymbol{\varepsilon}\Vert^2\right] \\<br />
=&amp;\, \mathbb{E}</em><em _boldsymbol_varphi="\boldsymbol{\varphi">0\sim \tilde{p}(\boldsymbol{x}_0),\boldsymbol{x}_t\sim p(\boldsymbol{x}_t|\boldsymbol{x}_0)}\left[\left\Vert\boldsymbol{\epsilon}</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t,t) - \frac{\boldsymbol{x}_t - \bar{\alpha}_t \boldsymbol{x}_0}{\bar{\beta}_t}\right\Vert^2\right] \\<br />
=&amp;\, \mathbb{E}</em><em _boldsymbol_varphi="\boldsymbol{\varphi">0\sim \tilde{p}(\boldsymbol{x}_0),\boldsymbol{x}_t\sim p(\boldsymbol{x}_t|\boldsymbol{x}_0)}\left[\left\Vert\boldsymbol{\epsilon}</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t,t) + \bar{\beta}_t\nabla</em><em _boldsymbol_varphi="\boldsymbol{\varphi">t}\log p(\boldsymbol{x}_t|\boldsymbol{x}_0)\right\Vert^2\right]<br />
\end{aligned}\end{equation}<br />
根据<a href="/archives/9209">《生成扩散模型漫谈（五）：一般框架之SDE篇》</a>的得分匹配相关结果，上述目标的最优解是$\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t,t)=-\bar{\beta}_t\nabla</em><em _boldsymbol_psi="\boldsymbol{\psi">t}\log p(\boldsymbol{x}_t)$，同理式$\eqref{eq:dloss}$的最优解是$\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t)=-\bar{\beta}_t\nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_z="\boldsymbol{z">t^{(g)})$。此时式$\eqref{eq:gloss-1}$的目标函数可以等价地改写成<br />
\begin{equation}\begin{aligned}<br />
&amp;\,\mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon<em _boldsymbol_z="\boldsymbol{z">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t)\Vert^2\right] \\[5pt]<br />
=&amp;\, \mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\langle\boldsymbol{\epsilon<em _boldsymbol_varphi="\boldsymbol{\varphi">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t), \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t) + \bar{\beta}_t\nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_z="\boldsymbol{z">t^{(g)})\right\rangle\right] \\[5pt]<br />
=&amp;\, \color{green}{\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\langle\boldsymbol{\epsilon}_{\boldsymbol{\varphi</em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_varphi="\boldsymbol{\varphi">t^{(g)},t), \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t)\right\rangle\right]} \\[5pt]<br />
&amp;\,\qquad+ \color{red}{\mathbb{E}</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}\sim p</em>}}(\boldsymbol{x<em _boldsymbol_varphi="\boldsymbol{\varphi">t^{(g)})}\left[\left\langle\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t), \bar{\beta}_t\nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t^{(g)})\right\rangle\right]}<br />
\end{aligned}\end{equation}<br />
接下来要用到在<a href="/archives/9509">《生成扩散模型漫谈（十八）：得分匹配 = 条件得分匹配》</a>证明过的一个恒等式，来化简上式的红色部分：<br />
\begin{equation}\nabla</em><em _boldsymbol_x="\boldsymbol{x">t}\log p(\boldsymbol{x}_t) = \mathbb{E}</em><em _boldsymbol_x="\boldsymbol{x">0\sim p(\boldsymbol{x}_0|\boldsymbol{x}_t)}\left[\nabla</em><em _boldsymbol_x="\boldsymbol{x">t} \log p(\boldsymbol{x}_t|\boldsymbol{x}_0)\right] \label{eq:id}\end{equation}<br />
这是由概率密度定义以及贝叶斯公式推出的恒等式，不依赖于$p(\boldsymbol{x}_t),p(\boldsymbol{x}_t|\boldsymbol{x}_0),p(\boldsymbol{x}_0|\boldsymbol{x}_t)$的形式。将该恒等式代入到红色部分，我们有<br />
\begin{equation}\color{red}{\begin{aligned}<br />
&amp;\,\mathbb{E}</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}\sim p</em>}}(\boldsymbol{x<em _boldsymbol_varphi="\boldsymbol{\varphi">t^{(g)})}\left[\left\langle\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t), \bar{\beta}_t\nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t^{(g)})\right\rangle\right] \\[5pt]<br />
= &amp;\,\mathbb{E}</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}\sim p</em>}}(\boldsymbol{x<em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}),\boldsymbol{x}_0^{(g)}\sim p</em>}}(\boldsymbol{x<em _boldsymbol_varphi="\boldsymbol{\varphi">0^{(g)}|\boldsymbol{x}_t^{(g)})}\left[\left\langle\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t), \bar{\beta}_t\nabla</em><em _boldsymbol_x="\boldsymbol{x">t^{(g)}} \log p(\boldsymbol{x}_t^{(g)}|\boldsymbol{x}_0^{(g)})\right\rangle\right] \\[5pt]<br />
= &amp;\,-\mathbb{E}</em><em _boldsymbol_theta="\boldsymbol{\theta">0^{(g)}\sim p</em>}}(\boldsymbol{x<em _boldsymbol_theta="\boldsymbol{\theta">0^{(g)}),\boldsymbol{x}_t^{(g)}\sim p</em>}}(\boldsymbol{x<em _boldsymbol_varphi="\boldsymbol{\varphi">t^{(g)}|\boldsymbol{x}_0^{(g)})}\left[\left\langle\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t), \frac{\boldsymbol{x}_t - \bar{\alpha}_t \boldsymbol{x}_0}{\bar{\beta}_t}\right\rangle\right] \\[5pt]<br />
= &amp;\,-\mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\langle\boldsymbol{\epsilon<em _boldsymbol_z="\boldsymbol{z">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t), \boldsymbol{\varepsilon}\right\rangle\right]<br />
\end{aligned}}\end{equation}<br />
跟绿色部分合并，就得到学生模型新的损失函数<br />
\begin{equation}\mathcal{L}_2 = \mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\left\langle\boldsymbol{\epsilon<em _boldsymbol_varphi="\boldsymbol{\varphi">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t), \boldsymbol{\epsilon}</em>}^*}(\boldsymbol{x}_t^{(g)},t) - \boldsymbol{\varepsilon}\right\rangle\right]\label{eq:gloss-2}\end{equation<br />
这就是SiD的核心结果，原论文的实验结果显示它能够高效地实现蒸馏，而式$\eqref{eq:gloss-1}$则没有训练出有意义的结果。</p>
<p>相比式$\eqref{eq:gloss-1}$，上式$\eqref{eq:gloss-2}$出现$\boldsymbol{\psi}^<em>$的次数显然更少，也就是对$\boldsymbol{\psi}^</em>$的依赖更弱。此外，上式是基于最优解$\boldsymbol{\epsilon}_{\boldsymbol{\psi}^<em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t)=-\bar{\beta}_t\nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>^}}(\boldsymbol{x}_t^{(g)})$恒等变换而来的，也就是说相当于（部分地）预先窥见了$\boldsymbol{\psi</em>$的精确值，这也是它更优越的原因之一</p>
<h2 id="_6">其他细节<a class="toc-link" href="#_6" title="Permanent link">&para;</a></h2>
<p>到目前为止，本文的推导基本上是原论文推导的重复，但出了个别记号上的不一致外，还有一些细节上的不同，下面简单澄清一下，以免读者混淆。</p>
<p>首先，论文的推导默认了$\bar{\alpha}_t=1$，这是沿用了<a href="https://papers.cool/arxiv/2206.00364">《Elucidating the Design Space of Diffusion-Based Generative Models》</a>一文的设置。然而尽管$\bar{\alpha}_t=1$很有代表性，并且能简化形式，但并不能很好地覆盖所有扩散模型类型，所以本文的推导保留了$\bar{\alpha}_t$。其次，论文的结果是以$\bar{\boldsymbol{\mu}}(\boldsymbol{x}_t) = \frac{\boldsymbol{x}_t - \bar{\beta}_t \boldsymbol{\epsilon}(\boldsymbol{x}_t,t)}{\bar{\alpha}_t}$为标准给出的，这显然跟扩散模型常见的以$\boldsymbol{\epsilon}(\boldsymbol{x}_t,t)$为准不符，笔者暂时没有领悟到原论文的表述方式的优越所在。</p>
<p>最后，原论文发现损失函数$\mathcal{L}_1$即$\eqref{eq:gloss-1}$实在太不稳定，往往对效果还起到负面作用，所以SiD最终取了式$\eqref{eq:gloss-1}$的相反数作为额外的损失函数，加权到改进的损失函数$\eqref{eq:gloss-2}$上，即最终损失为$\mathcal{L}_2 - \lambda\mathcal{L}_1$（注：原论文中的权重记号是$\alpha$，但本文$\alpha$已用来表示noise schedule，所以改用$\lambda$），这在个别情形还能取得更优的蒸馏效果。至于具体实验细节和数据，读者自行翻阅原论文就好。</p>
<p>相比其他蒸馏方法，SiD的缺点是对显存的需求比较大，因为它同时要维护三个模型$\boldsymbol{\epsilon}<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{\varphi}}(\boldsymbol{x}_t,t)$、$\boldsymbol{\epsilon}</em>}}(\boldsymbol{x<em _boldsymbol_theta="\boldsymbol{\theta">t,t)$和$\boldsymbol{g}</em>)$，它们具有相同的体量，虽然并非同时进行反向传播，但叠加起来也使得总显存量翻了一倍左右。针对这个问题，SiD在正文末尾提出，未来可以尝试对预训练的模型加LoRA来作为额外引入的两个模型，以进一步节省显存需求。}}(\boldsymbol{z</p>
<h2 id="_7">延伸思考<a class="toc-link" href="#_7" title="Permanent link">&para;</a></h2>
<p>笔者相信，对于一开始的“初级形式”，即式$\eqref{eq:dloss}$和式$\eqref{eq:gloss-1}$的交替优化，那么不少理论基础比较扎实并且深入思考过的读者都有机会想到，尤其是已经有DDE“珠玉在前”，推出它似乎并不是那么难预估的事情。但SiD的精彩之处是并没有止步于此，而是提出了后面的恒等变换，使得训练更加稳定高效，这体现了作者对扩散模型和优化理论非常深刻的理解。</p>
<p>同时，SiD也留下了不少值得进一步思考和探索的问题。比如，学生模型的损失$\eqref{eq:gloss-2}$的恒等化简到了尽头了吗？并没有，因为它的内积左边还有$\boldsymbol{\epsilon}<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{\psi}^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)$，还可以用同样的方式进行化简。具体来说，我们有<br />
\begin{equation}\begin{aligned}<br />
&amp;\,\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}_{\boldsymbol{\varphi</em>}(\boldsymbol{x}_t^{(g)},t) - \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\Vert^2\right] \\[5pt]<br />
=&amp;\,\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}_{\boldsymbol{\varphi</em>}(\boldsymbol{x}<em _boldsymbol_varphi="\boldsymbol{\varphi">t^{(g)},t)\Vert^2 - 2\left\langle\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t),\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t)\right\rangle + \Vert\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t)\Vert^2\right] \\[5pt]<br />
=&amp;\,\mathbb{E}</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}\sim p</em>}}(\boldsymbol{x<em _boldsymbol_varphi="\boldsymbol{\varphi">t^{(g)})}\left[<br />
\scriptsize{\Vert\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_varphi="\boldsymbol{\varphi">t^{(g)},t)\Vert^2 - 2\left\langle\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t),-\bar{\beta}_t\nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)})\right\rangle + \left\langle\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_x="\boldsymbol{x">t^{(g)},t),-\bar{\beta}_t\nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_x="\boldsymbol{x">t^{(g)})\right\rangle}<br />
\right] \\[5pt]<br />
\end{aligned}\end{equation}<br />
这里的每一个$-\bar{\beta}_t\nabla</em><em _boldsymbol_theta="\boldsymbol{\theta">t^{(g)}}\log p</em>}}(\boldsymbol{x<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)})$都可以用相同的恒等变换$\eqref{eq:id}$最终转化为单个$\boldsymbol{\varepsilon}$（但要注意$\Vert\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t)\Vert^2=\langle\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t),\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\rangle$只能转换一个，不能都转），而式$\eqref{eq:gloss-2}$相当于只转了一部分，如果全部转会更好吗？因为没有实验结果，所以暂时不得而知。但有一个特别有意思的形式，就是只转换上面的中间部分的话，该损失函数可以写成<br />
\begin{equation}\begin{aligned}<br />
&amp;\,\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}_{\boldsymbol{\varphi</em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\Vert^2\right] \\[5pt]<br />
=&amp;\,\mathbb{E}</em>^},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}_{\boldsymbol{\varphi</em>}(\boldsymbol{x}<em _boldsymbol_varphi="\boldsymbol{\varphi">t^{(g)},t)\Vert^2 - 2\left\langle\boldsymbol{\epsilon}</em>^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t),\boldsymbol{\varepsilon}\right\rangle + \Vert\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}<em _boldsymbol_z="\boldsymbol{z">t^{(g)},t)\Vert^2\right] \\[5pt]<br />
=&amp;\,\mathbb{E}</em>},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{\varphi}^<em>}(\boldsymbol{x}<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\varepsilon}\Vert^2 + \Vert\boldsymbol{\epsilon}</em>^</em>}(\boldsymbol{x}_t^{(g)},t)\Vert^2\right] + \text{常数} \\[5pt]<br />
\end{aligned}\label{eq:gloss-3}\end{equation}<br />
这是学生模型，也就是生成器的损失，然后我们再对比学生数据去噪模型的损失$\eqref{eq:dloss}$：<br />
\begin{equation}\boldsymbol{\psi}^* = \mathop{\text{argmin}}</em>}} \mathbb{E<em _boldsymbol_psi="\boldsymbol{\psi">{\boldsymbol{z},\boldsymbol{\varepsilon}\sim\mathcal{N}(\boldsymbol{0}, \boldsymbol{I})}\left[\Vert\boldsymbol{\epsilon}</em>}}(\boldsymbol{x<em _boldsymbol_psi="\boldsymbol{\psi">t^{(g)},t) - \boldsymbol{\varepsilon}\Vert^2\right]\label{eq:dloss-1}\end{equation}<br />
这两个式子联合起来看，我们可以发现学生模型实则在向教师模型看齐，并且试图远离学生数据所训练的去噪模型，形式上很像<a href="https://papers.cool/arxiv/1611.04076">LSGAN</a>，$\boldsymbol{\epsilon}</em>,t)$类似GAN的判别器，不同的地方是，GAN的判别器一般是两项损失相加而生成器是单项损失，SiD则反过来了。这其实体现了两种不同的学习思路：}}(\boldsymbol{x}_t^{(g)</p>
<blockquote>
<p>1、GAN：一开始造假者（生成器）和鉴别者（判别器）都是小白，鉴别者不断对比真品和赝品来提供自己的鉴宝水平，造假者则通过鉴别者的反馈不断提高自己的造假水平；</p>
<p>2、SiD：完全没有真品，但有一个绝对权威的鉴宝大师（教师模型），造假者（学生模型）不断制作赝品，同时培养自己的鉴别者（学生数据训练的去噪模型），然后通过自家鉴别者跟大师的交流来提高自己造假水平。</p>
</blockquote>
<p>可能有读者会问：为什么SiD中的造假者不直接向大师请教，而是要通过培养自己的鉴别者来间接获得反馈呢？这是因为直接跟大师交流的话，可能会出现的问题就是长期都只交流同一个作品的技术，最终只制造出了一种能够以假乱真的赝品（模式坍缩），而通过培养自己的鉴别者一定程度上就可以避免这个问题，因为造假者的学习策略是“多得到大师的好评，同时尽量减少自家人的好评”，如果造假者还是只制造一种赝品，那么大师和自家的好评都会越来越多，这不符合造假者的学习策略，从而迫使造假者不断开发新的产品而不是固步自封。</p>
<p>此外，读者可以发现，SiD整个训练并没有利用到扩散模型的递归采样的任何信息，换句话说它纯粹是利用了去噪这一训练方式所训练出来的去噪模型，那么一个自然的问题是：如果单纯为了训练一个单步的生成模型，而不是作为已有扩散模型的蒸馏，那么我们训练一个只具有单一噪声强度的去噪模型会不会更好？比如像DDE一样，固定$\bar{\alpha}_t=1$、$\bar{\beta}_t=\beta=\text{某个常数}$取训练一个去噪模型，然后用它来重复SiD的训练过程，这样会不会能够简化训练难度、提高训练效率？这也是一个值得进一步确认的问题。</p>
<h2 id="_8">文章小结<a class="toc-link" href="#_8" title="Permanent link">&para;</a></h2>
<p>在这篇文章中，我们介绍了一种新的将扩散模型蒸馏为单步生成模型的方案，其思想可以追溯到前两年的利用去噪自编码器训练生成模型的工作，它不需要获得教师模型的真实训练集，也不需要迭代教师模型来生成样本对，而引入了类似GAN的交替训练，同时提出了关键的恒等变换来稳定训练过程，整个方法有颇多值得学习之处。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/10085">https://spaces.ac.cn/archives/10085</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (May. 01, 2024). 《生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上） 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/10085">https://spaces.ac.cn/archives/10085</a></p>
<p>@online{kexuefm-10085,<br />
title={生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上）},<br />
author={苏剑林},<br />
year={2024},<br />
month={May},<br />
url={\url{https://spaces.ac.cn/archives/10085}},<br />
} </p>
<hr />
<h2 id="_9">公式推导与注释<a class="toc-link" href="#_9" title="Permanent link">&para;</a></h2>
<p>TODO: 添加详细的数学公式推导和注释</p>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="adam的epsilon如何影响学习率的scaling-law.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#195 Adam的epsilon如何影响学习率的Scaling Law？</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="三个球的交点坐标三球交会定位.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#197 三个球的交点坐标（三球交会定位）</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#_1">生成扩散模型漫谈（二十五）：基于恒等式的蒸馏（上）</a><ul>
<li><a href="#_2">重现江湖</a></li>
<li><a href="#_3">初级形式</a></li>
<li><a href="#_4">点睛之笔</a></li>
<li><a href="#_5">恒等变换</a></li>
<li><a href="#_6">其他细节</a></li>
<li><a href="#_7">延伸思考</a></li>
<li><a href="#_8">文章小结</a></li>
<li><a href="#_9">公式推导与注释</a></li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>