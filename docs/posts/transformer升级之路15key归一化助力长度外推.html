<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer升级之路：15、Key归一化助力长度外推 | ML & Math Blog Posts</title>
    <meta name="description" content="Transformer升级之路：15、Key归一化助力长度外推&para;
原文链接: https://spaces.ac.cn/archives/9859
发布日期: 

大体上，我们可以将目前Transformer的长度外推技术分为两类：一类是事后修改，比如NTK-RoPE、YaRN、ReRoPE等，这类方法的特点是直接修改推理模型，无需微调就能达到一定的长度外推效果，但缺点是它们都无法保持模...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=详细推导">详细推导</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #119 Transformer升级之路：15、Key归一化助力长度外推
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#119</span>
                Transformer升级之路：15、Key归一化助力长度外推
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> 2023-11-20</span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=详细推导" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 详细推导</span>
                </a>
                
                <a href="../index.html?tags=attention" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> attention</span>
                </a>
                
                <a href="../index.html?tags=位置编码" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 位置编码</span>
                </a>
                
                <a href="../index.html?tags=泛化" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 泛化</span>
                </a>
                
                <a href="../index.html?tags=外推" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 外推</span>
                </a>
                
                <a href="../index.html?tags=生成模型" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 生成模型</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="transformer15key">Transformer升级之路：15、Key归一化助力长度外推<a class="toc-link" href="#transformer15key" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/9859">https://spaces.ac.cn/archives/9859</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>大体上，我们可以将目前Transformer的长度外推技术分为两类：一类是事后修改，比如<a href="/archives/9675">NTK-RoPE</a>、<a href="https://papers.cool/arxiv/2309.00071">YaRN</a>、<a href="/archives/9708">ReRoPE</a>等，这类方法的特点是直接修改推理模型，无需微调就能达到一定的长度外推效果，但缺点是它们都无法保持模型在训练长度内的恒等性；另一类自然是事前修改，如<a href="/archives/9431#ALIBI">ALIBI</a>、<a href="/archives/9431#KERPLE">KERPLE</a>、<a href="/archives/9431#XPOS">XPOS</a>以及<a href="/archives/9603">HWFA</a>等，它们可以不加改动地实现一定的长度外推，但相应的改动需要在训练之前就引入，因此无法不微调地用于现成模型，并且这类方法是否能够Scale Up还没得到广泛认可。</p>
<p>在这篇文章中，笔者将介绍一种意外发现的长度外推方案——“KeyNorm”——对Attention的Key序列做L2 Normalization，很明显它属于事前修改一类，但对Attention机制的修改非常小，因此看上去非常有希望能够Scale Up。</p>
<h2 id="_1">最初动机<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h2>
<p>之所以说“意外发现”，是因为该改动的原始动机并不是长度外推，而是尝试替换Scaled Dot-Product Attention中的Scale方式。我们知道，Attention的标准定义是（本文主要考虑Causal场景）<br />
\begin{equation}\boldsymbol{o}<em j="j">i = \frac{\sum</em>}^i\exp\left(\frac{\boldsymbol{q<em j="j">i\cdot \boldsymbol{k}_j}{\sqrt{d}}\right)\boldsymbol{v}_j}{\sum</em>}^i\exp\left(\frac{\boldsymbol{q<em i="1">i\cdot \boldsymbol{k}_j}{\sqrt{d}}\right)},\quad \boldsymbol{q}_i,\boldsymbol{k}_j\in\mathbb{R}^d\label{eq:sdpa}\end{equation}<br />
其中，Scale因子$\frac{1}{\sqrt{d}}$我们已经多次进行过解释甚至推广，比如<a href="/archives/8620#NTK%E5%8F%82%E6%95%B0%E5%8C%96">《浅谈Transformer的初始化、参数化与标准化》</a>、<a href="/archives/8823">《从熵不变性看Attention的Scale操作》</a>、<a href="/archives/9812">《从梯度最大化看Attention的Scale操作》</a>等。标准的推导是在“$\boldsymbol{q}_i,\boldsymbol{k}_j$均独立地采样自“均值为0、方差为1”的分布”的假设下进行的，而在该假设之下，我们还有<br />
\begin{equation}\Vert\boldsymbol{q}_i\Vert\approx \sqrt{d},\quad \Vert\boldsymbol{k}_j\Vert\approx \sqrt{d}\end{equation}<br />
这是因为<br />
\begin{equation}\Vert\boldsymbol{x}\Vert^2 = \sum</em>}^d x_i^2 = d\times\frac{1}{d}\sum_{i=1}^d x_i^2\approx d\,\mathbb{E<em j="j">{x\sim\mathcal{N}(0,1)}[x^2] = d\end{equation}<br />
相关推广还可以参考<a href="/archives/8679#%E5%BC%95%E7%90%86%E7%9A%84%E5%BC%95%E7%90%86">《让人惊叹的Johnson-Lindenstrauss引理：理论篇》</a>。这个近似式意味着，在Attention的初始阶段式$\eqref{eq:sdpa}$与下面两个变体有着相同的效果：<br />
\begin{align}\color{red}{\text{Q}}\text{uery}\color{red}{\text{N}}\text{orm:}\quad\boldsymbol{o}_i =&amp;\, \frac{\sum</em>}^i\exp\left(\tilde{\boldsymbol{q}<em j="j">i\cdot \boldsymbol{k}_j\right)\boldsymbol{v}_j}{\sum</em>}^i\exp\left(\tilde{\boldsymbol{q}<em j="j">i\cdot \boldsymbol{k}_j\right)},\qquad \tilde{\boldsymbol{q}}_i = \frac{\boldsymbol{q}_i}{\Vert\boldsymbol{q}_i\Vert} \\[5pt]<br />
\color{red}{\text{K}}\text{ey}\color{red}{\text{N}}\text{orm:}\quad\boldsymbol{o}_i =&amp;\, \frac{\sum</em>}^i\exp\left(\boldsymbol{q<em j="j">i\cdot \tilde{\boldsymbol{k}}_j\right)\boldsymbol{v}_j}{\sum</em>}^i\exp\left(\boldsymbol{q}_i\cdot \tilde{\boldsymbol{k}}_j\right)},\qquad \tilde{\boldsymbol{k}}_j = \frac{\boldsymbol{k}_j}{\Vert\boldsymbol{k}_j\Vert<br />
\end{align}<br />
因此，就有了验证这两个变体与标准的式$\eqref{eq:sdpa}$哪个更优的想法。为了描述的方便，我们可以相应地称为“Query/Key-Normalized Dot-Product Attention”，分别简称为“QNA”和“KNA”。</p>
<p>此外，既然可以QueryNorm和KeyNorm，那么自然也可以考虑两者都Norm一下，所以我们将如下“Scaled Cosine Attention（CosA）”也一并进行实验：<br />
\begin{equation}\boldsymbol{o}<em j="j">i = \frac{\sum</em>}^i\exp\left(\lambda\,\tilde{\boldsymbol{q}<em j="j">i\cdot \tilde{\boldsymbol{k}}_j\right)\boldsymbol{v}_j}{\sum</em>}^i\exp\left(\lambda\,\tilde{\boldsymbol{q}<em j="j">i\cdot \tilde{\boldsymbol{k}}_j\right)} = \frac{\sum</em>}^i\exp\left(\lambda\cos(\boldsymbol{q<em j="j">i,\boldsymbol{k}_j)\right)\boldsymbol{v}_j}{\sum</em>}^i\exp\left(\lambda\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)\right)<br />
\end{equation}<br />
其中$\lambda$采用<a href="/archives/9812">《从梯度最大化看Attention的Scale操作》</a>中的结果，即$\lambda = 4\log n$（原文是3.5，但下面训练长度比较小，改为4更精准一些），其中$n$固定为训练长度的一半，或者动态取位置id加1。</p>
<h2 id="_2">先看结果<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>沿着<a href="/archives/9731#%E5%AE%9E%E9%AA%8C">之前</a>做长度外推的实验设置，都是1亿参数的小模型，<a href="/archives/9052">GAU</a>架构，训练相同的步数（时间有限，这个步数下其实模型还没训练充分），训练长度512，并考虑外推到4096长度，实验结果如下表。其中Baseline就是式$\eqref{eq:sdpa}$，$\text{-}\log n$就是加入<a href="/archives/8823">《从熵不变性看Attention的Scale操作》</a>介绍的长度相关的缩放因子。评价指标是语言模型的逐token准确率，越大越好。<br />
\begin{array}{c|cc}<br />
\hline<br />
\text{测试长度} &amp; 512(\text{训练}) &amp; 4096(\text{重复}) &amp; 4096(\text{不重复}) \\<br />
\hline<br />
\text{Baseline} &amp; 49.41\% &amp; 24.17\% &amp; 23.16\% \\<br />
\text{Baseline-}\log n &amp; 49.40\% &amp; 24.60\% &amp; 24.02\% \\<br />
\hline<br />
\text{QNA} &amp; 49.55\% &amp; 22.45\% &amp; 22.18\% \\<br />
\text{QNA-}\log n &amp; 49.42\% &amp; 19.55\% &amp; 18.74\% \\<br />
\text{KNA} &amp; 49.60\% &amp; 61.08\% &amp; 47.69\% \\<br />
\text{KNA-}\log n &amp; 49.58\% &amp; 63.17\% &amp; 46.40\%\\<br />
\text{CosA} &amp; 49.73\% &amp; 58.90\% &amp; 46.98\% \\<br />
\text{CosA-}\log n &amp; 49.67\% &amp; 64.74\% &amp; 48.95\% \\<br />
\hline<br />
\end{array}<br />
从表格中我们可以看出：1、不管是QueryNorm还是KeyNorm，都在训练长度上取得了更好的效果，虽然这个优势非常微弱，大概率随着训练的进一步推进可以忽略不计，但这个优势非常稳定，暗示着让训练更加平稳的可能性；2、<strong>KeyNorm对长度外推的提升非常明显</strong> ，这就是实验结果中的“意外之喜”！</p>
<p>注意，跟NTK-RoPE、YaRN需要修改推理阶段的模型不同，这里的KNA和CosA的长度外推在推理阶段是完全不做改动的。因此，可能有读者想知道，既然KNA和CosA推理时不加改动外推效果都这么好了，如果配合NTK-RoPE、YaRN等外推技巧，效果会不会“更上一层楼”？对此，笔者也进行了测试，结果如下表：<br />
\begin{array}{c|cc}<br />
\hline<br />
\text{测试长度} &amp; 512(\text{训练}) &amp; 4096(\text{重复}) &amp; 4096(\text{不重复}) \\<br />
\hline<br />
\text{Baseline} &amp; 49.41\% &amp; 24.17\% &amp; 23.16\% \\<br />
\text{Baseline-NTK} &amp; 49.41\% &amp; 60.57\% &amp; 42.20\% \\<br />
\text{Baseline-YaRN} &amp; 49.41\% &amp; 80.10\% &amp; 47.45\% \\<br />
\text{Baseline-ReRoPE} &amp; 49.41\% &amp; 76.11\% &amp; 47.82\% \\<br />
\hline<br />
\text{Baseline-}\log n &amp; 49.40\% &amp; 24.60\% &amp; 24.02\% \\<br />
\text{Baseline-}\log n\text{-NTK} &amp; 49.40\% &amp; 75.86\% &amp; 47.06\% \\<br />
\text{Baseline-}\log n\text{-YaRN} &amp; 49.40\% &amp; 82.57\% &amp; 46.52\% \\<br />
\text{Baseline-}\log n\text{-ReRoPE} &amp; 49.40\% &amp; 85.47\% &amp; 48.87\% \\<br />
\hline<br />
\text{QNA} &amp; 49.55\% &amp; 22.45\% &amp; 22.18\% \\<br />
\text{QNA-NTK} &amp; 49.55\% &amp; 52.28\% &amp; 39.88\% \\<br />
\text{QNA-YaRN} &amp; 49.55\% &amp; 82.53\% &amp; 47.50\% \\<br />
\text{QNA-ReRoPE} &amp; 49.55\% &amp; 78.22\% &amp; 47.72\% \\<br />
\hline<br />
\text{QNA-}\log n &amp; 49.42\% &amp; 19.55\% &amp; 18.74\% \\<br />
\text{QNA-}\log n\text{-NTK} &amp; 49.42\% &amp; 57.44\% &amp; 41.56\% \\<br />
\text{QNA-}\log n\text{-YaRN} &amp; 49.42\% &amp; 80.08\% &amp; 45.16\% \\<br />
\text{QNA-}\log n\text{-ReRoPE} &amp; 49.42\% &amp; 84.71\% &amp; 48.31\% \\<br />
\hline<br />
\text{KNA} &amp; 49.60\% &amp; 61.08\% &amp; 47.69\% \\<br />
\text{KNA-NTK} &amp; 49.60\% &amp; 64.44\% &amp; 43.02\% \\<br />
\text{KNA-YaRN} &amp; 49.60\% &amp; 84.19\% &amp; 47.44\% \\<br />
\text{KNA-ReRoPE} &amp; 49.60\% &amp; 77.76\% &amp; 47.73\% \\<br />
\hline<br />
\text{KNA-}\log n &amp; 49.58\% &amp; 63.17\% &amp; 46.40\%\\<br />
\text{KNA-}\log n\text{-NTK} &amp; 49.58\% &amp; 79.05\% &amp; 47.43\%\\<br />
\text{KNA-}\log n\text{-YaRN} &amp; 49.58\% &amp; 83.95\% &amp; 47.16\%\\<br />
\text{KNA-}\log n\text{-ReRoPE} &amp; 49.58\% &amp; 85.48\% &amp; 48.78\%\\<br />
\hline<br />
\text{CosA} &amp; 49.73\% &amp; 58.90\% &amp; 46.98\% \\<br />
\text{CosA-NTK} &amp; 49.73\% &amp; 62.50\% &amp; 42.77\% \\<br />
\text{CosA-YaRN} &amp; 49.73\% &amp; 83.40\% &amp; 47.80\% \\<br />
\text{CosA-ReRoPE} &amp; 49.73\% &amp; 77.82\% &amp; 47.80\% \\<br />
\hline<br />
\text{CosA-}\log n &amp; 49.67\% &amp; 64.74\% &amp; 48.39\% \\<br />
\text{CosA-}\log n\text{-NTK} &amp; 49.67\% &amp; 78.97\% &amp; 47.46\% \\<br />
\text{CosA-}\log n\text{-YaRN} &amp; 49.67\% &amp; 82.28\% &amp; 45.72\% \\<br />
\text{CosA-}\log n\text{-ReRoPE} &amp; 49.67\% &amp; 85.67\% &amp; 48.39\% \\<br />
\hline<br />
\end{array}<br />
这个表比较啰嗦，主要是为了让大家对主流长度外推技巧的效果差异有一个全面的感知，大家选择自己感兴趣的维度比较就好，但要注意如果看长度外推效果的话，应该以“不重复”一列为主，“重复”一列为辅。从上表看，结果着实有点让人意外，KeyNorm似乎“免疫”了已有的RoPE外推技巧，NTK、YaRN等技巧叠加上去并没有明显提升，甚至可能会下降，不过总体来看“重复”一列还是有显著提升的，不显著的是“不重复”一列。这些结果表明，KeyNorm依然有着无法有效识别超出训练长度的位置（所以“重复”的结果不高）的问题，但有效地避免了PPL爆炸问题（所以“不重复”的结果还不错）。</p>
<p>这对做Long Context的同学来说可能是个好消息：一方面，KeyNorm不像ALIBI、KERPLE等，它的长度外推不用加Local约束，训练完成后也不做任何修改，纯属是“免费的午餐”，甚至看上去加了KeyNorm后训练效果都变好了；另一方面，也因为它是非Local的，所以可以更长文本继续训练，并且继续训练时再也不用纠结是选<a href="https://papers.cool/arxiv/2306.15595">PI</a>还是<a href="https://papers.cool/arxiv/2309.16039">ABF</a>了，对于KeyNorm来说，啥也不改就行。</p>
<h2 id="_3">原理分析<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>尽管这是个意外发现，但我们仍需要尝试去解释它，不然它就一直只是个意外。所以这一节我们尝试来思考，为什么KeyNorm会有助于长度外推。</p>
<p>让我们重新回到式$\eqref{eq:sdpa}$，第$i$个token与第$j$个token的相关性打分由内积完成：<br />
\begin{equation}s(j|i) = \boldsymbol{q}<em j="1">i\cdot \boldsymbol{k}_j = \Vert\boldsymbol{q}_i\Vert \Vert\boldsymbol{k}_j\Vert \cos(\boldsymbol{q}_i,\boldsymbol{k}_j),\quad p(j|i) = \frac{\exp\left(\frac{s(j|i)}{\sqrt{d}}\right)}{\sum</em>}^i \exp\left(\frac{s(j|i)}{\sqrt{d}}\right)}\end{equation<br />
第二个等号，我们从几何意义出发，将它分解为了各自模长与夹角余弦的乘积。注意力$p(j|i)$是一个条件概率，$\Vert\boldsymbol{q}_i\Vert$只跟当前位置$i$有关，它不改变注意力的相对大小，而只改变<a href="/archives/9595">稀疏程度</a>；$\Vert\boldsymbol{k}_j\Vert$则有能力改变$p(j|i)$的相对大小，但它不涉及到$i,j$的交互，可以用来表达一些绝对信号，比如<a href="https://papers.cool/arxiv/2305.17118">Scissorhands</a>表明某些绝对位置的token的注意力一直都会很高，这就有可能用$\Vert\boldsymbol{k}_j\Vert$来表达；剩下的$\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)$就是用来表达$i,j$的交互，它是自由度最大的一项。</p>
<p>很明显，为了提高某个位置$j$的相对重要性，模型有两个选择：1、增大模长$\Vert\boldsymbol{k}_j\Vert$；2、增大$\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)$，即缩小$\boldsymbol{q}_i,\boldsymbol{k}_j$的夹角大小。然而，由于“<a href="/archives/7076">维度灾难</a>”的存在，在高维空间中显著地改变夹角大小相对来说没有那么容易，所以如果能靠增大模长$\Vert\boldsymbol{k}_j\Vert$完成的，模型会优先选择通过增大模长$\Vert\boldsymbol{k}_j\Vert$来完成，这导致的直接后果是：$\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)$的训练可能并不充分。</p>
<p>这里笔者作出一个断言（猜测）：</p>
<blockquote>
<p>$\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)$的训练不充分是Attention无法长度外推的主要原因。</p>
</blockquote>
<p>$\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)$的训练不充分，是指被训练过的$\boldsymbol{q}_i,\boldsymbol{k}_j$的夹角只是一个有限的集合，而进行长度外推时，它要面对一个更大的集合，从而无法进行正确的预测。仔细思考<a href="https://papers.cool/arxiv/2309.00071">YaRN</a>一文的推导就会发现，NTK、YaRN之所以有效，是因为修改了推理阶段RoPE的实现，使得$\boldsymbol{q}_i,\boldsymbol{k}_j$的夹角落到原本训练阶段的有限集合中，避免面对没见过的更大的集合，转外推为内插；ReRoPE则更加干脆，直接截断Window以外的相对位置，这使得推理阶段的位置编码都不会“面生”。这些技巧一定程度上都间接地验证了这个断言。</p>
<p>从这个断言出发，KeyNorm的长度外推起因就变得简单了。不论是只进行KeyNorm的KNA，还是QueryNorm、KeyNorm都做的CosA，它们都将$\Vert\boldsymbol{k}_j\Vert$从Attention的定义中排除掉了，于是为了改变$j$的相对重要性，模型就只有“调整$\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)$”这一个选择，这将会使得模型更加充分地训练和利用$\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)$，从而间接促进了长度外推性。此外，笔者也实验过“KeyNorm + NoPE”的组合，但并没有发现长度外推性，这说明RoPE也在KeyNorm的长度外推中担任重要角色。事实上这也不难理解，RoPE对$\boldsymbol{q}_i,\boldsymbol{k}_j$进行旋转，更有助于扩大训练期间$\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)$的范围，从而使得$\cos(\boldsymbol{q}_i,\boldsymbol{k}_j)$的训练更为充分。</p>
<p>有没有工作已经尝试过QueryNorm和KeyNorm了呢？有。2020年的论文<a href="https://papers.cool/arxiv/2010.04245">《Query-Key Normalization for Transformers》</a>曾实验过CosA，论文还提出了一个类似的长度对数的Scale因子，但没有讨论到长度外推问题。此外，今年初Google的论文<a href="https://papers.cool/arxiv/2302.05442">《Scaling Vision Transformers to 22 Billion Parameters》</a>也在Query和Key加了Norm，但加的是LayerNorm，LayerNorm或者RMSNorm都带有可学的gamma参数，这使得Norm之后的向量模长未必为常数，因此并不好说是否能达到本文一样的长度外推效果。</p>
<h2 id="_4">文章小结<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h2>
<p>本文介绍了笔者意外发现的一种长度外推方案“KeyNorm”——对Attention的Key序列进行L2归一化，在训练长度上取得了更好的效果，并在长度外推方面表现出显著的提升。它属于“事前修改”方案，跟其他事前修改方案如ALIBI、KERPLE等相比，它没有Local约束，因此更有希望能够Scale Up；相比于NTK-RoPE、YaRN等“事后修改”方案，它在外推的时候则不会损失训练长度内的性能。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/9859">https://spaces.ac.cn/archives/9859</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Nov. 20, 2023). 《Transformer升级之路：15、Key归一化助力长度外推 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/9859">https://spaces.ac.cn/archives/9859</a></p>
<p>@online{kexuefm-9859,<br />
title={Transformer升级之路：15、Key归一化助力长度外推},<br />
author={苏剑林},<br />
year={2023},<br />
month={Nov},<br />
url={\url{https://spaces.ac.cn/archives/9859}},<br />
} </p>
<hr />
<h2 id="_5">公式推导与注释<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h2>
<h3 id="1-key">1. Key归一化的数学基础<a class="toc-link" href="#1-key" title="Permanent link">&para;</a></h3>
<p><strong>定义1.1：标准Scaled Dot-Product Attention</strong></p>
<p>标准的注意力机制可以表示为：<br />
$$<br />
\boldsymbol{o}<em j="1">i = \frac{\sum</em>}^i \exp\left(\frac{\boldsymbol{q<em j="1">i \cdot \boldsymbol{k}_j}{\sqrt{d}}\right) \boldsymbol{v}_j}{\sum</em>}^i \exp\left(\frac{\boldsymbol{q}_i \cdot \boldsymbol{k}_j}{\sqrt{d}}\right)<br />
$$</p>
<p>其中：<br />
- $\boldsymbol{q}_i, \boldsymbol{k}_j \in \mathbb{R}^d$ 分别是Query和Key向量<br />
- $d$ 是向量维度<br />
- $\boldsymbol{v}_j \in \mathbb{R}^d$ 是Value向量<br />
- $i$ 表示当前位置（Causal Mask）</p>
<p><strong>推导1.1：Scale因子$\frac{1}{\sqrt{d}}$的来源</strong></p>
<p>假设$\boldsymbol{q}<em _ell="1">i, \boldsymbol{k}_j$的每个分量独立同分布于$\mathcal{N}(0,1)$，则：<br />
$$<br />
\boldsymbol{q}_i \cdot \boldsymbol{k}_j = \sum</em>}^d q_{i,\ell} k_{j,\ell<br />
$$</p>
<p>由于$q_{i,\ell} \sim \mathcal{N}(0,1)$且$k_{j,\ell} \sim \mathcal{N}(0,1)$是独立的，我们有：<br />
$$<br />
\mathbb{E}[q_{i,\ell} k_{j,\ell}] = \mathbb{E}[q_{i,\ell}] \mathbb{E}[k_{j,\ell}] = 0 \cdot 0 = 0<br />
$$</p>
<p>方差为：<br />
$$<br />
\text{Var}[q_{i,\ell} k_{j,\ell}] = \mathbb{E}[(q_{i,\ell} k_{j,\ell})^2] - (\mathbb{E}[q_{i,\ell} k_{j,\ell}])^2 = \mathbb{E}[q_{i,\ell}^2]\mathbb{E}[k_{j,\ell}^2] = 1 \cdot 1 = 1<br />
$$</p>
<p>因此内积的方差为：<br />
$$<br />
\text{Var}\left[\sum_{\ell=1}^d q_{i,\ell} k_{j,\ell}\right] = \sum_{\ell=1}^d \text{Var}[q_{i,\ell} k_{j,\ell}] = d<br />
$$</p>
<p>故：<br />
$$<br />
\boldsymbol{q}_i \cdot \boldsymbol{k}_j \sim \mathcal{N}(0, d)<br />
$$</p>
<p>为了归一化方差到1，我们除以$\sqrt{d}$：<br />
$$<br />
\frac{\boldsymbol{q}_i \cdot \boldsymbol{k}_j}{\sqrt{d}} \sim \mathcal{N}(0, 1)<br />
$$</p>
<h3 id="2">2. 向量模长的统计性质<a class="toc-link" href="#2" title="Permanent link">&para;</a></h3>
<p><strong>定理2.1：高维随机向量的模长</strong></p>
<p>对于$\boldsymbol{x} \in \mathbb{R}^d$，其中$x_i \stackrel{i.i.d.}{\sim} \mathcal{N}(0,1)$，有：<br />
$$<br />
|\boldsymbol{x}|^2 = \sum_{i=1}^d x_i^2<br />
$$</p>
<p>由于$x_i^2 \sim \chi^2(1)$（卡方分布），所以：<br />
$$<br />
|\boldsymbol{x}|^2 \sim \chi^2(d)<br />
$$</p>
<p><strong>推导2.1：模长的期望</strong></p>
<p>卡方分布$\chi^2(d)$的期望和方差分别为$d$和$2d$，因此：<br />
$$<br />
\mathbb{E}[|\boldsymbol{x}|^2] = d<br />
$$</p>
<p>利用Jensen不等式（由于平方根是凹函数）：<br />
$$<br />
\mathbb{E}[|\boldsymbol{x}|] \leq \sqrt{\mathbb{E}[|\boldsymbol{x}|^2]} = \sqrt{d}<br />
$$</p>
<p>实际上，对于卡方分布，我们有更精确的结果：<br />
$$<br />
\mathbb{E}[|\boldsymbol{x}|] = \sqrt{2} \frac{\Gamma((d+1)/2)}{\Gamma(d/2)} \approx \sqrt{d} - \frac{1}{4\sqrt{d}} + O(d^{-3/2})<br />
$$</p>
<p>当$d$较大时，我们有近似：<br />
$$<br />
|\boldsymbol{x}| \approx \sqrt{d}<br />
$$</p>
<p><strong>推导2.2：集中不等式</strong></p>
<p>利用卡方分布的集中性，对于任意$\epsilon &gt; 0$：<br />
$$<br />
\mathbb{P}\left(\left||\boldsymbol{x}|^2 - d\right| &gt; \epsilon d\right) \leq 2\exp\left(-\frac{d\epsilon^2}{8}\right)<br />
$$</p>
<p>这说明当维度$d$较大时，$|\boldsymbol{x}|^2$高概率集中在$d$附近，因此：<br />
$$<br />
\mathbb{P}\left(\left||\boldsymbol{x}| - \sqrt{d}\right| &gt; \frac{\epsilon\sqrt{d}}{2}\right) \to 0 \quad \text{当} \quad d \to \infty<br />
$$</p>
<h3 id="3-key-normalization">3. Key Normalization的数学定义<a class="toc-link" href="#3-key-normalization" title="Permanent link">&para;</a></h3>
<p><strong>定义3.1：Key Normalized Attention (KNA)</strong></p>
<p>Key归一化注意力定义为：<br />
$$<br />
\boldsymbol{o}<em j="1">i = \frac{\sum</em>}^i \exp\left(\boldsymbol{q<em j="1">i \cdot \tilde{\boldsymbol{k}}_j\right) \boldsymbol{v}_j}{\sum</em>}^i \exp\left(\boldsymbol{q}_i \cdot \tilde{\boldsymbol{k}}_j\right)<br />
$$</p>
<p>其中归一化的Key向量为：<br />
$$<br />
\tilde{\boldsymbol{k}}_j = \frac{\boldsymbol{k}_j}{|\boldsymbol{k}_j|}<br />
$$</p>
<p>满足$|\tilde{\boldsymbol{k}}_j| = 1$。</p>
<p><strong>定理3.1：KNA与标准Attention的初始等价性</strong></p>
<p>在训练初期，当$\boldsymbol{q}_i, \boldsymbol{k}_j$的分量独立同分布于$\mathcal{N}(0,1)$时，KNA近似等价于标准的Scaled Attention。</p>
<p><strong>证明：</strong></p>
<p>由前述分析，当$\boldsymbol{k}_j$的分量独立同分布于$\mathcal{N}(0,1)$时：<br />
$$<br />
|\boldsymbol{k}_j| \approx \sqrt{d}<br />
$$</p>
<p>因此：<br />
$$<br />
\tilde{\boldsymbol{k}}_j = \frac{\boldsymbol{k}_j}{|\boldsymbol{k}_j|} \approx \frac{\boldsymbol{k}_j}{\sqrt{d}}<br />
$$</p>
<p>代入KNA的定义：<br />
$$<br />
\boldsymbol{q}_i \cdot \tilde{\boldsymbol{k}}_j \approx \boldsymbol{q}_i \cdot \frac{\boldsymbol{k}_j}{\sqrt{d}} = \frac{\boldsymbol{q}_i \cdot \boldsymbol{k}_j}{\sqrt{d}}<br />
$$</p>
<p>这恰好是标准Attention中的形式。$\square$</p>
<h3 id="4-query-key">4. Query-Key内积的几何分解<a class="toc-link" href="#4-query-key" title="Permanent link">&para;</a></h3>
<p><strong>定理4.1：内积的几何分解</strong></p>
<p>任意两个向量$\boldsymbol{q}_i, \boldsymbol{k}_j \in \mathbb{R}^d$的内积可以分解为：<br />
$$<br />
\boldsymbol{q}_i \cdot \boldsymbol{k}_j = |\boldsymbol{q}_i| |\boldsymbol{k}_j| \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)<br />
$$</p>
<p>其中$\cos(\boldsymbol{q}_i, \boldsymbol{k}_j)$是两向量夹角的余弦值：<br />
$$<br />
\cos(\boldsymbol{q}_i, \boldsymbol{k}_j) = \frac{\boldsymbol{q}_i \cdot \boldsymbol{k}_j}{|\boldsymbol{q}_i| |\boldsymbol{k}_j|}<br />
$$</p>
<p><strong>推导4.1：三个因子的作用分析</strong></p>
<p>在标准Attention中，注意力分数为：<br />
$$<br />
s(j|i) = \frac{\boldsymbol{q}_i \cdot \boldsymbol{k}_j}{\sqrt{d}} = \frac{|\boldsymbol{q}_i| |\boldsymbol{k}_j| \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)}{\sqrt{d}}<br />
$$</p>
<p>三个因子的作用：</p>
<ol>
<li>
<p><strong>Query模长$|\boldsymbol{q}_i|$</strong>：只依赖于位置$i$，不改变注意力的相对大小，只影响注意力分布的稀疏程度（温度）。</p>
</li>
<li>
<p><strong>Key模长$|\boldsymbol{k}_j|$</strong>：能够改变位置$j$的绝对重要性，不涉及$i,j$的交互。</p>
</li>
<li>
<p><strong>余弦$\cos(\boldsymbol{q}_i, \boldsymbol{k}_j)$</strong>：表达$i,j$之间的真正交互，取值范围$[-1,1]$，是自由度最大的一项。</p>
</li>
</ol>
<p><strong>推导4.2：注意力权重的详细展开</strong></p>
<p>注意力权重为：<br />
$$<br />
\alpha_{ij} = \frac{\exp\left(\frac{s(j|i)}{\sqrt{d}}\right)}{\sum_{k=1}^i \exp\left(\frac{s(k|i)}{\sqrt{d}}\right)}<br />
$$</p>
<p>代入几何分解：<br />
$$<br />
\alpha_{ij} = \frac{\exp\left(\frac{|\boldsymbol{q}<em k="1">i| |\boldsymbol{k}_j| \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)}{\sqrt{d}}\right)}{\sum</em>}^i \exp\left(\frac{|\boldsymbol{q}_i| |\boldsymbol{k}_k| \cos(\boldsymbol{q}_i, \boldsymbol{k}_k)}{\sqrt{d}}\right)<br />
$$</p>
<p>由于$|\boldsymbol{q}<em ij="ij">i|$在分子分母中都有，可以提取出来：<br />
$$<br />
\alpha</em>} = \frac{\exp\left(\frac{|\boldsymbol{k<em k="1">j| \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)}{\sqrt{d}/|\boldsymbol{q}_i|}\right)}{\sum</em>}^i \exp\left(\frac{|\boldsymbol{k}_k| \cos(\boldsymbol{q}_i, \boldsymbol{k}_k)}{\sqrt{d}/|\boldsymbol{q}_i|}\right)<br />
$$</p>
<p>这表明$|\boldsymbol{q}_i|$起到温度参数的作用。</p>
<h3 id="5-key">5. Key归一化对注意力分布的影响<a class="toc-link" href="#5-key" title="Permanent link">&para;</a></h3>
<p><strong>定理5.1：KNA消除了Key模长的影响</strong></p>
<p>在Key归一化后，注意力分数变为：<br />
$$<br />
s_{KNA}(j|i) = \boldsymbol{q}_i \cdot \tilde{\boldsymbol{k}}_j = |\boldsymbol{q}_i| \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)<br />
$$</p>
<p><strong>推导5.1：KNA的注意力权重</strong></p>
<p>$$<br />
\alpha_{ij}^{KNA} = \frac{\exp\left(|\boldsymbol{q}<em k="1">i| \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)\right)}{\sum</em>}^i \exp\left(|\boldsymbol{q}_i| \cos(\boldsymbol{q}_i, \boldsymbol{k}_k)\right)<br />
$$</p>
<p>对比标准Attention，KNA有以下特点：</p>
<ol>
<li>
<p><strong>消除了Key模长的影响</strong>：所有Key的模长都被归一化为1，模型无法通过增大$|\boldsymbol{k}_j|$来提高位置$j$的重要性。</p>
</li>
<li>
<p><strong>强制模型优化余弦相似度</strong>：模型只能通过调整$\cos(\boldsymbol{q}_i, \boldsymbol{k}_j)$（即向量方向）来改变注意力分布。</p>
</li>
<li>
<p><strong>保留了Query模长的温度效应</strong>：$|\boldsymbol{q}_i|$仍然可以控制注意力分布的尖锐程度。</p>
</li>
</ol>
<p><strong>定理5.2：余弦相似度的有界性</strong></p>
<p>由于$\cos(\boldsymbol{q}<em KNA="KNA">i, \boldsymbol{k}_j) \in [-1, 1]$，KNA的注意力分数满足：<br />
$$<br />
-|\boldsymbol{q}_i| \leq s</em>_i|}(j|i) \leq |\boldsymbol{q<br />
$$</p>
<p>这个有界性保证了注意力分数不会过大，有助于训练稳定性。</p>
<h3 id="6">6. 维度灾难与角度调整的困难<a class="toc-link" href="#6" title="Permanent link">&para;</a></h3>
<p><strong>定理6.1：高维空间中的角度分布</strong></p>
<p>在$d$维空间中，随机向量之间的夹角余弦值趋向于集中在0附近。</p>
<p><strong>推导6.1：随机向量夹角的分布</strong></p>
<p>设$\boldsymbol{u}, \boldsymbol{v} \in \mathbb{R}^d$为两个独立的随机向量，分量独立同分布于$\mathcal{N}(0,1)$。定义：<br />
$$<br />
\rho = \cos(\boldsymbol{u}, \boldsymbol{v}) = \frac{\boldsymbol{u} \cdot \boldsymbol{v}}{|\boldsymbol{u}| |\boldsymbol{v}|}<br />
$$</p>
<p>由于$\boldsymbol{u} \cdot \boldsymbol{v} = \sum_{i=1}^d u_i v_i$，其中$u_i v_i$独立，我们有：<br />
$$<br />
\mathbb{E}[\boldsymbol{u} \cdot \boldsymbol{v}] = \sum_{i=1}^d \mathbb{E}[u_i v_i] = 0<br />
$$<br />
$$<br />
\text{Var}[\boldsymbol{u} \cdot \boldsymbol{v}] = \sum_{i=1}^d \text{Var}[u_i v_i] = d<br />
$$</p>
<p>因此$\boldsymbol{u} \cdot \boldsymbol{v} \sim \mathcal{N}(0, d)$。同时：<br />
$$<br />
|\boldsymbol{u}|^2 \sim \chi^2(d), \quad |\boldsymbol{v}|^2 \sim \chi^2(d)<br />
$$</p>
<p>由大数定律：<br />
$$<br />
\frac{|\boldsymbol{u}|^2}{d} \to 1, \quad \frac{|\boldsymbol{v}|^2}{d} \to 1 \quad \text{当} \quad d \to \infty<br />
$$</p>
<p>因此：<br />
$$<br />
\rho = \frac{\boldsymbol{u} \cdot \boldsymbol{v}}{|\boldsymbol{u}| |\boldsymbol{v}|} \approx \frac{\boldsymbol{u} \cdot \boldsymbol{v}}{d}<br />
$$</p>
<p>标准化后：<br />
$$<br />
\sqrt{d} \cdot \rho \approx \frac{\boldsymbol{u} \cdot \boldsymbol{v}}{\sqrt{d}} \sim \mathcal{N}(0, 1)<br />
$$</p>
<p>即：<br />
$$<br />
\rho \sim \mathcal{N}\left(0, \frac{1}{d}\right)<br />
$$</p>
<p>这说明随着维度$d$增大，余弦相似度集中在0附近，方差为$O(1/d)$。</p>
<p><strong>推导6.2：角度调整的梯度分析</strong></p>
<p>要改变两个向量的余弦相似度，需要调整向量的方向。设我们要通过梯度下降优化$\boldsymbol{k}_j$使得$\cos(\boldsymbol{q}_i, \boldsymbol{k}_j)$增大。损失函数为：<br />
$$<br />
\mathcal{L} = -\cos(\boldsymbol{q}_i, \boldsymbol{k}_j) = -\frac{\boldsymbol{q}_i \cdot \boldsymbol{k}_j}{|\boldsymbol{q}_i| |\boldsymbol{k}_j|}<br />
$$</p>
<p>梯度为：<br />
$$<br />
\frac{\partial \mathcal{L}}{\partial \boldsymbol{k}_j} = -\frac{\boldsymbol{q}_i}{|\boldsymbol{q}_i| |\boldsymbol{k}_j|} + \frac{(\boldsymbol{q}_i \cdot \boldsymbol{k}_j) \boldsymbol{k}_j}{|\boldsymbol{q}_i| |\boldsymbol{k}_j|^3}<br />
$$</p>
<p>简化为：<br />
$$<br />
\frac{\partial \mathcal{L}}{\partial \boldsymbol{k}_j} = -\frac{1}{|\boldsymbol{q}_i| |\boldsymbol{k}_j|}\left(\boldsymbol{q}_i - \frac{\boldsymbol{q}_i \cdot \boldsymbol{k}_j}{|\boldsymbol{k}_j|^2} \boldsymbol{k}_j\right)<br />
$$</p>
<p>这是$\boldsymbol{q}_i$在垂直于$\boldsymbol{k}_j$方向上的分量（归一化后）。</p>
<p>另一方面，如果直接优化模长：<br />
$$<br />
\mathcal{L}' = -|\boldsymbol{k}_j|<br />
$$</p>
<p>梯度为：<br />
$$<br />
\frac{\partial \mathcal{L}'}{\partial \boldsymbol{k}_j} = -\frac{\boldsymbol{k}_j}{|\boldsymbol{k}_j|}<br />
$$</p>
<p>在高维空间中，改变向量方向（调整余弦）比改变向量模长需要更精细的协调，因此模型倾向于优先调整模长。</p>
<h3 id="7">7. 长度外推与位置编码的训练充分性<a class="toc-link" href="#7" title="Permanent link">&para;</a></h3>
<p><strong>定义7.1：位置编码的训练集</strong></p>
<p>设训练长度为$L_{train}$，则训练过程中出现的相对位置集合为：<br />
$$<br />
\mathcal{P}<em train="train">{train} = {m - n : 0 \leq m, n \leq L</em>}}, m \geq n} = {0, 1, 2, \ldots, L_{train<br />
$$</p>
<p>在长度外推到$L_{test} &gt; L_{train}$时，需要预测的相对位置集合为：<br />
$$<br />
\mathcal{P}<em test="test">{test} = {0, 1, 2, \ldots, L</em>}<br />
$$</p>
<p>显然$\mathcal{P}<em test="test">{train} \subset \mathcal{P}</em>}$，且$\mathcal{P<em train="train">{test} \setminus \mathcal{P}</em> \neq \emptyset$。</p>
<p><strong>假设7.1：余弦训练充分性假设</strong></p>
<p>模型能够成功进行长度外推，当且仅当$\cos(\boldsymbol{q}_i, \boldsymbol{k}_j)$在训练阶段得到充分训练，使得其学到的模式能够泛化到新的相对位置。</p>
<p><strong>推导7.1：标准Attention中余弦训练不足的原因</strong></p>
<p>在标准Attention中，为了提高位置$j$相对于位置$i$的注意力权重，模型有两个选择：</p>
<ol>
<li><strong>增大$|\boldsymbol{k}_j|$</strong>：这不需要改变向量方向，相对简单。</li>
<li><strong>增大$\cos(\boldsymbol{q}_i, \boldsymbol{k}_j)$</strong>：这需要精细调整向量方向，在高维空间中较困难。</li>
</ol>
<p>由于路径1更容易，模型会优先选择调整$|\boldsymbol{k}_j|$，导致：<br />
- $|\boldsymbol{k}_j|$充分训练，但它编码的是绝对位置信息<br />
- $\cos(\boldsymbol{q}_i, \boldsymbol{k}_j)$训练不足，但它才是真正编码相对位置的关键</p>
<p><strong>推导7.2：KNA强制余弦充分训练</strong></p>
<p>在KNA中，由于$|\tilde{\boldsymbol{k}}<em _boldsymbol_k="\boldsymbol{k">j| = 1$恒定，模型无法通过调整Key模长来改变注意力。因此：<br />
$$<br />
\text{唯一的优化路径：} \quad \max</em>_j)}_j} \cos(\boldsymbol{q}_i, \boldsymbol{k<br />
$$</p>
<p>这强制模型充分训练余弦相似度，使得位置信息更多地编码在向量方向而非模长中。</p>
<h3 id="8-ropekey">8. RoPE与Key归一化的协同作用<a class="toc-link" href="#8-ropekey" title="Permanent link">&para;</a></h3>
<p><strong>定理8.1：RoPE的旋转性质</strong></p>
<p>RoPE通过旋转矩阵$\boldsymbol{\mathcal{R}}_m$对Query和Key进行变换：<br />
$$<br />
\tilde{\boldsymbol{q}}_m = \boldsymbol{\mathcal{R}}_m \boldsymbol{q}_m, \quad \tilde{\boldsymbol{k}}_n = \boldsymbol{\mathcal{R}}_n \boldsymbol{k}_n<br />
$$</p>
<p>其中旋转矩阵保持向量模长不变：<br />
$$<br />
|\boldsymbol{\mathcal{R}}_m \boldsymbol{q}_m| = |\boldsymbol{q}_m|, \quad |\boldsymbol{\mathcal{R}}_n \boldsymbol{k}_n| = |\boldsymbol{k}_n|<br />
$$</p>
<p>且满足相对位置性质：<br />
$$<br />
\tilde{\boldsymbol{q}}<em n-m="n-m">m \cdot \tilde{\boldsymbol{k}}_n = \boldsymbol{q}_m^T \boldsymbol{\mathcal{R}}_m^T \boldsymbol{\mathcal{R}}_n \boldsymbol{k}_n = \boldsymbol{q}_m^T \boldsymbol{\mathcal{R}}</em>_n} \boldsymbol{k<br />
$$</p>
<p><strong>推导8.1：RoPE增加角度多样性</strong></p>
<p>对于二维旋转矩阵：<br />
$$<br />
\boldsymbol{\mathcal{R}}_m = \begin{pmatrix} \cos(m\theta) &amp; -\sin(m\theta) \ \sin(m\theta) &amp; \cos(m\theta) \end{pmatrix}<br />
$$</p>
<p>相对旋转为：<br />
$$<br />
\boldsymbol{\mathcal{R}}_{n-m} = \begin{pmatrix} \cos((n-m)\theta) &amp; -\sin((n-m)\theta) \ \sin((n-m)\theta) &amp; \cos((n-m)\theta) \end{pmatrix}<br />
$$</p>
<p>这使得$\boldsymbol{q}<em n-m="n-m">m$和$\boldsymbol{k}_n$之间的夹角变为：<br />
$$<br />
\cos(\tilde{\boldsymbol{q}}_m, \tilde{\boldsymbol{k}}_n) = \cos(\boldsymbol{q}_m, \boldsymbol{\mathcal{R}}</em>_n)} \boldsymbol{k<br />
$$</p>
<p>通过不同的相对位置$n-m$，旋转角度$(n-m)\theta$会遍历$[0, 2\pi)$的多个值（当$\theta$选择合适时），这显著增加了不同位置对之间角度的多样性。</p>
<p><strong>推导8.2：角度覆盖率分析</strong></p>
<p>设训练长度为$L_{train}$，RoPE的基频率为$\theta$。在训练过程中，相对位置$\Delta = n - m \in [0, L_{train}]$对应的旋转角度为：<br />
$$<br />
{\Delta \theta : \Delta = 0, 1, 2, \ldots, L_{train}}<br />
$$</p>
<p>这些角度在单位圆上的分布密度为：<br />
$$<br />
\rho = \frac{L_{train} \theta}{2\pi}<br />
$$</p>
<p>当$\rho \gg 1$时，即：<br />
$$<br />
\theta &gt; \frac{2\pi}{L_{train}}<br />
$$</p>
<p>单位圆被密集覆盖，训练到的角度样本充分，有利于泛化到更长的序列。</p>
<p><strong>定理8.2：KNA + RoPE的协同效应</strong></p>
<p>KNA强制模型优化余弦相似度，RoPE增加角度的多样性。两者结合：</p>
<ol>
<li><strong>KNA作用</strong>：$|\tilde{\boldsymbol{k}}_j| = 1$，消除模长干扰</li>
<li><strong>RoPE作用</strong>：通过旋转增加不同相对位置的角度多样性</li>
<li><strong>协同效应</strong>：充分训练的角度模式 + 丰富的角度样本 = 更好的长度外推</li>
</ol>
<h3 id="9-cosine-attention">9. Cosine Attention的数学表示<a class="toc-link" href="#9-cosine-attention" title="Permanent link">&para;</a></h3>
<p><strong>定义9.1：Scaled Cosine Attention (CosA)</strong></p>
<p>Cosine Attention同时对Query和Key进行归一化：<br />
$$<br />
\boldsymbol{o}<em j="1">i = \frac{\sum</em>}^i \exp\left(\lambda \tilde{\boldsymbol{q}<em j="1">i \cdot \tilde{\boldsymbol{k}}_j\right) \boldsymbol{v}_j}{\sum</em>}^i \exp\left(\lambda \tilde{\boldsymbol{q}}_i \cdot \tilde{\boldsymbol{k}}_j\right)<br />
$$</p>
<p>其中：<br />
$$<br />
\tilde{\boldsymbol{q}}_i = \frac{\boldsymbol{q}_i}{|\boldsymbol{q}_i|}, \quad \tilde{\boldsymbol{k}}_j = \frac{\boldsymbol{k}_j}{|\boldsymbol{k}_j|}<br />
$$</p>
<p>$\lambda$是可学习的温度参数。</p>
<p><strong>推导9.1：CosA注意力分数的性质</strong></p>
<p>注意力分数为：<br />
$$<br />
s_{CosA}(j|i) = \lambda \tilde{\boldsymbol{q}}_i \cdot \tilde{\boldsymbol{k}}_j = \lambda \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)<br />
$$</p>
<p>由于$\cos(\boldsymbol{q}<em CosA="CosA">i, \boldsymbol{k}_j) \in [-1, 1]$，有：<br />
$$<br />
s</em>(j|i) \in [-\lambda, \lambda]<br />
$$</p>
<p>这提供了严格的分数界限，有助于训练稳定性。</p>
<p><strong>定理9.1：温度参数的理论值</strong></p>
<p>根据熵不变性原理，温度参数应该设置为：<br />
$$<br />
\lambda = c \log n<br />
$$</p>
<p>其中$n$是序列长度，$c$是常数（通常取4左右）。</p>
<p><strong>推导9.2：温度参数的梯度最大化推导</strong></p>
<p>假设我们希望注意力分布的最大梯度保持稳定。注意力对输入的梯度为：<br />
$$<br />
\frac{\partial \alpha_{ij}}{\partial s(j|i)} = \alpha_{ij}(1 - \alpha_{ij})<br />
$$</p>
<p>梯度最大值出现在$\alpha_{ij} = 0.5$时，此时：<br />
$$<br />
\frac{\partial \alpha_{ij}}{\partial s(j|i)} = 0.25<br />
$$</p>
<p>对于均匀分布（$n$个位置），有$\alpha_{ij} = 1/n$。softmax的性质告诉我们，当分数差异为：<br />
$$<br />
\Delta s = \log n<br />
$$</p>
<p>时，能够产生显著的概率差异。因此温度参数应该随$\log n$缩放。</p>
<h3 id="10">10. 温度参数的自适应调整<a class="toc-link" href="#10" title="Permanent link">&para;</a></h3>
<p><strong>定义10.1：动态温度参数</strong></p>
<p>对于变长序列，温度参数应该根据实际序列长度动态调整：<br />
$$<br />
\lambda(n) = \max(1, c \log n)<br />
$$</p>
<p>其中$c \in [3.5, 4]$是常数，$n$是当前位置的索引（或序列长度的一半）。</p>
<p><strong>推导10.1：熵不变性条件</strong></p>
<p>设注意力分布为${\alpha_{ij}}<em j="1">{j=1}^i$，其熵为：<br />
$$<br />
H_i = -\sum</em>}^i \alpha_{ij} \log \alpha_{ij<br />
$$</p>
<p>在标准Attention中，由于softmax的性质，当分数尺度固定时：<br />
$$<br />
H_i \approx \log i - \text{const}<br />
$$</p>
<p>即熵随序列长度对数增长。</p>
<p>为了保持熵相对稳定（相对于最大熵$\log i$的比例），我们需要温度参数随$\log i$调整：<br />
$$<br />
s'(j|i) = \frac{s(j|i)}{\lambda(i)}, \quad \lambda(i) \propto \log i<br />
$$</p>
<p><strong>推导10.2：温度参数对注意力分布的影响</strong></p>
<p>注意力权重对温度的导数：<br />
$$<br />
\frac{\partial \alpha_{ij}}{\partial \lambda} = \frac{\partial}{\partial \lambda} \frac{\exp(\lambda s_{ij})}{\sum_k \exp(\lambda s_{ik})}<br />
$$</p>
<p>利用softmax的导数性质：<br />
$$<br />
\frac{\partial \alpha_{ij}}{\partial \lambda} = \alpha_{ij} \left(s_{ij} - \sum_k \alpha_{ik} s_{ik}\right)<br />
$$</p>
<p>这表明：<br />
- 当$s_{ij}$高于平均分数时，增大$\lambda$会增大$\alpha_{ij}$（富者更富）<br />
- 温度参数控制分布的尖锐程度</p>
<h3 id="11-layernorml2-normalization">11. LayerNorm与L2 Normalization的对比<a class="toc-link" href="#11-layernorml2-normalization" title="Permanent link">&para;</a></h3>
<p><strong>定义11.1：LayerNorm</strong></p>
<p>LayerNorm对向量进行如下变换：<br />
$$<br />
\text{LayerNorm}(\boldsymbol{x}) = \gamma \odot \frac{\boldsymbol{x} - \mu}{\sigma} + \beta<br />
$$</p>
<p>其中：<br />
$$<br />
\mu = \frac{1}{d}\sum_{i=1}^d x_i, \quad \sigma = \sqrt{\frac{1}{d}\sum_{i=1}^d (x_i - \mu)^2}<br />
$$</p>
<p>$\gamma, \beta \in \mathbb{R}^d$是可学习参数。</p>
<p><strong>定义11.2：L2 Normalization</strong></p>
<p>L2归一化仅调整模长：<br />
$$<br />
\text{L2Norm}(\boldsymbol{x}) = \frac{\boldsymbol{x}}{|\boldsymbol{x}|}<br />
$$</p>
<p>不改变向量方向，无可学习参数。</p>
<p><strong>对比11.1：中心化</strong></p>
<ul>
<li><strong>LayerNorm</strong>：先减去均值$\mu$，进行中心化</li>
<li><strong>L2Norm</strong>：不进行中心化，保留原始方向</li>
</ul>
<p><strong>对比11.2：缩放</strong></p>
<ul>
<li><strong>LayerNorm</strong>：除以标准差$\sigma$后，再乘以可学习的$\gamma$，输出模长不固定</li>
<li><strong>L2Norm</strong>：固定输出模长为1，$|\text{L2Norm}(\boldsymbol{x})| = 1$</li>
</ul>
<p><strong>对比11.3：可学习参数</strong></p>
<ul>
<li><strong>LayerNorm</strong>：有$2d$个可学习参数（$\gamma, \beta$）</li>
<li><strong>L2Norm</strong>：无可学习参数</li>
</ul>
<p><strong>定理11.1：LayerNorm可能破坏Key归一化的效果</strong></p>
<p>如果对Key应用LayerNorm而非L2归一化：<br />
$$<br />
\tilde{\boldsymbol{k}}_j = \gamma \odot \frac{\boldsymbol{k}_j - \mu_j}{\sigma_j} + \beta<br />
$$</p>
<p>由于$\gamma$是可学习的，模型可以通过调整$\gamma$来改变$|\tilde{\boldsymbol{k}}_j|$：<br />
$$<br />
|\tilde{\boldsymbol{k}}_j| = \left|\gamma \odot \frac{\boldsymbol{k}_j - \mu_j}{\sigma_j} + \beta\right|<br />
$$</p>
<p>这个模长不再固定为1，因此LayerNorm无法保证消除Key模长的影响。</p>
<h3 id="12">12. 长度外推的稳定性分析<a class="toc-link" href="#12" title="Permanent link">&para;</a></h3>
<p><strong>定义12.1：PPL爆炸</strong></p>
<p>在长度外推时，如果测试集的困惑度(Perplexity)显著高于训练长度下的困惑度，我们称发生了PPL爆炸：<br />
$$<br />
\text{PPL}<em test="test">{test}(L</em>}) \gg \text{PPL<em train="train">{train}(L</em>}) \quad \text{当} \quad L_{test} \gg L_{train<br />
$$</p>
<p><strong>定理12.1：KNA的数值稳定性</strong></p>
<p>在Key归一化后，注意力分数有严格的上界：<br />
$$<br />
|s_{KNA}(j|i)| = ||\boldsymbol{q}_i| \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)| \leq |\boldsymbol{q}_i|<br />
$$</p>
<p>这防止了注意力分数过大导致的softmax溢出。</p>
<p><strong>推导12.1：标准Attention的不稳定性来源</strong></p>
<p>在标准Attention中，如果某个Key的模长异常大：<br />
$$<br />
|\boldsymbol{k}_j| \gg \sqrt{d}<br />
$$</p>
<p>则对应的注意力分数：<br />
$$<br />
s(j|i) = \frac{|\boldsymbol{q}_i| |\boldsymbol{k}_j| \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)}{\sqrt{d}}<br />
$$</p>
<p>可能非常大，导致：<br />
$$<br />
\exp(s(j|i)) \gg \sum_{k \neq j} \exp(s(k|i))<br />
$$</p>
<p>注意力几乎完全集中在位置$j$，损失了对其他位置的感知。</p>
<p><strong>推导12.2：KNA保持注意力分布的多样性</strong></p>
<p>由于$s_{KNA}(j|i)$有界，softmax不会出现极端集中：<br />
$$<br />
\alpha_{ij}^{KNA} = \frac{\exp(|\boldsymbol{q}<em k="1">i| \cos_j)}{\sum</em>}^i \exp(|\boldsymbol{q}_i| \cos_k)<br />
$$</p>
<p>即使$\cos_j = 1$（最大值），只要存在其他$\cos_k$接近1的位置，注意力仍会分散。</p>
<h3 id="13">13. 相对位置的外推误差界<a class="toc-link" href="#13" title="Permanent link">&para;</a></h3>
<p><strong>定义13.1：位置编码函数</strong></p>
<p>设位置编码为函数$f: \mathbb{N} \to \mathbb{R}^d$，满足相对位置性质：<br />
$$<br />
\boldsymbol{q}_m^T \boldsymbol{k}_n = g(f(m), f(n)) = h(m - n)<br />
$$</p>
<p>其中$h: \mathbb{Z} \to \mathbb{R}$仅依赖于相对位置。</p>
<p><strong>定理13.1：训练位置集的Lipschitz性质</strong></p>
<p>假设$h$在训练集$[0, L_{train}]$上是Lipschitz连续的，常数为$L$：<br />
$$<br />
|h(\Delta_1) - h(\Delta_2)| \leq L |\Delta_1 - \Delta_2|, \quad \forall \Delta_1, \Delta_2 \in [0, L_{train}]<br />
$$</p>
<p><strong>推导13.1：外推误差的上界</strong></p>
<p>当外推到$L_{test} &gt; L_{train}$时，对于新的相对位置$\Delta \in (L_{train}, L_{test}]$，我们需要估计$h(\Delta)$。</p>
<p>最近邻插值：<br />
$$<br />
\hat{h}(\Delta) = h(L_{train})<br />
$$</p>
<p>误差为：<br />
$$<br />
|h(\Delta) - \hat{h}(\Delta)| = |h(\Delta) - h(L_{train})|<br />
$$</p>
<p>如果$h$满足全局Lipschitz条件（外推假设）：<br />
$$<br />
|h(\Delta) - h(L_{train})| \leq L (\Delta - L_{train}) \leq L (L_{test} - L_{train})<br />
$$</p>
<p>误差随外推长度线性增长。</p>
<p><strong>推导13.2：KNA减小Lipschitz常数</strong></p>
<p>在标准Attention中：<br />
$$<br />
h(\Delta) = |\boldsymbol{q}| |\boldsymbol{k}| \cos(\Delta\theta) / \sqrt{d}<br />
$$</p>
<p>其导数：<br />
$$<br />
|h'(\Delta)| = \frac{|\boldsymbol{q}| |\boldsymbol{k}| \theta |\sin(\Delta\theta)|}{\sqrt{d}} \leq \frac{|\boldsymbol{q}| |\boldsymbol{k}| \theta}{\sqrt{d}}<br />
$$</p>
<p>在KNA中：<br />
$$<br />
h_{KNA}(\Delta) = |\boldsymbol{q}| \cos(\Delta\theta)<br />
$$</p>
<p>导数：<br />
$$<br />
|h'_{KNA}(\Delta)| = |\boldsymbol{q}| \theta |\sin(\Delta\theta)| \leq |\boldsymbol{q}| \theta<br />
$$</p>
<p>如果$|\boldsymbol{k}| &gt; \sqrt{d}$（训练后期常见），则：<br />
$$<br />
|h'<em std="std">{KNA}| &lt; |h'</em>|<br />
$$</p>
<p>即KNA的Lipschitz常数更小，外推误差更小。</p>
<h3 id="14">14. 注意力熵与长度外推的关系<a class="toc-link" href="#14" title="Permanent link">&para;</a></h3>
<p><strong>定义14.1：注意力熵</strong></p>
<p>位置$i$的注意力分布的熵定义为：<br />
$$<br />
H_i = -\sum_{j=1}^i \alpha_{ij} \log \alpha_{ij}<br />
$$</p>
<p>熵越大，注意力越分散；熵越小，注意力越集中。</p>
<p><strong>定理14.1：长度外推需要适度的注意力熵</strong></p>
<p>成功的长度外推要求：<br />
$$<br />
\frac{H_i}{\log i} \approx \text{const}, \quad \forall i \in [1, L_{test}]<br />
$$</p>
<p>即归一化熵保持稳定。</p>
<p><strong>推导14.1：熵崩塌导致PPL爆炸</strong></p>
<p>如果在长序列中$H_i \to 0$（熵崩塌），意味着注意力几乎完全集中在少数位置：<br />
$$<br />
\exists j^<em> : \alpha_{ij^</em>} \approx 1, \quad \alpha_{ij} \approx 0, \forall j \neq j^*<br />
$$</p>
<p>这导致输出仅依赖于位置$j^*$的信息，丢失了其他位置的信息，预测质量下降。</p>
<p><strong>推导14.2：KNA维持注意力熵</strong></p>
<p>在KNA中，由于所有Key归一化，不存在某个位置通过极大的$|\boldsymbol{k}<em KNA="KNA">j|$"垄断"注意力的情况。注意力分数：<br />
$$<br />
s</em>_j)}(j|i) = |\boldsymbol{q}_i| \cos(\boldsymbol{q}_i, \boldsymbol{k<br />
$$</p>
<p>所有位置"平等竞争"，$\cos$值在$[-1,1]$范围内，差异相对温和，从而维持了适度的注意力熵。</p>
<h3 id="15-query-normalization">15. Query Normalization的对比实验<a class="toc-link" href="#15-query-normalization" title="Permanent link">&para;</a></h3>
<p><strong>定义15.1：Query Normalized Attention (QNA)</strong></p>
<p>$$<br />
\boldsymbol{o}<em j="1">i = \frac{\sum</em>}^i \exp\left(\tilde{\boldsymbol{q}<em j="1">i \cdot \boldsymbol{k}_j\right) \boldsymbol{v}_j}{\sum</em>}^i \exp\left(\tilde{\boldsymbol{q}}_i \cdot \boldsymbol{k}_j\right)}, \quad \tilde{\boldsymbol{q}}_i = \frac{\boldsymbol{q}_i}{|\boldsymbol{q}_i|<br />
$$</p>
<p><strong>定理15.1：QNA无法实现长度外推</strong></p>
<p>实验表明，QNA在训练长度上效果与标准Attention相当，但在长度外推上表现糟糕，甚至劣于Baseline。</p>
<p><strong>推导15.1：QNA失效的原因</strong></p>
<p>在QNA中：<br />
$$<br />
s_{QNA}(j|i) = \tilde{\boldsymbol{q}}_i \cdot \boldsymbol{k}_j = \frac{\boldsymbol{q}_i \cdot \boldsymbol{k}_j}{|\boldsymbol{q}_i|} = |\boldsymbol{k}_j| \cos(\boldsymbol{q}_i, \boldsymbol{k}_j)<br />
$$</p>
<p>Key模长$|\boldsymbol{k}_j|$仍然存在，模型仍可通过调整$|\boldsymbol{k}_j|$来改变注意力分布，因此$\cos$的训练不充分问题未解决。</p>
<p>同时，Query归一化消除了$|\boldsymbol{q}<em ij="ij">i|$的温度效应：<br />
$$<br />
\alpha</em>}^{QNA} = \frac{\exp(|\boldsymbol{k}_j| \cos_j)}{\sum_k \exp(|\boldsymbol{k}_k| \cos_k)<br />
$$</p>
<p>失去了通过$|\boldsymbol{q}_i|$调节注意力尖锐度的能力，反而增加了训练难度。</p>
<h3 id="16-key">16. 多头注意力中的Key归一化<a class="toc-link" href="#16-key" title="Permanent link">&para;</a></h3>
<p><strong>定义16.1：多头Key归一化</strong></p>
<p>对于$H$个注意力头，每个头独立进行Key归一化：<br />
$$<br />
\tilde{\boldsymbol{k}}_{j}^{(h)} = \frac{\boldsymbol{k}_j^{(h)}}{|\boldsymbol{k}_j^{(h)}|}, \quad h = 1, 2, \ldots, H<br />
$$</p>
<p><strong>推导16.1：不同头学习不同的角度模式</strong></p>
<p>由于每个头的Query和Key投影不同：<br />
$$<br />
\boldsymbol{q}_i^{(h)} = \boldsymbol{W}_Q^{(h)} \boldsymbol{x}_i, \quad \boldsymbol{k}_j^{(h)} = \boldsymbol{W}_K^{(h)} \boldsymbol{x}_j<br />
$$</p>
<p>归一化后：<br />
$$<br />
\cos^{(h)}(\boldsymbol{q}_i, \boldsymbol{k}_j) = \frac{\boldsymbol{q}_i^{(h)} \cdot \boldsymbol{k}_j^{(h)}}{|\boldsymbol{q}_i^{(h)}| |\boldsymbol{k}_j^{(h)}|}<br />
$$</p>
<p>不同的$\boldsymbol{W}_Q^{(h)}, \boldsymbol{W}_K^{(h)}$导致不同的余弦模式，实现多样化的位置感知。</p>
<p><strong>定理16.1：多头KNA增强表达能力</strong></p>
<p>多头KNA的输出为：<br />
$$<br />
\boldsymbol{o}_i = \boldsymbol{W}_O \text{Concat}(\text{head}_1, \text{head}_2, \ldots, \text{head}_H)<br />
$$</p>
<p>其中每个head学习不同的相对位置模式，组合后能够表达复杂的位置依赖关系。</p>
<h3 id="17">17. 训练稳定性的理论分析<a class="toc-link" href="#17" title="Permanent link">&para;</a></h3>
<p><strong>定义17.1：梯度范数</strong></p>
<p>训练稳定性可以通过梯度范数来衡量：<br />
$$<br />
|\nabla_\theta \mathcal{L}|<br />
$$</p>
<p>如果梯度范数在训练过程中保持适度范围，训练稳定；如果出现梯度爆炸或消失，训练不稳定。</p>
<p><strong>定理17.1：KNA的梯度有界性</strong></p>
<p>由于KNA的注意力分数有界：<br />
$$<br />
|s_{KNA}(j|i)| \leq |\boldsymbol{q}_i|<br />
$$</p>
<p>反向传播时梯度也相应有界，不会出现极端的梯度爆炸。</p>
<p><strong>推导17.1：注意力分数对参数的梯度</strong></p>
<p>$$<br />
\frac{\partial s_{KNA}(j|i)}{\partial \theta} = \frac{\partial}{\partial \theta} \left(\boldsymbol{q}_i \cdot \frac{\boldsymbol{k}_j}{|\boldsymbol{k}_j|}\right)<br />
$$</p>
<p>利用链式法则：<br />
$$<br />
\frac{\partial s_{KNA}}{\partial \theta} = \frac{\boldsymbol{q}_i}{|\boldsymbol{k}_j|} \cdot \frac{\partial \boldsymbol{k}_j}{\partial \theta} - \frac{(\boldsymbol{q}_i \cdot \boldsymbol{k}_j) \boldsymbol{k}_j}{|\boldsymbol{k}_j|^3} \cdot \frac{\partial \boldsymbol{k}_j}{\partial \theta}<br />
$$</p>
<p>由于$|\tilde{\boldsymbol{k}}_j| = 1$，第二项提供了自动的梯度缩放，防止梯度过大。</p>
<h3 id="18">18. 长度外推的实证分析<a class="toc-link" href="#18" title="Permanent link">&para;</a></h3>
<p><strong>实验设置</strong>：<br />
- 模型：GAU架构，1亿参数<br />
- 训练长度：512<br />
- 测试长度：4096<br />
- 评价指标：逐token准确率</p>
<p><strong>结果18.1：KNA显著提升外推效果</strong></p>
<p>从实验表格可见：<br />
- Baseline在4096（不重复）：23.16%<br />
- KNA在4096（不重复）：47.69%（提升超过2倍）<br />
- CosA在4096（不重复）：46.98%（接近KNA）</p>
<p><strong>分析18.1：为何"不重复"比"重复"更重要</strong></p>
<p>"重复"测试集：将512长度的文本重复8次拼接成4096<br />
"不重复"测试集：真实的4096长度文本</p>
<p>"不重复"更能反映真实的长度外推能力，因为：<br />
1. 真实场景中不会有大量重复文本<br />
2. "重复"可能被模型识别出周期性模式<br />
3. "不重复"需要模型真正理解长距离依赖</p>
<p><strong>分析18.2：KNA与外推技巧的叠加效果</strong></p>
<p>实验显示：<br />
- Baseline + YaRN：47.45%<br />
- KNA（无修改）：47.69%<br />
- KNA + YaRN：47.44%（几乎无提升）</p>
<p>结论：KNA已经隐式地解决了长度外推问题，进一步叠加YaRN等技巧无显著增益。</p>
<h3 id="19">19. 计算复杂度分析<a class="toc-link" href="#19" title="Permanent link">&para;</a></h3>
<p><strong>定理19.1：KNA的额外计算成本</strong></p>
<p>Key归一化的操作为：<br />
$$<br />
\tilde{\boldsymbol{k}}<em _ell="1">j = \frac{\boldsymbol{k}_j}{|\boldsymbol{k}_j|} = \frac{\boldsymbol{k}_j}{\sqrt{\sum</em>}^d k_{j,\ell}^2}<br />
$$</p>
<p><strong>计算步骤</strong>：<br />
1. 计算$|\boldsymbol{k}<em _ell="1">j|^2 = \sum</em>^2$：$O(d)$}^d k_{j,\ell<br />
2. 计算$|\boldsymbol{k}_j| = \sqrt{|\boldsymbol{k}_j|^2}$：$O(1)$<br />
3. 逐元素除法：$O(d)$</p>
<p>总计：$O(d)$</p>
<p>对于序列长度$n$，总复杂度为$O(nd)$。</p>
<p><strong>对比19.1：相对于Attention的计算量</strong></p>
<p>标准Attention的计算复杂度：<br />
- Query-Key点积：$O(n^2 d)$<br />
- Softmax：$O(n^2)$<br />
- Attention-Value加权：$O(n^2 d)$</p>
<p>总计：$O(n^2 d)$</p>
<p>Key归一化的$O(nd)$相对于$O(n^2 d)$可忽略不计（当$n \gg 1$时）。</p>
<h3 id="20">20. 与其他位置编码方案的比较<a class="toc-link" href="#20" title="Permanent link">&para;</a></h3>
<p><strong>对比20.1：ALIBI</strong></p>
<p>ALIBI通过在Attention分数上加入线性衰减bias：<br />
$$<br />
s_{ALIBI}(j|i) = \boldsymbol{q}_i \cdot \boldsymbol{k}_j - m \cdot (i - j)<br />
$$</p>
<p>其中$m$是衰减率。</p>
<p>缺点：<br />
- 显式的局部注意力偏好，可能损失远程依赖<br />
- 需要为每个头设置不同的$m$<br />
- 不适用于Encoder</p>
<p><strong>对比20.2：NTK-RoPE</strong></p>
<p>NTK-RoPE修改RoPE的base：<br />
$$<br />
\theta_i = (10000 \cdot \kappa)^{-2i/d}, \quad \kappa = \left(\frac{L_{test}}{L_{train}}\right)^{d/(d-2)}<br />
$$</p>
<p>缺点：<br />
- 需要修改推理阶段的模型<br />
- 无法保持训练长度内的恒等性<br />
- 外推效果有限（约$L_{test}/2$）</p>
<p><strong>对比20.3：YaRN</strong></p>
<p>YaRN对不同频率进行分段处理：<br />
$$<br />
\theta_i^{new} = \left[\gamma_i + (1-\gamma_i)\frac{L_{train}}{L_{test}}\right] \theta_i<br />
$$</p>
<p>优点：<br />
- 效果好于NTK-RoPE<br />
- 理论基础较好（转圈视角）</p>
<p>缺点：<br />
- 仍需修改推理模型<br />
- 实现相对复杂</p>
<p><strong>对比20.4：KNA的优势总结</strong></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>训练修改</th>
<th>推理修改</th>
<th>保持恒等性</th>
<th>远程依赖</th>
<th>实现复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALIBI</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>损失</td>
<td>低</td>
</tr>
<tr>
<td>NTK-RoPE</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>保留</td>
<td>低</td>
</tr>
<tr>
<td>YaRN</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>保留</td>
<td>中</td>
</tr>
<tr>
<td>KNA</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>保留</td>
<td>低</td>
</tr>
</tbody>
</table>
<p>KNA的独特优势：<br />
1. 推理时完全不修改（保持恒等性）<br />
2. 不引入局部偏好（保留远程依赖）<br />
3. 实现简单（单个归一化操作）<br />
4. 训练效果还略有提升</p>
<h3 id="21-key">21. Key归一化的几何解释<a class="toc-link" href="#21-key" title="Permanent link">&para;</a></h3>
<p><strong>几何视角21.1：单位球面上的点</strong></p>
<p>Key归一化将所有Key向量投影到单位球面：<br />
$$<br />
\mathcal{S}^{d-1} = {\boldsymbol{k} \in \mathbb{R}^d : |\boldsymbol{k}| = 1}<br />
$$</p>
<p>注意力分数变为：<br />
$$<br />
s_{KNA}(j|i) = |\boldsymbol{q}_i| \cdot (\hat{\boldsymbol{q}}_i \cdot \hat{\boldsymbol{k}}_j)<br />
$$</p>
<p>其中$\hat{\boldsymbol{q}}_i = \boldsymbol{q}_i / |\boldsymbol{q}_i|$也在单位球面上。</p>
<p><strong>几何意义</strong>：注意力分数正比于两个单位向量的内积，即它们在球面上的距离（测地线距离）。</p>
<p><strong>推导21.1：球面距离与余弦相似度</strong></p>
<p>单位球面上两点$\hat{\boldsymbol{q}}, \hat{\boldsymbol{k}}$的测地线距离为：<br />
$$<br />
d(\hat{\boldsymbol{q}}, \hat{\boldsymbol{k}}) = \arccos(\hat{\boldsymbol{q}} \cdot \hat{\boldsymbol{k}})<br />
$$</p>
<p>Taylor展开：<br />
$$<br />
\hat{\boldsymbol{q}} \cdot \hat{\boldsymbol{k}} = \cos d = 1 - \frac{d^2}{2} + O(d^4)<br />
$$</p>
<p>当两向量接近时：<br />
$$<br />
\hat{\boldsymbol{q}} \cdot \hat{\boldsymbol{k}} \approx 1 - \frac{d^2}{2}<br />
$$</p>
<p>因此余弦相似度近似反映了球面距离的平方。</p>
<p><strong>几何视角21.2：RoPE的旋转群作用</strong></p>
<p>RoPE在球面上施加旋转群$SO(d)$的作用：<br />
$$<br />
\hat{\boldsymbol{k}}_n \mapsto \boldsymbol{\mathcal{R}}_n \hat{\boldsymbol{k}}_n<br />
$$</p>
<p>由于旋转保持内积：<br />
$$<br />
(\boldsymbol{\mathcal{R}}<em n-m="n-m">m \hat{\boldsymbol{q}}) \cdot (\boldsymbol{\mathcal{R}}_n \hat{\boldsymbol{k}}) = \hat{\boldsymbol{q}} \cdot (\boldsymbol{\mathcal{R}}</em>)} \hat{\boldsymbol{k}<br />
$$</p>
<p>这在球面上实现了相对位置编码。</p>
<h3 id="22-key">22. 信息论视角下的Key归一化<a class="toc-link" href="#22-key" title="Permanent link">&para;</a></h3>
<p><strong>定义22.1：注意力的信息容量</strong></p>
<p>位置$i$的注意力分布${\alpha_{ij}}$的信息容量（负熵）为：<br />
$$<br />
C_i = \max_{p} I(Y; X) = H(Y) - H(Y|X) = H(Y)<br />
$$</p>
<p>其中$Y$是选择的位置，$X$是给定的Query。</p>
<p><strong>定理22.1：KNA最大化位置信息</strong></p>
<p>由于KNA消除了Key模长的影响，所有位置"平等竞争"，位置选择的熵接近最大：<br />
$$<br />
H_i^{KNA} \approx \log i<br />
$$</p>
<p>相比之下，标准Attention可能出现某些位置因模长过大而"垄断"注意力，降低熵。</p>
<p><strong>推导22.1：互信息的分解</strong></p>
<p>注意力分布与位置的互信息：<br />
$$<br />
I(\alpha; \Delta) = H(\alpha) - H(\alpha | \Delta)<br />
$$</p>
<p>其中$\Delta = n - m$是相对位置。</p>
<p>KNA强制$|\boldsymbol{k}_j| = 1$，使得$H(\alpha | \Delta)$最小化（给定相对位置，注意力确定性最强），从而最大化互信息$I(\alpha; \Delta)$。</p>
<p>这意味着KNA让注意力分布与相对位置的关系最紧密，有助于学习位置模式。</p>
<h3 id="23">23. 训练动态与收敛性<a class="toc-link" href="#23" title="Permanent link">&para;</a></h3>
<p><strong>定义23.1：训练损失的Lipschitz平滑性</strong></p>
<p>如果损失函数$\mathcal{L}(\theta)$满足：<br />
$$<br />
|\nabla \mathcal{L}(\theta_1) - \nabla \mathcal{L}(\theta_2)| \leq L |\theta_1 - \theta_2|<br />
$$</p>
<p>则称$\mathcal{L}$是$L$-Lipschitz平滑的。</p>
<p><strong>定理23.1：KNA提升训练平滑性</strong></p>
<p>由于KNA限制了注意力分数的范围，损失函数的Lipschitz常数$L$减小，训练更平滑。</p>
<p><strong>推导23.1：注意力分数对参数的二阶导数</strong></p>
<p>$$<br />
\frac{\partial^2 s_{KNA}}{\partial \theta^2} = \frac{\partial}{\partial \theta} \left(\frac{\partial s_{KNA}}{\partial \theta}\right)<br />
$$</p>
<p>由于$s_{KNA}$有界，其二阶导数也有界，保证了损失函数的平滑性。</p>
<p><strong>定理23.2：KNA的收敛保证</strong></p>
<p>在平滑损失下，梯度下降的收敛率为：<br />
$$<br />
\mathcal{L}(\theta_T) - \mathcal{L}(\theta^<em>) \leq \frac{L |\theta_0 - \theta^</em>|^2}{2T}<br />
$$</p>
<p>其中$T$是迭代次数，$\theta^*$是最优解。</p>
<p>KNA的较小Lipschitz常数$L$意味着更快的收敛速度。</p>
<h3 id="24">24. 泛化理论<a class="toc-link" href="#24" title="Permanent link">&para;</a></h3>
<p><strong>定义24.1：泛化误差</strong></p>
<p>$$<br />
\mathcal{E}<em _mathcal_D="\mathcal{D" _sim="\sim" _x_y_="(x,y)">{gen} = \mathbb{E}</em><em _mathcal_D="\mathcal{D" _sim="\sim" _x_y_="(x,y)">{test}}[\mathcal{L}(f(x), y)] - \mathbb{E}</em>(f(x), y)]}_{train}}[\mathcal{L<br />
$$</p>
<p><strong>定理24.1：KNA减小Rademacher复杂度</strong></p>
<p>模型的Rademacher复杂度为：<br />
$$<br />
\mathcal{R}(\mathcal{F}) = \mathbb{E}<em _in="\in" _mathcal_F="\mathcal{F" f="f">{\sigma} \sup</em>^n \sigma_i f(x_i)}} \frac{1}{n} \sum_{i=1<br />
$$</p>
<p>KNA通过限制Key的范数，减小了函数类$\mathcal{F}$的复杂度，从而减小$\mathcal{R}(\mathcal{F})$。</p>
<p><strong>推导24.1：泛化界</strong></p>
<p>根据Rademacher复杂度理论，泛化误差有界：<br />
$$<br />
\mathcal{E}_{gen} \leq 2\mathcal{R}(\mathcal{F}) + \sqrt{\frac{\log(1/\delta)}{2n}}<br />
$$</p>
<p>其中$n$是训练样本数，$\delta$是置信度。</p>
<p>KNA的较小$\mathcal{R}(\mathcal{F})$导致更小的泛化界。</p>
<h3 id="25">25. 位置编码的傅里叶分析<a class="toc-link" href="#25" title="Permanent link">&para;</a></h3>
<p><strong>定理25.1：RoPE的频谱特性</strong></p>
<p>RoPE可以看作傅里叶变换的一种形式：<br />
$$<br />
e^{i n \theta_k} = \cos(n\theta_k) + i\sin(n\theta_k)<br />
$$</p>
<p>不同的$\theta_k = 10000^{-2k/d}$对应不同的频率。</p>
<p><strong>推导25.1：高频与低频的位置分辨率</strong></p>
<p>对于$\theta_k = 10000^{-2k/d}$：<br />
- 当$k \to 0$（高频）：$\theta_k \to 1$，周期$T_k = 2\pi / \theta_k \approx 6.28$<br />
- 当$k \to d/2$（低频）：$\theta_k \to 10000^{-1}$，周期$T_k \approx 62800$</p>
<p>高频成分能够分辨短距离的相对位置，低频成分能够分辨长距离的相对位置。</p>
<p><strong>推导25.2：KNA与频谱的交互</strong></p>
<p>KNA不改变RoPE的频谱结构，只是消除了Key模长的影响。因此：<br />
$$<br />
s_{KNA}(n-m) = |\boldsymbol{q}<em k="0">m| \text{Re}\left[\sum</em>\right]}^{d/2-1} q_k^* k_k e^{i(n-m)\theta_k<br />
$$</p>
<p>其中$q_k, k_k$是Query和Key的频域系数（归一化后）。</p>
<p>这保留了RoPE的多尺度位置感知能力。</p>
<h3 id="26">26. 实践建议与超参数设置<a class="toc-link" href="#26" title="Permanent link">&para;</a></h3>
<p><strong>建议26.1：Key归一化的实现</strong></p>
<pre class="highlight"><code class="language-python"># 伪代码
k_norm = k / torch.norm(k, dim=-1, keepdim=True)
scores = torch.matmul(q, k_norm.transpose(-2, -1))
</code></pre>

<p>注意：<br />
1. 归一化在最后一维（head_dim）进行<br />
2. 使用<code>keepdim=True</code>保持维度一致<br />
3. 数值稳定性：可以加上小常数$\epsilon$防止除零</p>
<p><strong>建议26.2：是否同时归一化Query</strong></p>
<p>实验表明：<br />
- 只归一化Key（KNA）：最佳长度外推效果<br />
- 同时归一化Query和Key（CosA）：效果接近KNA，但需要调整温度参数<br />
- 只归一化Query（QNA）：无长度外推效果</p>
<p>推荐：<br />
- 如果不想调温度参数，使用KNA<br />
- 如果能精细调参，CosA可能略优</p>
<p><strong>建议26.3：与RoPE的结合</strong></p>
<p>KNA必须与RoPE结合使用才能体现长度外推效果：<br />
- KNA + RoPE：显著外推效果<br />
- KNA + NoPE：无外推效果<br />
- KNA + ALIBI：未充分测试，理论上有冲突</p>
<h3 id="27">27. 注意力矩阵的秩分析<a class="toc-link" href="#27" title="Permanent link">&para;</a></h3>
<p><strong>定义27.1：注意力矩阵</strong></p>
<p>$$<br />
\boldsymbol{A} \in \mathbb{R}^{n \times n}, \quad A_{ij} = \alpha_{ij}<br />
$$</p>
<p><strong>定理27.1：KNA保持注意力矩阵的秩</strong></p>
<p>标准Attention中，如果某些Key的模长过大，可能导致注意力矩阵退化为低秩：<br />
$$<br />
\text{rank}(\boldsymbol{A}) \ll n<br />
$$</p>
<p>KNA通过归一化保持各位置的竞争力，维持较高的秩：<br />
$$<br />
\text{rank}(\boldsymbol{A}_{KNA}) \approx n<br />
$$</p>
<p><strong>推导27.1：低秩退化的机制</strong></p>
<p>如果$|\boldsymbol{k}<em i="i" j_="j^*">{j^<em>}| \gg |\boldsymbol{k}_j|$ for $j \neq j^</em>$，则：<br />
$$<br />
\alpha</em> \approx 0, \quad \forall i} \approx 1, \quad \alpha_{ij<br />
$$</p>
<p>注意力矩阵近似为：<br />
$$<br />
\boldsymbol{A} \approx \boldsymbol{1} \boldsymbol{e}_{j^*}^T<br />
$$</p>
<p>这是秩1矩阵。</p>
<p>KNA消除了这种退化的可能性。</p>
<h3 id="28">28. 长度外推的必要条件<a class="toc-link" href="#28" title="Permanent link">&para;</a></h3>
<p><strong>定理28.1：成功长度外推的三要素</strong></p>
<ol>
<li><strong>相对位置编码</strong>：必须使用RoPE等相对位置编码，绝对位置编码无法外推</li>
<li><strong>充分的角度训练</strong>：$\cos(\boldsymbol{q}_i, \boldsymbol{k}_j)$必须在训练中充分优化</li>
<li><strong>数值稳定性</strong>：注意力分数不能过大，避免softmax饱和</li>
</ol>
<p><strong>推导28.1：为何绝对位置编码无法外推</strong></p>
<p>绝对位置编码：<br />
$$<br />
\boldsymbol{q}_m = \boldsymbol{W}_Q (\boldsymbol{x}_m + \boldsymbol{p}_m)<br />
$$</p>
<p>其中$\boldsymbol{p}_m$是位置$m$的嵌入。</p>
<p>当$m &gt; L_{train}$时，$\boldsymbol{p}_m$从未见过，模型无法泛化。</p>
<p>相对位置编码：<br />
$$<br />
\boldsymbol{q}_m^T \boldsymbol{k}_n = f(m - n)<br />
$$</p>
<p>只要相对位置$m - n$的模式在训练中学到，就能外推。</p>
<p><strong>推导28.2：KNA满足所有三要素</strong></p>
<ol>
<li>✓ 与RoPE配合，保留相对位置编码</li>
<li>✓ 强制模型充分训练$\cos$</li>
<li>✓ 归一化保证数值稳定性</li>
</ol>
<p>因此KNA能够成功实现长度外推。</p>
<h3 id="29-transformer">29. 与Transformer架构变体的兼容性<a class="toc-link" href="#29-transformer" title="Permanent link">&para;</a></h3>
<p><strong>兼容性29.1：GAU (Gated Attention Unit)</strong></p>
<p>GAU使用单头注意力：<br />
$$<br />
\boldsymbol{o} = (\boldsymbol{Z} \odot \text{Attention}(\boldsymbol{U})) \boldsymbol{V}<br />
$$</p>
<p>KNA可以直接应用于GAU的注意力部分，实验表明效果显著。</p>
<p><strong>兼容性29.2：Multi-Query Attention (MQA)</strong></p>
<p>MQA中所有Query头共享同一组Key和Value：<br />
$$<br />
\boldsymbol{K} = \boldsymbol{W}_K \boldsymbol{X}, \quad \text{所有头共享}<br />
$$</p>
<p>Key归一化仍然有效：<br />
$$<br />
\tilde{\boldsymbol{K}} = \boldsymbol{K} / |\boldsymbol{K}|_{\text{row}}<br />
$$</p>
<p><strong>兼容性29.3：Grouped-Query Attention (GQA)</strong></p>
<p>GQA是MQA的泛化，多个Query头共享一组Key-Value。KNA同样适用。</p>
<h3 id="30">30. 总结与展望<a class="toc-link" href="#30" title="Permanent link">&para;</a></h3>
<p><strong>总结30.1：Key归一化的核心洞察</strong></p>
<p>Key归一化通过一个简单的操作——将Key向量归一化到单位球面——实现了显著的长度外推效果。其核心机制是：</p>
<ol>
<li><strong>消除捷径</strong>：去除Key模长这一"简单路径"，强制模型优化更本质的角度信息</li>
<li><strong>充分训练</strong>：使$\cos(\boldsymbol{q}_i, \boldsymbol{k}_j)$得到充分训练，增强泛化能力</li>
<li><strong>数值稳定</strong>：有界的注意力分数保证训练和推理的稳定性</li>
<li><strong>保持恒等</strong>：推理时无需修改，在训练长度内保持原始性能</li>
</ol>
<p><strong>展望30.2：未来研究方向</strong></p>
<ol>
<li><strong>理论完善</strong>：进一步建立Key归一化与长度外推的严格理论联系</li>
<li><strong>大规模验证</strong>：在更大规模的LLM上验证效果（数十亿、千亿参数）</li>
<li><strong>多模态扩展</strong>：将KNA应用于视觉、音频等多模态场景</li>
<li><strong>优化算法</strong>：设计针对KNA的专用优化算法</li>
<li><strong>硬件加速</strong>：开发针对归一化操作的高效硬件实现</li>
</ol>
<p><strong>理论意义</strong>：Key归一化揭示了Attention机制中模长与方向的不同作用，为理解和改进Transformer提供了新视角。</p>
<p><strong>实践价值</strong>：作为一个简单、有效、易于实现的方法，KNA为长文本建模提供了新的工具，特别适合资源有限但需要长度外推的场景。</p>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="生活杂记炒锅的尽头是铁锅.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#118 【生活杂记】炒锅的尽头是铁锅</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="我在performer中发现了transformer-vq的踪迹.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#120 我在Performer中发现了Transformer-VQ的踪迹</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#transformer15key">Transformer升级之路：15、Key归一化助力长度外推</a><ul>
<li><a href="#_1">最初动机</a></li>
<li><a href="#_2">先看结果</a></li>
<li><a href="#_3">原理分析</a></li>
<li><a href="#_4">文章小结</a></li>
<li><a href="#_5">公式推导与注释</a><ul>
<li><a href="#1-key">1. Key归一化的数学基础</a></li>
<li><a href="#2">2. 向量模长的统计性质</a></li>
<li><a href="#3-key-normalization">3. Key Normalization的数学定义</a></li>
<li><a href="#4-query-key">4. Query-Key内积的几何分解</a></li>
<li><a href="#5-key">5. Key归一化对注意力分布的影响</a></li>
<li><a href="#6">6. 维度灾难与角度调整的困难</a></li>
<li><a href="#7">7. 长度外推与位置编码的训练充分性</a></li>
<li><a href="#8-ropekey">8. RoPE与Key归一化的协同作用</a></li>
<li><a href="#9-cosine-attention">9. Cosine Attention的数学表示</a></li>
<li><a href="#10">10. 温度参数的自适应调整</a></li>
<li><a href="#11-layernorml2-normalization">11. LayerNorm与L2 Normalization的对比</a></li>
<li><a href="#12">12. 长度外推的稳定性分析</a></li>
<li><a href="#13">13. 相对位置的外推误差界</a></li>
<li><a href="#14">14. 注意力熵与长度外推的关系</a></li>
<li><a href="#15-query-normalization">15. Query Normalization的对比实验</a></li>
<li><a href="#16-key">16. 多头注意力中的Key归一化</a></li>
<li><a href="#17">17. 训练稳定性的理论分析</a></li>
<li><a href="#18">18. 长度外推的实证分析</a></li>
<li><a href="#19">19. 计算复杂度分析</a></li>
<li><a href="#20">20. 与其他位置编码方案的比较</a></li>
<li><a href="#21-key">21. Key归一化的几何解释</a></li>
<li><a href="#22-key">22. 信息论视角下的Key归一化</a></li>
<li><a href="#23">23. 训练动态与收敛性</a></li>
<li><a href="#24">24. 泛化理论</a></li>
<li><a href="#25">25. 位置编码的傅里叶分析</a></li>
<li><a href="#26">26. 实践建议与超参数设置</a></li>
<li><a href="#27">27. 注意力矩阵的秩分析</a></li>
<li><a href="#28">28. 长度外推的必要条件</a></li>
<li><a href="#29-transformer">29. 与Transformer架构变体的兼容性</a></li>
<li><a href="#30">30. 总结与展望</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>