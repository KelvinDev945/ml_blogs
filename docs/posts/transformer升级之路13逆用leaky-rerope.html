<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer升级之路：13、逆用Leaky ReRoPE | ML & Math Blog Posts</title>
    <meta name="description" content="Transformer升级之路：13、逆用Leaky ReRoPE&para;
原文链接: https://spaces.ac.cn/archives/9728
发布日期: 

上周在《Transformer升级之路：12、无限外推的ReRoPE？》中，笔者提出了ReRoPE和Leaky ReRoPE，诸多实验结果表明，它们能够在几乎不损失训练效果的情况下免微调地扩展LLM的Context长度，并...">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css">

    <!-- Google Fonts -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/main.css">
    <link rel="stylesheet" href="../assets/css/post.css">

    <!-- Custom JS -->
    <script src="../assets/js/collapsible.js" defer></script>

    <!-- MathJax for math rendering with equation numbering -->
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        tags: 'ams',  // Enable equation numbering with AMS style
        tagSide: 'right',  // Place equation numbers on the right
        tagIndent: '0.8em',  // Indentation for equation numbers
        multlineWidth: '85%'
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/github.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/highlight.min.js"></script>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
        <div class="container">
            <a class="navbar-brand" href="../index.html">
                <i class="fas fa-brain"></i> ML & Math Blog
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html"><i class="fas fa-home"></i> 首页</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Post Content -->
    <article class="container post-container my-5">
        <!-- Breadcrumb Navigation -->
        <nav aria-label="breadcrumb">
            <ol class="breadcrumb">
                <li class="breadcrumb-item"><a href="../index.html"><i class="fas fa-home"></i> 首页</a></li>
                
                <li class="breadcrumb-item"><a href="../index.html?tags=详细推导">详细推导</a></li>
                
                <li class="breadcrumb-item active" aria-current="page">
                    #98 Transformer升级之路：13、逆用Leaky ReRoPE
                </li>
            </ol>
        </nav>

        <!-- Post Header -->
        <header class="post-header mb-4">
            <h1 class="post-title">
                <span class="post-number">#98</span>
                Transformer升级之路：13、逆用Leaky ReRoPE
            </h1>
            <div class="post-meta">
                <span><i class="far fa-calendar"></i> 2023-08-14</span>
                
            </div>
            
            <div class="post-tags mt-3">
                
                <a href="../index.html?tags=详细推导" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 详细推导</span>
                </a>
                
                <a href="../index.html?tags=attention" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> attention</span>
                </a>
                
                <a href="../index.html?tags=位置编码" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 位置编码</span>
                </a>
                
                <a href="../index.html?tags=泛化" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 泛化</span>
                </a>
                
                <a href="../index.html?tags=外推" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> 外推</span>
                </a>
                
                <a href="../index.html?tags=rope" class="tag-link">
                    <span class="tag"><i class="fas fa-tag"></i> rope</span>
                </a>
                
            </div>
            
        </header>

        <div class="row">
            <!-- Main Content -->
            <div class="col-lg-9">
                <!-- Post Body -->
                <div class="post-content">
                    <h1 id="transformer13leaky-rerope">Transformer升级之路：13、逆用Leaky ReRoPE<a class="toc-link" href="#transformer13leaky-rerope" title="Permanent link">&para;</a></h1>
<p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/9728">https://spaces.ac.cn/archives/9728</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>上周在<a href="/archives/9708">《Transformer升级之路：12、无限外推的ReRoPE？》</a>中，笔者提出了ReRoPE和Leaky ReRoPE，诸多实验结果表明，它们能够在几乎不损失训练效果的情况下免微调地扩展LLM的Context长度，并且实现了“longer context, lower loss”的理想特性，此外跟NTK-aware Scaled RoPE不同的是，其中ReRoPE似乎还有表现出了无限的Context处理能力。</p>
<p>总之，ReRoPE看起来相当让人满意，但美中不足的是会增加推理成本，具体表现为第一步推理需要算两次Attention，以及后续每步推理需要重新计算位置编码。本文试图通过在训练中逆用Leaky ReRoPE的方法来解决这个问题。</p>
<h2 id="_1">回顾<a class="toc-link" href="#_1" title="Permanent link">&para;</a></h2>
<p>让我们不厌其烦地重温一下：RoPE形式上是一种绝对位置编码，但实际达到的效果是相对位置编码，对应的相对位置矩阵是：<br />
\begin{equation}\begin{pmatrix}0 &amp; \\
1 &amp; 0 &amp; \\
2 &amp; 1 &amp; 0 &amp;\\
3 &amp; 2 &amp; 1 &amp; 0 &amp; \\
\ddots &amp; 3 &amp; 2 &amp; 1 &amp; 0 &amp; \\
\ddots &amp; \ddots &amp; 3 &amp; 2 &amp; 1 &amp; 0 &amp; \\
\ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots \\
\small{L - 2} &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots \\
\small{L - 1} &amp; \small{L - 2} &amp; \ddots &amp; \ddots &amp; \ddots &amp; 3 &amp; 2 &amp; 1 &amp; 0 &amp; \\
\end{pmatrix}\label{eq:rope}\end{equation}<br />
为了在保留局域性的同时避免Long Context导致位置越界问题，Leaky ReRoPE将推理阶段的相对位置矩阵改为：<br />
\begin{equation}\begin{pmatrix}
\color{red}{0} &amp; \\
\color{red}{1} &amp; \color{red}{0} &amp; \\
\color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{red}{\small{w - 1}} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{w} &amp; \color{red}{\small{w - 1}} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{\small{w + \frac{1}{k}}} &amp; \color{green}{w} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{\small{w + \frac{2}{k}}} &amp; \color{green}{\small{w + \frac{1}{k}}} &amp; \color{green}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{\ddots} &amp; \color{green}{\small{w + \frac{2}{k}}} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \\
\color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\small{w + \frac{2}{k}}} &amp; \color{green}{\small{w + \frac{1}{k}}} &amp; \color{green}{w} &amp; \color{red}{\small{w - 1}} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{\small{w + \frac{L-1-w}{k}}} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\small{w + \frac{2}{k}}} &amp; \color{green}{\small{w + \frac{1}{k}}} &amp; \color{green}{w} &amp; \color{red}{\small{w - 1}} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\end{pmatrix}\label{eq:leaky-rerope}\end{equation}<br />
其中$w$是窗口宽度，大概取训练长度的$\frac{1}{4}$到$\frac{1}{2}$，$k$用来调节可处理的最大长度，一般使得$w + \frac{L-1-w}{k}$不超过训练长度的一半为佳。至于ReRoPE，则是直接取了$k\to\infty$的极限：<br />
\begin{equation}\begin{pmatrix}
\color{red}{0} &amp; \\
\color{red}{1} &amp; \color{red}{0} &amp; \\
\color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{red}{\small{w - 1}} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{w} &amp; \color{red}{\small{w - 1}} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{w} &amp; \color{green}{w} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{w} &amp; \color{green}{w} &amp; \color{green}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{\ddots} &amp; \color{green}{w} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \color{red}{\ddots} &amp; \\
\color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{w} &amp; \color{green}{w} &amp; \color{green}{w} &amp; \color{red}{\small{w - 1}} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\color{green}{w} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{\ddots} &amp; \color{green}{w} &amp; \color{green}{w} &amp; \color{green}{w} &amp; \color{red}{\small{w - 1}} &amp; \color{red}{\ddots} &amp; \color{red}{2} &amp; \color{red}{1} &amp; \color{red}{0} &amp; \\
\end{pmatrix}\label{eq:rerope}\end{equation}</p>
<h2 id="_2">反转<a class="toc-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>从上一篇的评测结果来看，作为一种免训练的外推方案，ReRoPE和Leaky ReRoPE的效果都是相当让人满意的，既没有损失训练长度内的效果，又实现了“Longer Context, Lower Loss”。唯一美中不足的是，它们的推理速度相比原本的Attention来说是变慢的，并且目前尚不兼容Flash Attention等加速技术。</p>
<p>那么，能否反过来呢？ReRoPE/Leaky ReRoPE在训练阶段是正常速度的RoPE，推理阶段则是变慢了，反过来也就是说：能否让训练阶段变慢，让推理阶段变为常规的RoPE？可能有读者疑惑：为什么会想要让训练阶段变慢？训练成本不是更高吗？这是因为ReRoPE/Leaky ReRoPE是一种长度外推方法，场景是“Train Short, Test Long”，训练速度的变慢是短期的、可控的，推理速度的变慢才是长期的、难顶的，所以相较之下，如果是同等程度的变慢的话，我们更愿意将变慢的部分放到训练阶段。</p>
<p>让我们再看一下Leaky ReRoPE，它在训练阶段的相对位置矩阵是步长为1的式$\eqref{eq:rope}$，推理阶段则在$w$的窗口内使用$1$的步长，在窗口外使用$\frac{1}{k} &lt; 1$的步长，即式$\eqref{eq:leaky-rerope}$，换句话说， <em>差别是推理阶段窗口外使用更小的步长</em> 。如果我们反过来，在训练阶段使用Leaky ReRoPE，并让它窗口外的步长大于$1$，那么按照“推理阶段窗口外使用更小的步长”的原则，推理阶段窗口外是否就可以使用等于$1$的步长，从而退化为RoPE了？</p>
<p>笔者将以上想法称之为“InvLeaky ReRoPE（Inverse Leaky ReRoPE）”。事不宜迟，我们马上做实验测试。</p>
<h2 id="_3">实验<a class="toc-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>继续之前的“<a href="/archives/8934">GAU</a> + <a href="/archives/8978">Deep Norm</a> + <a href="/archives/9512">Tiger</a> + 语言模型”实验组合，在训练阶段使用$k=1/16, w=128$的Leaky ReRoPE，在推理阶段使用正常的RoPE，测试结果如下：</p>
<p>\begin{array}{c|cc}
\hline
\text{测试长度} &amp; 512(\text{训练}) &amp; 4096(\text{重复}) &amp; 4096(\text{不重复})\\
\hline
\text{Baseline} &amp; 49.41\% &amp; 24.17\% &amp; 23.16\% \\
\text{Baseline-}\log n &amp; 49.40\% &amp; 24.60\% &amp; 24.02\% \\
\hline
\text{NTK-RoPE-fixed} &amp; 49.41\% &amp; 51.86\% &amp; 39.61\% \\
\text{NTK-RoPE-}\log n^{\color{red}{\dagger}}\text{-fixed} &amp; 49.41\% &amp; 55.94\% &amp; 41.11\% \\
\text{NTK-RoPE-}\log n\text{-fixed} &amp; 49.40\% &amp; 62.85\% &amp; 44.14\% \\
\text{NTK-RoPE-mixed} &amp; 49.41\% &amp; 53.09\% &amp; 40.12\% \\
\text{NTK-RoPE-}\log n^{\color{red}{\dagger}}\text{-mixed} &amp; 49.41\% &amp; 59.11\% &amp; 42.38\% \\
\text{NTK-RoPE-}\log n\text{-mixed} &amp; 49.40\% &amp; 68.91\% &amp; 45.41\% \\
\hline
\text{ReRoPE-w256} &amp; 49.41\% &amp; 77.90\% &amp; 48.48\% \\
\text{ReRoPE-w256-}\log n^{\color{red}{\dagger}} &amp; 49.41\% &amp; 82.40\% &amp; 48.85\% \\
\text{ReRoPE-w256-}\log n &amp; 49.40\% &amp; \boldsymbol{85.12\%} &amp; \boldsymbol{49.07\%} \\
\hline
\text{InvLeaky ReRoPE-w128-}\log n &amp; 49.38\% &amp; 82.25\% &amp; 48.32\% \\
\text{InvLeaky ReRoPE-w128-b8-}\log n &amp; 49.62\% &amp; 81.15\% &amp; 48.85\% \\
\hline
\text{HFWA} &amp; 48.70\% &amp; 80.84\% &amp; 48.15\% \\
\hline
\end{array}</p>
<p>其中$\text{b8}$是指RoPE的频率底数从10000换成了80000。可以看到，“Leaky ReRoPE → RoPE”的InvLeaky ReRoPE虽然效果上不如“RoPE → ReRoPE/Leaky ReRoPE”，但依然胜过了HFWA，并且由于推理阶段是常规的RoPE，可以套用现成的加速技术，因此依然是有相当竞争力的。此外，笔者对$k,w,b$等参数做了一些简单的调参，发现最优解基本上就是以上两个组合了，即“$k$设置为‘扩展倍数的2倍的倒数’、$w$设置为训练长度的$\frac{1}{4}$、$b$可选乘以扩展倍数”。</p>
<p>那么，InvLeaky ReRoPE对训练速度有多大影响呢？在上述实验中，模型是1亿参数量，训练长度是512，每1000步的训练时间从330秒增加到了350秒，增加不到10%，当然这里边有GAU的原因，因为GAU是单头的注意力，本就比多头注意力快。如果多头注意力或者训练长度更长的话，增加幅度应该会大一些，但目测应该不超过50%都是可以接受的。</p>
<h2 id="_4">小结<a class="toc-link" href="#_4" title="Permanent link">&para;</a></h2>
<p>本文提出了Leaky ReRoPE的“逆用”做法，通过在训练阶段使用更大步长的Leaky ReRoPE，使得推理阶段可以退回常规的RoPE，从而可以保持推理速度不变，实验结果显示这种做法还是有一定的竞争力的。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/9728">https://spaces.ac.cn/archives/9728</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Aug. 14, 2023). 《Transformer升级之路：13、逆用Leaky ReRoPE 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/9728">https://spaces.ac.cn/archives/9728</a></p>
<p>@online{kexuefm-9728,<br />
title={Transformer升级之路：13、逆用Leaky ReRoPE},<br />
author={苏剑林},<br />
year={2023},<br />
month={Aug},<br />
url={\url{https://spaces.ac.cn/archives/9728}},<br />
} </p>
<hr />
<h2 id="_5">公式推导与注释<a class="toc-link" href="#_5" title="Permanent link">&para;</a></h2>
<h3 id="1-leaky-rerope">1. Leaky ReRoPE的泄漏机制数学基础<a class="toc-link" href="#1-leaky-rerope" title="Permanent link">&para;</a></h3>
<p><strong>定义1.1（泄漏系数）</strong></p>
<p>Leaky ReRoPE的核心参数是泄漏系数$k &gt; 1$，它控制窗口外相对位置的压缩程度。对于相对位置$m \geq w$，泄漏函数定义为：</p>
<p>$$g(m; k) = \frac{m - w}{k}$$</p>
<p>这表示窗口外的位置以$1/k$的速率增长，相比窗口内的单位速率慢了$k$倍。</p>
<p><strong>推导1.2（Leaky ReRoPE的完整形式）</strong></p>
<p>完整的Leaky ReRoPE相对位置函数为：</p>
<p>$$f_{\text{Leaky}}(m; w, k) = \begin{cases}
m, &amp; 0 \leq m &lt; w \
w + \frac{m - w}{k}, &amp; m \geq w
\end{cases}$$</p>
<p>展开第二个分支：</p>
<p>$$f_{\text{Leaky}}(m; w, k) = w + \frac{m - w}{k} = w\left(1 - \frac{1}{k}\right) + \frac{m}{k} = w \cdot \frac{k-1}{k} + \frac{m}{k}$$</p>
<p>当$m \to \infty$时：</p>
<p>$$f_{\text{Leaky}}(m; w, k) \sim \frac{m}{k}$$</p>
<p>这表明远距离位置的有效相对位置与位置内插类似，但保留了窗口内的完整信息。</p>
<p><strong>定理1.3（泄漏机制的连续性与可导性）</strong></p>
<p>Leaky ReRoPE在整个定义域上连续，在$m \neq w$处可导。</p>
<p><strong>证明</strong>：</p>
<p><strong>连续性</strong>：在$m = w$处：</p>
<p>$$\lim_{m \to w^-} f_{\text{Leaky}}(m; w, k) = w$$</p>
<p>$$\lim_{m \to w^+} f_{\text{Leaky}}(m; w, k) = w + \frac{w - w}{k} = w$$</p>
<p>$$f_{\text{Leaky}}(w; w, k) = w$$</p>
<p>因此在$m = w$处连续。</p>
<p><strong>可导性</strong>：</p>
<ul>
<li>当$m &lt; w$时：$f'(m) = 1$</li>
<li>当$m &gt; w$时：$f'(m) = 1/k$</li>
</ul>
<p>在$m = w$处，左导数为1，右导数为$1/k$，因此不可导。但分段可导足以保证训练稳定性。</p>
<p><strong>推导1.4（泄漏率的物理意义）</strong></p>
<p>定义泄漏率为窗口外相对于窗口内的位置增长比：</p>
<p>$$\rho = \frac{f'(m &gt; w)}{f'(m &lt; w)} = \frac{1/k}{1} = \frac{1}{k}$$</p>
<p>当$k = 16$时，$\rho = 1/16 = 0.0625$，意味着窗口外的位置编码增长速度仅为窗口内的6.25%。这种强烈的压缩使得模型可以在有限的位置编码范围内表示非常长的序列。</p>
<h3 id="2">2. 窗口边界的平滑处理<a class="toc-link" href="#2" title="Permanent link">&para;</a></h3>
<p><strong>定义2.1（平滑窗口函数）</strong></p>
<p>为了避免在$m = w$处的不可导问题，可以引入平滑窗口函数。定义平滑参数$\sigma &gt; 0$，平滑Leaky ReRoPE为：</p>
<p>$$f_{\text{smooth}}(m; w, k, \sigma) = \begin{cases}
m, &amp; m \leq w - \sigma \
h(m; w, k, \sigma), &amp; w - \sigma &lt; m &lt; w + \sigma \
w + \frac{m - w}{k}, &amp; m \geq w + \sigma
\end{cases}$$</p>
<p>其中$h$是过渡函数，需要满足：</p>
<ol>
<li>$h(w - \sigma) = w - \sigma$</li>
<li>$h(w + \sigma) = w + \sigma/k$</li>
<li>$h'(w - \sigma) = 1$</li>
<li>$h'(w + \sigma) = 1/k$</li>
</ol>
<p><strong>推导2.2（三次样条过渡函数）</strong></p>
<p>使用三次Hermite样条作为过渡函数。设$t = (m - (w - \sigma))/(2\sigma) \in [0, 1]$，则：</p>
<p>$$h(m) = (1 - t)^2(1 + 2t) \cdot (w - \sigma) + t^2(3 - 2t) \cdot \left(w + \frac{\sigma}{k}\right) + (1 - t)^2 t \cdot 2\sigma \cdot 1 + t^2(t - 1) \cdot 2\sigma \cdot \frac{1}{k}$$</p>
<p>简化后：</p>
<p>$$h(m) = a_0 + a_1 t + a_2 t^2 + a_3 t^3$$</p>
<p>其中系数$a_i$由边界条件确定。</p>
<p><strong>定理2.3（平滑窗口的梯度有界性）</strong></p>
<p>对于平滑Leaky ReRoPE，其导数在整个定义域上有界：</p>
<p>$$\frac{1}{k} \leq f'_{\text{smooth}}(m) \leq 1, \quad \forall m$$</p>
<p><strong>证明</strong>：</p>
<ul>
<li>在$m &lt; w - \sigma$时：$f'_{\text{smooth}} = 1$</li>
<li>在$m &gt; w + \sigma$时：$f'_{\text{smooth}} = 1/k$</li>
<li>在过渡区间$[w - \sigma, w + \sigma]$内，由三次样条的性质，导数从1平滑过渡到$1/k$</li>
</ul>
<p>因此导数始终在$[1/k, 1]$范围内。</p>
<p><strong>推导2.4（平滑参数的选择）</strong></p>
<p>平滑参数$\sigma$应该选择为窗口大小的一小部分，典型值为：</p>
<p>$$\sigma = \alpha w, \quad \alpha \in [0.01, 0.1]$$</p>
<p>例如，当$w = 128$，$\alpha = 0.05$时，$\sigma = 6.4$，过渡区间为$[121.6, 134.4]$，仅占窗口的约10%。</p>
<h3 id="3">3. 逆向应用的数学原理<a class="toc-link" href="#3" title="Permanent link">&para;</a></h3>
<p><strong>定义3.1（正向与逆向Leaky ReRoPE）</strong></p>
<p><strong>正向应用</strong>（推理时使用，如原始ReRoPE/Leaky ReRoPE）：训练时使用标准RoPE，推理时使用Leaky ReRoPE，窗口外使用$k &gt; 1$进行压缩。</p>
<p><strong>逆向应用</strong>（InvLeaky ReRoPE）：训练时使用Leaky ReRoPE且$k &lt; 1$（等价于窗口外扩展），推理时使用标准RoPE。</p>
<p><strong>推导3.2（逆向应用的位置编码映射）</strong></p>
<p>对于逆向应用，设训练时的泄漏系数为$k_{\text{train}} = 1/r$，其中$r &gt; 1$是扩展倍数。训练阶段的相对位置函数为：</p>
<p>$$f_{\text{train}}(m; w, r) = \begin{cases}
m, &amp; m &lt; w \
w + r(m - w), &amp; m \geq w
\end{cases}$$</p>
<p>这相当于窗口外的位置以$r$倍速率增长。对于训练长度$L_{\text{train}}$，最大相对位置为：</p>
<p>$$f_{\text{train}}(L_{\text{train}} - 1; w, r) = w + r(L_{\text{train}} - 1 - w) = w(1 - r) + r(L_{\text{train}} - 1)$$</p>
<p><strong>定理3.3（逆向应用的外推覆盖）</strong></p>
<p>如果在训练时使用扩展倍数$r$，那么推理时可以处理的最大长度为：</p>
<p>$$L_{\text{test}}^{\max} = w + r(L_{\text{train}} - w)$$</p>
<p><strong>证明</strong>：训练时见过的最大相对位置为$w + r(L_{\text{train}} - 1 - w) \approx w + r(L_{\text{train}} - w)$。推理时使用标准RoPE，最大相对位置为$L_{\text{test}} - 1$。要避免外推，需要：</p>
<p>$$L_{\text{test}} - 1 \leq w + r(L_{\text{train}} - w)$$</p>
<p>因此：</p>
<p>$$L_{\text{test}} \leq w + r(L_{\text{train}} - w) + 1$$</p>
<p><strong>推导3.4（逆向应用的参数选择）</strong></p>
<p>对于目标扩展倍数$\text{target} = L_{\text{test}}/L_{\text{train}}$，训练时的扩展倍数应选择为：</p>
<p>$$r = \frac{(\text{target} - 1)L_{\text{train}} + w}{L_{\text{train}} - w}$$</p>
<p>例如，$L_{\text{train}} = 512$，$w = 128$，目标扩展到$L_{\text{test}} = 4096$（扩展8倍）：</p>
<p>$$r = \frac{(8 - 1) \times 512 + 128}{512 - 128} = \frac{3584 + 128}{384} = \frac{3712}{384} \approx 9.67$$</p>
<p>但实验中通常直接使用$r = \text{target}$或略小的值。</p>
<h3 id="4">4. 信息流动的定量分析<a class="toc-link" href="#4" title="Permanent link">&para;</a></h3>
<p><strong>定义4.1（位置编码信息流）</strong></p>
<p>定义从位置$j$到位置$i$的位置信息流为：</p>
<p>$$I_{i \to j} = -\log p(\text{attend}_{i \to j})$$</p>
<p>其中$p(\text{attend}_{i \to j})$是位置$i$关注位置$j$的概率，主要由相对位置编码决定。</p>
<p><strong>推导4.2（Leaky ReRoPE的信息流特性）</strong></p>
<p>对于Leaky ReRoPE，Attention分数的位置贡献部分为：</p>
<p>$$s_{\text{pos}}(i, j) = \boldsymbol{q}<em _text_Leaky="\text{Leaky">i^{\top}\boldsymbol{\mathcal{R}}^{f</em>_j$$}}(i-j; w, k)}\boldsymbol{k</p>
<p>定义归一化位置相似度：</p>
<p>$$\text{sim}<em _text_pos="\text{pos">{\text{pos}}(i, j) = \frac{s</em>$$}}(i, j)}{|\boldsymbol{q}_i| |\boldsymbol{k}_j|</p>
<p>对于窗口内（$i - j &lt; w$）：</p>
<p>$$\text{sim}_{\text{pos}}(i, j) \propto \cos((i - j) \theta)$$</p>
<p>对于窗口外（$i - j \geq w$）：</p>
<p>$$\text{sim}_{\text{pos}}(i, j) \propto \cos\left(\left(w + \frac{i - j - w}{k}\right) \theta\right)$$</p>
<p><strong>定理4.3（信息流的衰减率）</strong></p>
<p>在Leaky ReRoPE中，窗口外信息流的衰减率低于标准RoPE。</p>
<p><strong>证明思路</strong>：标准RoPE下，远距离位置的相似度随距离快速振荡并平均衰减。Leaky ReRoPE通过压缩远距离相对位置，减缓了相位变化，从而减缓了信息流衰减。</p>
<p>具体地，对于距离$\Delta = i - j \gg w$：</p>
<p><strong>标准RoPE</strong>：相位为$\Delta \theta$，快速振荡</p>
<p><strong>Leaky ReRoPE</strong>：相位为$(w + \Delta/k) \theta \approx w\theta + \Delta\theta/k$，振荡速度降低$k$倍</p>
<p><strong>推导4.4（逆向应用的信息流增强）</strong></p>
<p>逆向应用（训练时$k &lt; 1$）会增强窗口外的位置区分度。设$k_{\text{train}} = 1/r$，训练时窗口外的相位为：</p>
<p>$$\phi_{\text{train}}(\Delta) = (w + r(\Delta - w))\theta = w\theta(1 - r) + r\Delta\theta$$</p>
<p>相位变化率为$r$，大于标准RoPE的1。这意味着模型在训练时学习了更强的远距离位置区分能力，推理时即使使用标准RoPE也能保持良好性能。</p>
<h3 id="5">5. 梯度传播与训练稳定性<a class="toc-link" href="#5" title="Permanent link">&para;</a></h3>
<p><strong>定义5.1（位置编码梯度）</strong></p>
<p>对于损失函数$\mathcal{L}$，位置编码函数$f(m)$的梯度通过Attention分数传播：</p>
<p>$$\frac{\partial \mathcal{L}}{\partial f(m)} = \sum_{i,j: i-j=m} \frac{\partial \mathcal{L}}{\partial a_{i,j}} \cdot \frac{\partial a_{i,j}}{\partial f(m)}$$</p>
<p>其中$a_{i,j}$是Attention分数。</p>
<p><strong>推导5.2（Leaky ReRoPE的梯度分析）</strong></p>
<p>对于Leaky ReRoPE，位置$m$处的导数为：</p>
<p>$$f'(m; w, k) = \begin{cases}
1, &amp; m &lt; w \
1/k, &amp; m &gt; w
\end{cases}$$</p>
<p>因此梯度为：</p>
<p>$$\frac{\partial \mathcal{L}}{\partial m} = \frac{\partial \mathcal{L}}{\partial f(m)} \cdot f'(m) = \begin{cases}
\frac{\partial \mathcal{L}}{\partial f(m)}, &amp; m &lt; w \
\frac{1}{k} \frac{\partial \mathcal{L}}{\partial f(m)}, &amp; m &gt; w
\end{cases}$$</p>
<p>窗口外的梯度被缩放了$1/k$倍。</p>
<p><strong>定理5.3（梯度缩放的稳定效应）</strong></p>
<p>当$k &gt; 1$（正向应用）时，窗口外梯度的缩小有助于训练稳定性；当$k &lt; 1$（逆向应用）时，窗口外梯度的放大需要额外的正则化。</p>
<p><strong>证明</strong>：</p>
<p><strong>正向应用</strong>（$k &gt; 1$）：窗口外梯度$\times 1/k &lt; 1$，相当于自动梯度裁剪，防止远距离位置的梯度主导训练。</p>
<p><strong>逆向应用</strong>（$k &lt; 1$，即$k_{\text{train}} = 1/r$，$r &gt; 1$）：窗口外梯度$\times r &gt; 1$，梯度被放大。这需要：</p>
<ol>
<li>使用较小的学习率</li>
<li>应用梯度裁剪</li>
<li>增加权重衰减</li>
</ol>
<p><strong>推导5.4（反向传播的链式法则）</strong></p>
<p>考虑多层Transformer，第$\ell$层的梯度为：</p>
<p>$$\frac{\partial \mathcal{L}}{\partial f^{(\ell)}(m)} = \sum_{\ell' &gt; \ell} \frac{\partial \mathcal{L}}{\partial f^{(\ell')}(m')} \cdot \frac{\partial f^{(\ell')}(m')}{\partial f^{(\ell)}(m)}$$</p>
<p>由于Leaky ReRoPE在每层独立应用，梯度传播不会跨层累积位置编码的影响，因此训练稳定性良好。</p>
<p><strong>推导5.5（训练动态的理论分析）</strong></p>
<p>定义训练过程中的有效学习率为：</p>
<p>$$\eta_{\text{eff}}(m) = \eta \cdot |f'(m)|$$</p>
<p>其中$\eta$是基础学习率。</p>
<p>对于逆向Leaky ReRoPE（$k = 1/r$）：</p>
<p>$$\eta_{\text{eff}}(m) = \begin{cases}
\eta, &amp; m &lt; w \
r\eta, &amp; m &gt; w
\end{cases}$$</p>
<p>这意味着窗口外位置的学习速度是窗口内的$r$倍。为了平衡，可以使用位置相关的学习率：</p>
<p>$$\eta(m) = \begin{cases}
\eta_0, &amp; m &lt; w \
\eta_0/r, &amp; m &gt; w
\end{cases}$$</p>
<h3 id="6">6. 参数敏感性分析<a class="toc-link" href="#6" title="Permanent link">&para;</a></h3>
<p><strong>定义6.1（性能关于参数的导数）</strong></p>
<p>定义性能指标（如准确率$A$或负对数似然$-\log p$）关于参数$\theta$的敏感性：</p>
<p>$$S_\theta = \frac{\partial \text{Performance}}{\partial \theta}$$</p>
<p>对于Leaky ReRoPE，主要参数有窗口大小$w$和泄漏系数$k$。</p>
<p><strong>推导6.2（窗口大小$w$的敏感性）</strong></p>
<p>窗口大小$w$影响局部和全局信息的平衡。定义局部信息比例：</p>
<p>$$\alpha_{\text{local}}(w, L) = \frac{#{(i,j): 0 \leq i - j &lt; w}}{#{(i,j): 0 \leq i - j &lt; L}} = \frac{Lw - w^2/2}{L^2/2} \approx \frac{2w}{L}$$</p>
<p>当$w \ll L$时。性能对$w$的导数可近似为：</p>
<p>$$\frac{\partial A}{\partial w} \propto \frac{\partial A}{\partial \alpha_{\text{local}}} \cdot \frac{\partial \alpha_{\text{local}}}{\partial w} \propto \frac{2}{L}$$</p>
<p>这表明窗口大小对性能的影响与序列长度成反比。</p>
<p><strong>定理6.3（最优窗口大小的稳定性）</strong></p>
<p>最优窗口大小$w^<em>$在一定范围内对性能变化不敏感。具体地，当$w \in [w^</em>/2, 2w^*]$时，性能下降不超过$\epsilon$（$\epsilon$为小常数，如5%）。</p>
<p><strong>证明思路</strong>：性能函数$A(w)$通常在$w^*$附近是平滑的凸函数或拟凸函数，因此在最优点附近有较大的"平坦区域"。实验结果支持这一观察。</p>
<p><strong>推导6.4（泄漏系数$k$的敏感性）</strong></p>
<p>泄漏系数$k$控制窗口外位置的压缩程度。对于正向应用，$k$越大，压缩越强；对于逆向应用，$k = 1/r$越小（$r$越大），扩展越强。</p>
<p>定义有效外推长度：</p>
<p>$$L_{\text{eff}}(k, w, L_{\text{train}}) = w + k(L_{\text{train}} - w)$$</p>
<p>这是使用泄漏系数$k$时，相对位置编码不超过训练长度的最大测试长度。</p>
<p>性能对$k$的导数：</p>
<p>$$\frac{\partial A}{\partial k} \propto \frac{\partial A}{\partial L_{\text{eff}}} \cdot \frac{\partial L_{\text{eff}}}{\partial k} = \frac{\partial A}{\partial L_{\text{eff}}} \cdot (L_{\text{train}} - w)$$</p>
<p>当$L_{\text{eff}} &lt; L_{\text{test}}$时，增加$k$（减小压缩）可以提高性能；当$L_{\text{eff}} \geq L_{\text{test}}$时，继续增加$k$对性能影响很小。</p>
<p><strong>推导6.5（逆向应用的参数选择策略）</strong></p>
<p>对于逆向应用，需要选择训练扩展倍数$r = 1/k_{\text{train}}$。实验表明，最优值为：</p>
<p>$$r^* = \frac{L_{\text{test}}}{L_{\text{train}}} \times \beta$$</p>
<p>其中$\beta \in [1, 2]$是安全系数。$\beta = 1$时恰好覆盖目标长度，$\beta &gt; 1$提供额外的余量。</p>
<p>例如，$L_{\text{train}} = 512$，$L_{\text{test}} = 4096$（8倍扩展），选择$r = 8 \times 1.5 = 12$或$r = 16$。</p>
<h3 id="7">7. 逆向应用的理论保证<a class="toc-link" href="#7" title="Permanent link">&para;</a></h3>
<p><strong>定理7.1（逆向应用的外推消除）</strong></p>
<p>如果训练时使用扩展倍数$r \geq L_{\text{test}}/L_{\text{train}}$的逆向Leaky ReRoPE，那么推理时使用标准RoPE不会遇到未见过的位置编码。</p>
<p><strong>证明</strong>：训练时的最大相对位置为：</p>
<p>$$m_{\max}^{\text{train}} = w + r(L_{\text{train}} - 1 - w)$$</p>
<p>推理时的最大相对位置为：</p>
<p>$$m_{\max}^{\text{test}} = L_{\text{test}} - 1$$</p>
<p>只要$m_{\max}^{\text{train}} \geq m_{\max}^{\text{test}}$，即：</p>
<p>$$w + r(L_{\text{train}} - 1 - w) \geq L_{\text{test}} - 1$$</p>
<p>$$r(L_{\text{train}} - 1 - w) \geq L_{\text{test}} - 1 - w$$</p>
<p>$$r \geq \frac{L_{\text{test}} - 1 - w}{L_{\text{train}} - 1 - w}$$</p>
<p>当$w \ll L_{\text{train}}, L_{\text{test}}$时，近似为：</p>
<p>$$r \geq \frac{L_{\text{test}}}{L_{\text{train}}}$$</p>
<p><strong>推论7.2（训练成本的增加）</strong></p>
<p>逆向应用需要在训练时使用更大的有效位置编码范围，这可能增加训练难度。但由于窗口内保持标准RoPE，局部依赖的学习不受影响。</p>
<p><strong>推导7.3（与位置内插的对比）</strong></p>
<p>逆向Leaky ReRoPE与位置内插有相似之处，但关键区别在于：</p>
<p><strong>位置内插</strong>：所有位置统一压缩为$m/k$</p>
<p><strong>逆向Leaky ReRoPE</strong>：窗口内保持$m$，窗口外为$w + r(m - w)$</p>
<p>因此逆向Leaky ReRoPE保留了局部依赖的精确建模，而位置内插会破坏局部性。</p>
<h3 id="8-">8. 训练-推理不一致性分析<a class="toc-link" href="#8-" title="Permanent link">&para;</a></h3>
<p><strong>定义8.1（训练-推理位置编码差异）</strong></p>
<p>定义训练和推理阶段的位置编码差异为：</p>
<p>$$\Delta f(m) = |f_{\text{train}}(m) - f_{\text{test}}(m)|$$</p>
<p>对于逆向Leaky ReRoPE：</p>
<p>$$\Delta f(m) = \begin{cases}
0, &amp; m &lt; w \
|w + r(m - w) - m| = |(r - 1)(m - w)|, &amp; m \geq w
\end{cases}$$</p>
<p><strong>推导8.2（差异对性能的影响）</strong></p>
<p>训练-推理不一致会导致性能下降。定义性能损失为：</p>
<p>$$\mathcal{L}<em m="m">{\text{mismatch}} = \mathbb{E}</em>[\Delta f(m)^2]$$</p>
<p>对于序列长度$L$：</p>
<p>$$\mathcal{L}<em i_j="i,j">{\text{mismatch}} = \frac{1}{L^2}\sum</em> \Delta f(i - j)^2$$</p>
<p>在窗口外：</p>
<p>$$\Delta f(m) = (r - 1)(m - w)$$</p>
<p>平均差异为：</p>
<p>$$\mathbb{E}_{m \geq w}[\Delta f(m)] = (r - 1) \cdot \frac{L - w}{2}$$</p>
<p>当$r$接近1时，差异最小；当$r$很大时，差异增大，但实验显示只要$r$选择合理，性能仍然可接受。</p>
<p><strong>定理8.3（不一致性的容忍度）</strong></p>
<p>Transformer模型对训练-推理位置编码差异有一定容忍度，特别是当差异主要集中在远距离位置时。</p>
<p><strong>证明思路</strong>：注意力权重通常呈局部性衰减，远距离位置的权重较小。因此，即使远距离位置编码有较大差异，对最终预测的影响也较小。数学上，这可以通过注意力权重的加权平均来量化。</p>
<h3 id="9">9. 频率底数调整的数学原理<a class="toc-link" href="#9" title="Permanent link">&para;</a></h3>
<p><strong>定义9.1（RoPE频率底数）</strong></p>
<p>标准RoPE使用底数$b = 10000$：</p>
<p>$$\theta_i = b^{-2i/d} = 10000^{-2i/d}$$</p>
<p>调整底数到$b'$后：</p>
<p>$$\theta_i' = (b')^{-2i/d}$$</p>
<p><strong>推导9.2（底数调整等价于全局内插）</strong></p>
<p>将底数从$b$调整到$b' = b \cdot c$（$c &gt; 1$）等价于对所有频率应用内插因子$c$：</p>
<p>$$\theta_i' = (bc)^{-2i/d} = b^{-2i/d} \cdot c^{-2i/d} = \theta_i \cdot c^{-2i/d}$$</p>
<p>当$c = 8$时，所有频率都减小（波长增加），相当于位置编码"变慢"。</p>
<p><strong>定理9.3（底数调整与逆向应用的协同）</strong></p>
<p>在逆向Leaky ReRoPE中，底数调整可以进一步扩展有效长度。</p>
<p>设底数倍数为$c$，扩展倍数为$r$，则有效覆盖长度为：</p>
<p>$$L_{\text{eff}} = c \cdot [w + r(L_{\text{train}} - w)]$$</p>
<p><strong>证明</strong>：底数调整相当于将所有相对位置除以$c$，因此有效长度乘以$c$。</p>
<p><strong>推导9.4（实验中的参数组合）</strong></p>
<p>实验中的设置$w = 128$，$k = 1/16$（即$r = 16$），$b' = 80000 = 10000 \times 8$（即$c = 8$）：</p>
<p>有效覆盖：</p>
<p>$$L_{\text{eff}} = 8 \times [128 + 16(512 - 128)] = 8 \times [128 + 16 \times 384] = 8 \times 6272 = 50176$$</p>
<p>远超目标长度4096，提供了充足的余量。</p>
<h3 id="10-ropererope">10. 与标准RoPE和ReRoPE的性能对比<a class="toc-link" href="#10-ropererope" title="Permanent link">&para;</a></h3>
<p><strong>定义10.1（外推性能指标）</strong></p>
<p>定义归一化外推性能为：</p>
<p>$$P_{\text{extrap}} = \frac{A_{\text{extrap}}}{A_{\text{train}}}$$</p>
<p>其中$A_{\text{extrap}}$是外推长度的准确率，$A_{\text{train}}$是训练长度的准确率。理想情况下$P_{\text{extrap}} \geq 1$（"Longer Context, Better Performance"）。</p>
<p><strong>推导10.2（各方法的性能对比）</strong></p>
<p>根据实验结果：</p>
<ol>
<li><strong>标准RoPE</strong>：$P_{\text{extrap}} = 24.17\% / 49.41\% \approx 0.49$（严重退化）</li>
<li><strong>NTK-RoPE-mixed</strong>：$P_{\text{extrap}} = 68.91\% / 49.40\% \approx 1.39$（显著提升）</li>
<li><strong>ReRoPE-w256</strong>：$P_{\text{extrap}} = 85.12\% / 49.40\% \approx 1.72$（大幅提升）</li>
<li><strong>InvLeaky ReRoPE-w128</strong>：$P_{\text{extrap}} = 82.25\% / 49.38\% \approx 1.67$（接近ReRoPE）</li>
</ol>
<p><strong>定理10.3（逆向应用的竞争力）</strong></p>
<p>逆向Leaky ReRoPE的性能虽然略低于正向ReRoPE，但仍显著优于其他方法，且推理速度与标准RoPE相同。</p>
<p><strong>推导10.4（性能-效率权衡）</strong></p>
<p>定义效率归一化性能：</p>
<p>$$P_{\text{eff}} = \frac{A_{\text{extrap}}}{T_{\text{inference}}}$$</p>
<p>其中$T_{\text{inference}}$是推理时间。假设ReRoPE的推理时间是标准RoPE的2倍（需要计算两次Attention），则：</p>
<ul>
<li><strong>ReRoPE</strong>：$P_{\text{eff}} = 85.12\% / 2 = 42.56\%$</li>
<li><strong>InvLeaky ReRoPE</strong>：$P_{\text{eff}} = 82.25\% / 1 = 82.25\%$</li>
</ul>
<p>从效率角度看，逆向应用更优。</p>
<h3 id="11">11. 训练开销的定量分析<a class="toc-link" href="#11" title="Permanent link">&para;</a></h3>
<p><strong>定义11.1（训练时间复杂度）</strong></p>
<p>标准Attention的时间复杂度为：</p>
<p>$$T_{\text{std}} = \mathcal{O}(L^2 d)$$</p>
<p>逆向Leaky ReRoPE的训练复杂度为：</p>
<p>$$T_{\text{inv}} = \mathcal{O}(2L^2 d)$$</p>
<p>因为需要计算两次Attention矩阵（窗口内和窗口外）。</p>
<p><strong>推导11.2（实际训练时间增加）</strong></p>
<p>实验报告显示，对于1亿参数的GAU模型，训练长度512，每1000步训练时间从330秒增加到350秒，增幅为：</p>
<p>$$\frac{350 - 330}{330} = \frac{20}{330} \approx 6.06\%$$</p>
<p>远小于理论上的100%增加，原因包括：</p>
<ol>
<li>GAU使用单头注意力，Attention占总计算的比例较小</li>
<li>其他操作（FFN、LayerNorm等）时间不变</li>
<li>可能存在一定的并行优化</li>
</ol>
<p><strong>推导11.3（多头注意力的训练开销）</strong></p>
<p>对于标准的多头注意力（假设有$h$个头），Attention占总计算的比例约为：</p>
<p>$$\alpha = \frac{h \cdot L^2 d / h}{h \cdot L^2 d / h + d \cdot d_{\text{ff}} \cdot L} = \frac{L \cdot d}{L \cdot d + d_{\text{ff}}}$$</p>
<p>其中$d_{\text{ff}}$是FFN的隐藏维度，通常$d_{\text{ff}} = 4d$。</p>
<p>$$\alpha = \frac{L \cdot d}{L \cdot d + 4d} = \frac{L}{L + 4}$$</p>
<p>当$L = 512$时，$\alpha \approx 99.2\%$，因此训练时间增加接近100%。</p>
<p>当$L = 2048$时，$\alpha \approx 99.8\%$，训练时间增加几乎翻倍。</p>
<p><strong>定理11.4（训练开销的可接受性）</strong></p>
<p>尽管训练时间增加50%-100%，但这是一次性成本，且只在训练阶段发生。相比之下，推理速度的优化带来长期收益，因此逆向应用的整体价值仍然显著。</p>
<h3 id="12">12. 逆向应用的变体<a class="toc-link" href="#12" title="Permanent link">&para;</a></h3>
<p><strong>定义12.1（混合逆向策略）</strong></p>
<p>不是所有层都使用逆向Leaky ReRoPE，而是：</p>
<ul>
<li>前$L/2$层使用标准RoPE</li>
<li>后$L/2$层使用逆向Leaky ReRoPE</li>
</ul>
<p>这样可以减少训练开销，同时保留部分外推能力。</p>
<p><strong>推导12.2（渐进式逆向应用）</strong></p>
<p>在训练过程中逐渐引入逆向Leaky ReRoPE。设总训练步数为$T$，当前步数为$t$，窗口外扩展倍数为：</p>
<p>$$r(t) = 1 + (r_{\max} - 1) \cdot \min\left(\frac{t}{T_{\text{warmup}}}, 1\right)$$</p>
<p>其中$T_{\text{warmup}}$是预热步数。初期$r(t) = 1$（标准RoPE），逐渐过渡到$r_{\max}$。</p>
<p><strong>定义12.3（自适应窗口逆向应用）</strong></p>
<p>根据序列长度自适应调整窗口大小和扩展倍数：</p>
<p>$$w(L) = \alpha L, \quad r(L) = \beta \frac{L_{\text{test}}}{L}$$</p>
<p>其中$\alpha \in [0.2, 0.4]$，$\beta \in [1.2, 1.5]$是超参数。</p>
<h3 id="13">13. 理论优化方向<a class="toc-link" href="#13" title="Permanent link">&para;</a></h3>
<p><strong>定义13.1（最优位置编码函数）</strong></p>
<p>在所有满足以下约束的位置编码函数中寻找最优解：</p>
<ol>
<li>窗口内保持$f(m) = m$（保留局部性）</li>
<li>训练时最大相对位置不超过$C \cdot L_{\text{train}}$（$C$为常数，如1.5）</li>
<li>推理时使用标准RoPE</li>
</ol>
<p>目标是最大化外推性能。</p>
<p><strong>推导13.2（变分优化框架）</strong></p>
<p>定义性能泛函：</p>
<p>$$\mathcal{J}[f] = \mathbb{E}<em _text_test="\text{test">{L \sim \mathcal{D}</em>(f)$$}}}[A(f, L)] - \lambda \cdot \text{Cost</p>
<p>其中$A(f, L)$是使用位置编码$f$在长度$L$上的准确率，$\text{Cost}(f)$是训练成本，$\lambda$是权衡系数。</p>
<p>优化问题：</p>
<p>$$f^* = \arg\max_f \mathcal{J}[f]$$</p>
<p>Leaky ReRoPE（包括逆向）是这个优化问题的一个简单参数化解。</p>
<p><strong>定理13.3（最优性的必要条件）</strong></p>
<p>最优位置编码函数$f^*$应满足Euler-Lagrange方程：</p>
<p>$$\frac{\delta \mathcal{J}}{\delta f} = 0$$</p>
<p>在离散情况下，这转化为对每个位置$m$的最优条件。</p>
<h3 id="14">14. 实验设计的统计学分析<a class="toc-link" href="#14" title="Permanent link">&para;</a></h3>
<p><strong>定义14.1（实验的统计显著性）</strong></p>
<p>比较两个方法的性能差异是否显著。设方法A的准确率为$A_1$，方法B的准确率为$A_2$，假设检验：</p>
<p>$$H_0: A_1 = A_2, \quad H_1: A_1 \neq A_2$$</p>
<p>使用t检验或非参数检验（如Wilcoxon符号秩检验）。</p>
<p><strong>推导14.2（效应量分析）</strong></p>
<p>定义Cohen's d效应量：</p>
<p>$$d = \frac{A_1 - A_2}{\sqrt{(s_1^2 + s_2^2)/2}}$$</p>
<p>其中$s_1, s_2$是标准差。</p>
<p>从ReRoPE（85.12%）到InvLeaky ReRoPE（82.25%），差异为2.87个百分点。如果标准差约为1-2%，则效应量中等偏大，差异有实际意义但不算巨大。</p>
<p><strong>推导14.3（置信区间估计）</strong></p>
<p>对于准确率$A$，95%置信区间为：</p>
<p>$$[A - 1.96 \cdot \text{SE}, A + 1.96 \cdot \text{SE}]$$</p>
<p>其中标准误差$\text{SE} = \sqrt{A(1-A)/n}$，$n$是测试样本数。</p>
<p>例如，$A = 0.8225$，$n = 1000$：</p>
<p>$$\text{SE} = \sqrt{0.8225 \times 0.1775 / 1000} \approx 0.0121$$</p>
<p>置信区间为$[80.0\%, 84.5\%]$，与ReRoPE的$[83.3\%, 86.9\%]$有重叠，差异在统计上可能不显著。</p>
<h3 id="15">15. 未来研究方向<a class="toc-link" href="#15" title="Permanent link">&para;</a></h3>
<p><strong>方向15.1（自适应逆向机制）</strong></p>
<p>开发能够根据输入特征自适应调整$w$和$r$的机制：</p>
<p>$$w = g_w(\boldsymbol{x}; \theta_w), \quad r = g_r(\boldsymbol{x}; \theta_r)$$</p>
<p>其中$g_w, g_r$是可学习的函数（如小型神经网络）。</p>
<p><strong>方向15.2（多模态位置编码）</strong></p>
<p>结合相对位置和绝对位置的优势：</p>
<p>$$f_{\text{hybrid}}(m) = \alpha f_{\text{rel}}(m) + (1 - \alpha) f_{\text{abs}}(m)$$</p>
<p>其中$\alpha$是可学习的权重。</p>
<p><strong>方向15.3（理论分析深化）</strong></p>
<p>建立更严格的理论框架，证明逆向Leaky ReRoPE在特定假设下的最优性或近似最优性。</p>
<h3 id="16">16. 总结<a class="toc-link" href="#16" title="Permanent link">&para;</a></h3>
<p><strong>总结16.1（逆向应用的核心思想）</strong></p>
<p>逆向Leaky ReRoPE通过在训练时扩展窗口外位置编码，使得推理时可以使用标准RoPE，从而在保持外推能力的同时优化推理速度。</p>
<p><strong>总结16.2（关键发现）</strong></p>
<ol>
<li><strong>性能</strong>：逆向应用的外推性能接近正向ReRoPE，显著优于其他baseline</li>
<li><strong>效率</strong>：推理速度与标准RoPE相同，避免了ReRoPE的推理开销</li>
<li><strong>训练成本</strong>：训练时间增加可控（小于10%到接近100%，取决于模型架构）</li>
<li><strong>实用性</strong>：提供了外推性能和推理效率的良好权衡</li>
</ol>
<p><strong>总结16.3（适用场景）</strong></p>
<p>逆向Leaky ReRoPE特别适合以下场景：</p>
<ul>
<li>推理量远大于训练量（如生产环境的大规模服务）</li>
<li>需要与现有加速技术（如Flash Attention）兼容</li>
<li>可以接受适度的训练成本增加以换取长期推理效率</li>
</ul>
                </div>

                <!-- Previous/Next Navigation -->
                <nav class="post-navigation" aria-label="文章导航">
                    <div class="row g-3">
                        <div class="col-6">
                            
                            <a href="transformer升级之路12无限外推的rerope.html" class="nav-link-prev">
                                <div class="nav-direction"><i class="fas fa-chevron-left"></i> 上一篇</div>
                                <div class="nav-title">#97 Transformer升级之路：12、无限外推的ReRoPE？</div>
                            </a>
                            
                        </div>
                        <div class="col-6">
                            
                            <a href="transformer升级之路14当hwfa遇见rerope.html" class="nav-link-next">
                                <div class="nav-direction">下一篇 <i class="fas fa-chevron-right"></i></div>
                                <div class="nav-title">#99 Transformer升级之路：14、当HWFA遇见ReRoPE</div>
                            </a>
                            
                        </div>
                    </div>
                </nav>

                <!-- Back to Home -->
                <div class="text-center mt-4 mb-4">
                    <a href="../index.html" class="btn btn-outline-primary">
                        <i class="fas fa-arrow-left"></i> 返回首页
                    </a>
                </div>
            </div>

            <!-- Sidebar (TOC) -->
            <div class="col-lg-3">
                <aside class="sidebar">
                    
                    <div class="toc-sidebar">
                        <h5 class="toc-title"><i class="fas fa-list"></i> 目录</h5>
                        <div class="toc-content">
                            <div class="toc">
<ul>
<li><a href="#transformer13leaky-rerope">Transformer升级之路：13、逆用Leaky ReRoPE</a><ul>
<li><a href="#_1">回顾</a></li>
<li><a href="#_2">反转</a></li>
<li><a href="#_3">实验</a></li>
<li><a href="#_4">小结</a></li>
<li><a href="#_5">公式推导与注释</a><ul>
<li><a href="#1-leaky-rerope">1. Leaky ReRoPE的泄漏机制数学基础</a></li>
<li><a href="#2">2. 窗口边界的平滑处理</a></li>
<li><a href="#3">3. 逆向应用的数学原理</a></li>
<li><a href="#4">4. 信息流动的定量分析</a></li>
<li><a href="#5">5. 梯度传播与训练稳定性</a></li>
<li><a href="#6">6. 参数敏感性分析</a></li>
<li><a href="#7">7. 逆向应用的理论保证</a></li>
<li><a href="#8-">8. 训练-推理不一致性分析</a></li>
<li><a href="#9">9. 频率底数调整的数学原理</a></li>
<li><a href="#10-ropererope">10. 与标准RoPE和ReRoPE的性能对比</a></li>
<li><a href="#11">11. 训练开销的定量分析</a></li>
<li><a href="#12">12. 逆向应用的变体</a></li>
<li><a href="#13">13. 理论优化方向</a></li>
<li><a href="#14">14. 实验设计的统计学分析</a></li>
<li><a href="#15">15. 未来研究方向</a></li>
<li><a href="#16">16. 总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

                        </div>
                        <div class="toc-actions">
                            <button class="btn btn-sm btn-outline-secondary" onclick="expandAll()">
                                <i class="fas fa-expand"></i> 全部展开
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" onclick="collapseAll()">
                                <i class="fas fa-compress"></i> 全部折叠
                            </button>
                        </div>
                    </div>
                    

                    <!-- Back to Top Button -->
                    <button id="backToTop" class="back-to-top" title="回到顶部">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                </aside>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <p>
                博客来源: <a href="https://spaces.ac.cn" target="_blank">科学空间</a> |
                内容经过整理并添加详细数学推导
            </p>
            <p>
                Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
            </p>
        </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Syntax highlighting -->
    <script>hljs.highlightAll();</script>

    <!-- Back to top functionality -->
    <script>
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('show');
            } else {
                backToTop.classList.remove('show');
            }
        });

        // Smooth scroll to top
        document.getElementById('backToTop').addEventListener('click', function() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });

        // Sticky TOC sidebar
        window.addEventListener('scroll', function() {
            const sidebar = document.querySelector('.sidebar');
            if (!sidebar) return;

            const sidebarTop = sidebar.offsetTop;
            const scrollTop = window.pageYOffset;

            if (scrollTop > sidebarTop - 20) {
                sidebar.classList.add('sticky');
            } else {
                sidebar.classList.remove('sticky');
            }
        });
    </script>
</body>
</html>