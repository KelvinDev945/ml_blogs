---
title: 生成扩散模型漫谈（二十七）：将步长作为条件输入
slug: 生成扩散模型漫谈二十七将步长作为条件输入
date: 2024-12-15
tags: 微分方程, 生成模型, 采样, 扩散, 生成模型
status: pending
---

# 生成扩散模型漫谈（二十七）：将步长作为条件输入

**原文链接**: [https://spaces.ac.cn/archives/10617](https://spaces.ac.cn/archives/10617)

**发布日期**: 

---

这篇文章我们再次聚焦于扩散模型的采样加速。众所周知，扩散模型的采样加速主要有两种思路，一是开发更高效的求解器，二是事后蒸馏。然而，据笔者观察，除了上两篇文章介绍过的[SiD](/archives/10085)外，这两种方案都鲜有能将生成步数降低到一步的结果。虽然SiD能做到单步生成，但它需要额外的蒸馏成本，并且蒸馏过程中用到了类似GAN的交替训练过程，总让人感觉差点意思。

本文要介绍的是[《One Step Diffusion via Shortcut Models》](https://papers.cool/arxiv/2410.12557)，其突破性思想是将生成步长也作为扩散模型的条件输入，然后往训练目标中加入了一个直观的正则项，这样就能直接稳定训练出可以单步生成模型，可谓简单有效的经典之作。

## ODE扩散 #

原论文的结论是基于ODE式扩散模型的，而对于ODE式扩散的理论基础，我们在本系列的[（六）](/archives/9228)、[（十二）](/archives/9280)、[（十四）](/archives/9370)、[（十五）](/archives/9379)、[（十七）](/archives/9497)等博客中已经多次介绍，其中最简单的一种理解方式大概是[（十七）](/archives/9497)中的ReFlow视角，下面我们简单重复一下。

假设$\boldsymbol{x}_0\sim p_0(\boldsymbol{x}_0)$是先验分布采样的 _随机噪声_ ，$\boldsymbol{x}_1\sim p_1(\boldsymbol{x}_1)$是目标分布采样的 _真实样本_ （注：前面的文章中，普通都是$\boldsymbol{x}_T$是噪声、$\boldsymbol{x}_0$是目标样本，这里方便起见反过来了），ReFlow允许我们指定任意从$\boldsymbol{x}_0$到$\boldsymbol{x}_1$的运动轨迹，最简单的轨迹自然是直线：  
\begin{equation}\boldsymbol{x}_t = (1-t)\boldsymbol{x}_0 + t \boldsymbol{x}_1\label{eq:line}\end{equation}  
两边求导，就可以得到它满足的ODE（常微分方程）：  
\begin{equation}\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{x}_1 - \boldsymbol{x}_0\end{equation}  
这个ODE很简单，但实际上没用，因为我们想要的是通过ODE由$\boldsymbol{x}_0$生成$\boldsymbol{x}_1$，而上述ODE却显式地依赖$\boldsymbol{x}_1$。为了解决这个问题，一个很简单的想法是“学一个$\boldsymbol{x}_t$的函数去逼近$\boldsymbol{x}_1 - \boldsymbol{x}_0$”，学完之后就用它来取代$\boldsymbol{x}_1 - \boldsymbol{x}_0$，即  
\begin{equation}\boldsymbol{\theta}^* = \mathop{\text{argmin}}_{\boldsymbol{\theta}} \mathbb{E}_{\boldsymbol{x}_0\sim p_0(\boldsymbol{x}_0),\boldsymbol{x}_1\sim p_1(\boldsymbol{x}_1)}\left[\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\Vert^2\right]\label{eq:loss}\end{equation}  
以及  
\begin{equation}\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{x}_1 - \boldsymbol{x}_0\quad\Rightarrow\quad\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{v}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, t)\label{eq:ode-core}\end{equation}  
这就是ReFlow。当然这里边还欠缺了一个理论证明，就是通过平方误差来拟合$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$所得到的ODE确实能生成我们期望的分布，这部分大家自行看[《生成扩散模型漫谈（十七）：构建ODE的一般步骤（下）》](/archives/9497)就好。

## 步长自洽 #

假设我们已经有了$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$，那么通过求解微分方程$\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$就可以实现从$\boldsymbol{x}_0$到$\boldsymbol{x}_1$的变换。划重点，是“微分方程”，但实际上我们没法真的去数值计算微分方程，而是只能算“差分方程”：  
\begin{equation}\boldsymbol{x}_{t + \epsilon} - \boldsymbol{x}_t = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) \epsilon\label{eq:de}\end{equation}  
这个差分方程是原始ODE的“欧拉近似”，近似程度取决于步长$\epsilon$的大小，当$\epsilon\to 0$时就精确等于原始ODE，换言之步长越小越精确。然而，生成步数等于$1/\epsilon$，我们希望生成步数越少越好，这意味着不能用太大的步长，最好$\epsilon$可以等于1，这样$\boldsymbol{x}_1 = \boldsymbol{x}_0 + \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_0, 0)$，一步就可以完成生成。

问题是，如果直接用大步长代入上式，最终所算得的$\boldsymbol{x}_1$必然会严重偏离精确解。这时候原论文（下称“Shortcut模型”）的巧妙构思就登场了：它认为模型$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$不应该只是$\boldsymbol{x}_t$和$t$的函数，还应该是步长$\epsilon$的函数，这样差分方程$\eqref{eq:de}$就可以自行适应步长：  
\begin{equation}\boldsymbol{x}_{t + \epsilon} - \boldsymbol{x}_t = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) \epsilon\end{equation}  
目标$\eqref{eq:loss}$训练的是精确的ODE模型，所以它训练的是$\epsilon=0$的模型：  
\begin{equation}\mathcal{L}_1 = \mathbb{E}_{\boldsymbol{x}_0\sim p_0(\boldsymbol{x}_0),\boldsymbol{x}_1\sim p_1(\boldsymbol{x}_1)}\left[\frac{1}{2}\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 0) - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\Vert^2\right]\end{equation}  
那$\epsilon > 0$的部分又怎么训练呢？我们的目标是生成步数越少越好，这等价于说希望“ _两倍的步长走1步_ 等于 _单倍的步长走2步_ ”：  
\begin{equation}\boldsymbol{x}_t + \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) 2\epsilon = \color{green}{\underbrace{\boldsymbol{x}_t + \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) \epsilon}_{\tilde{\boldsymbol{x}}_{t+\epsilon}}} + \boldsymbol{v}_{\boldsymbol{\theta}}\big(\color{green}{\underbrace{\boldsymbol{x}_t + \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) \epsilon}_{\tilde{\boldsymbol{x}}_{t+\epsilon}}}, t+\epsilon, \epsilon\big) \epsilon\label{eq:cond}\end{equation}  
即$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) = [\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) + \boldsymbol{v}_{\boldsymbol{\theta}}(\color{green}{\tilde{\boldsymbol{x}}_{t+\epsilon}}, t+\epsilon, \epsilon)] /2$。为了达到这个目标，我们补充一项自洽性损失函数  
\begin{equation}\mathcal{L}_2 = \mathbb{E}_{\boldsymbol{x}_0\sim p_0(\boldsymbol{x}_0),\boldsymbol{x}_1\sim p_1(\boldsymbol{x}_1)}\left[\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) - [\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon)+ \boldsymbol{v}_{\boldsymbol{\theta}}(\color{green}{\tilde{\boldsymbol{x}}_{t+\epsilon}}, t+\epsilon, \epsilon) ]/2\Vert^2\right]\end{equation}  
$\mathcal{L}_1$与$\mathcal{L}_2$相加，就构成了Shortcut模型的损失函数。

（注：有读者指出，更早的[《Consistency Trajectory Models: Learning Probability Flow ODE Trajectory of Diffusion》](https://papers.cool/arxiv/2310.02279)提出过以离散化时间的起点和终点作为条件输入的做法，指定起点和终点后步长其实也就确定了，所以Shortcut以步长为输入的做法并不算完全创新。）

## 模型细节 #

以上基本就是Shortcut模型的全部理论内容，非常精巧且简明，但从理论到实验，还需要一些细节，比如步长$\epsilon$如何融入到模型中去。

首先，在训练$\mathcal{L}_2$时，Shortcut并没有均匀地从$[0,1]$采样$\epsilon$，而是设置了一个最小步长$2^{-7}$，然后将它们倍增至1，即所有的非零步长只有$\\{2^{-7},2^{-6},2^{-5},2^{-4},2^{-3},2^{-2},2^{-1},1\\}$这8个值，从前7个中均匀采样来训练$\mathcal{L}_2$。这样一来，$\epsilon$的取值就是有限的，算上$0$一共就只有9个，所以Shortcut模型直接以Embedding的方式来输入$\epsilon$，将它跟$t$的Embedding加在一起。

其次，注意到$\mathcal{L}_2$的计算量是比$\mathcal{L}_1$大的，因为$\boldsymbol{v}_{\boldsymbol{\theta}}(\tilde{\boldsymbol{x}}_{t+\epsilon}, t, \epsilon)$这一项需要两次前向传播，所以论文的做法是每个batch中$3/4$的样本都用来计算$\mathcal{L}_1$，剩下的$1/4$样本才用来算$\mathcal{L}_2$。该操作不仅是为了节省计算量，实际上还调节了$\mathcal{L}_1,\mathcal{L}_2$的权重，因为$\mathcal{L}_2$比$\mathcal{L}_1$更好训练，所以它的训练样本可以适当少些。

除此之外，论文在实践的时候还对$\mathcal{L}_2$做了微调，多加了个stop gradient算子：  
\begin{equation}\mathcal{L}_2 = \mathbb{E}_{\boldsymbol{x}_0\sim p_0(\boldsymbol{x}_0),\boldsymbol{x}_1\sim p_1(\boldsymbol{x}_1)}\left[\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) - \color{skyblue}{\text{sg}[}\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon)+ \boldsymbol{v}_{\boldsymbol{\theta}}(\color{green}{\tilde{\boldsymbol{x}}_{t+\epsilon}}, t+\epsilon, \epsilon) \color{skyblue}{]}/2\Vert^2\right]\end{equation}  
为什么要这样做呢？按照作者的[回复](https://openreview.net/forum?id=OlzB6LnXcS¬eId=k4If3csXST)，这是自引导学习的常见做法，被stop gradient的部分属于目标，不应该有梯度，跟[BYOL](https://papers.cool/arxiv/2006.07733)、[SimSiam](https://papers.cool/arxiv/2011.10566)等无监督学习方案类似。不过照笔者看来，这个操作最大的价值还是节省训练成本，因为$\boldsymbol{v}_{\boldsymbol{\theta}}(\tilde{\boldsymbol{x}}_{t+\epsilon}, t, \epsilon)$这一项做了两次前向传播，如果要对它反向传播，计算量也要翻倍。

## 实验效果 #

现在我们来看Shortcut模型的实验效果，看起来它是目前单步生成效果最好的、单阶段训练的扩散模型：  


[![各种扩散模型的生成质量评估](/usr/uploads/2024/12/2449555374.png)](/usr/uploads/2024/12/2449555374.png "点击查看原图")

各种扩散模型的生成质量评估

这是它的实际采样效果图：  


[![Flow Matching与Shortcut Model的实际采样效果对比](/usr/uploads/2024/12/3428964799.jpg)](/usr/uploads/2024/12/3428964799.jpg "点击查看原图")

Flow Matching与Shortcut Model的实际采样效果对比

不过仔细观察单步生成的样本就会发现，其实还有明显的瑕疵，所以说虽然Shortcut模型相比于之前的单阶段训练方案来说已经取得了较大的进步，但还有明显的提升空间。

作者已经将Shortcut模型的代码开源，Github链接是：

> **<https://github.com/kvfrans/shortcut-models>**

顺便说，Shortcut模型投到了ICLR 2025上，获得了reviewer的一致好评（全8分）。

## 延伸思考 #

看到Shortcut模型，不知道大家想到了哪些相关工作？笔者想到了一个可能大家都意想不到的，那就是我们在[《生成扩散模型漫谈（二十一）：中值定理加速ODE采样》](/archives/9881)介绍过的AMED。

Shortcut模型与AMED的底层思想是相通的，它们都已经发现，单靠研究复杂的高阶求解器，将生成的NFE（模型的运行次数）降低到个位数就已经很简单了，更不用说做单步生成了。所以它们一致认为，真正要变的并不是求解器，而是模型。该怎么变呢？AMED想到的是“中值定理”：对ODE两端积分，我们有精确的  
\begin{equation}\boldsymbol{x}_{t + \epsilon} - \boldsymbol{x}_t = \int_t^{t + \epsilon}\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau}, \tau) d\tau\end{equation}  
类比“[积分中值定理](https://en.wikipedia.org/wiki/Mean_value_theorem#Mean_value_theorems_for_definite_integrals)”，我们能找到一个$s\in[t, t + \epsilon]$，成立  
\begin{equation}\frac{1}{\epsilon}\int_t^{t + \epsilon}\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau}, \tau) d\tau = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_s, s)\end{equation}  
于是我们得到  
\begin{equation}\boldsymbol{x}_{t + \epsilon} - \boldsymbol{x}_t = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_s, s) \epsilon\end{equation}  
当然，积分中值定理实际上只对标量函数成立，对向量函数是不保证成立的，所以说是“类比”。现在的问题是并不知道$s$的值，所以AMED的后续做法是用一个非常小的（计算量几乎可以忽略的）模型去预测$s$。

AMED是基于现成扩散模型的事后修正方法，因此它的效果取决于中值定理对$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$模型的成立程度，这显得有些“运气成分”，并且AMED需要先用欧拉格式预估一下$\boldsymbol{x}_s$，所以它的NFE最少是2，不能做到单步生成。相比之下，Shortcut模型更“激进”，它直接把步长作为条件输入，将加速生成的条件$\eqref{eq:cond}$作为损失函数，这样一来不仅避免了“中值定理”近似的可行性讨论，还使得最少NFE可以降低到1。

更巧妙的是，细思之下我们会发现两者的做法其实也有些共性，前面我们说了Shortcut是直接将$\epsilon$转成Embedding加到$t$的Embeddding上的，这不相当于跟AMED一样都是修改$t$嘛！只不过AMED是直接修改$t$的数值，而Shortcut修改的是$t$的Embedding。

## 文章小结 #

本文介绍了一个单阶段训练就可以实现单步生成的扩散模型新工作，它的突破思想是将步长也当成条件输入到扩散模型中，并配以一个直观的正则项，这样只通过单阶段训练就可以得到单步生成的扩散模型。

_**转载到请包括本文地址：**<https://spaces.ac.cn/archives/10617>_

_**更详细的转载事宜请参考：**_[《科学空间FAQ》](https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8 "《科学空间FAQ》")

**如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。**

**如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！**

打赏

![科学空间](https://spaces.ac.cn/usr/themes/geekg/payment/wx.png)

微信打赏

![科学空间](https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png)

支付宝打赏

因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以[**点击这里**](http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=tN7d1drY3drrx8H0xcWa19vZ)或在下方评论区留言来告知你的建议或需求。

**如果您需要引用本文，请参考：**

苏剑林. (Dec. 15, 2024). 《生成扩散模型漫谈（二十七）：将步长作为条件输入 》[Blog post]. Retrieved from <https://spaces.ac.cn/archives/10617>

@online{kexuefm-10617,  
title={生成扩散模型漫谈（二十七）：将步长作为条件输入},  
author={苏剑林},  
year={2024},  
month={Dec},  
url={\url{https://spaces.ac.cn/archives/10617}},  
} 


---

## 公式推导与注释

### 1. 核心概念与数学框架

#### 1.1 ReFlow框架的基础

ReFlow框架允许我们在噪声分布 $\boldsymbol{x}_0 \sim p_0(\boldsymbol{x}_0)$ 和目标分布 $\boldsymbol{x}_1 \sim p_1(\boldsymbol{x}_1)$ 之间构建任意的运动轨迹。最简单的选择是直线轨迹：

\begin{equation}
\boldsymbol{x}_t = (1-t)\boldsymbol{x}_0 + t \boldsymbol{x}_1, \quad t \in [0,1] \tag{1}
\end{equation}

**数学直觉**：这个线性插值公式确保了：
- 当 $t=0$ 时，$\boldsymbol{x}_0$ 是纯噪声
- 当 $t=1$ 时，$\boldsymbol{x}_1$ 是真实样本
- 中间时刻 $t \in (0,1)$ 是从噪声到真实样本的平滑过渡

对式 (1) 关于时间 $t$ 求导，得到速度场：

\begin{equation}
\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{x}_1 - \boldsymbol{x}_0 \tag{2}
\end{equation}

**证明**：
\begin{equation}
\frac{d\boldsymbol{x}_t}{dt} = \frac{d}{dt}[(1-t)\boldsymbol{x}_0 + t\boldsymbol{x}_1] = -\boldsymbol{x}_0 + \boldsymbol{x}_1 = \boldsymbol{x}_1 - \boldsymbol{x}_0 \tag{3}
\end{equation}

#### 1.2 速度场学习问题

式 (2) 中的ODE显式依赖于目标 $\boldsymbol{x}_1$，这在生成阶段是不可知的。为此，我们引入参数化的速度场 $\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$ 来近似 $\boldsymbol{x}_1 - \boldsymbol{x}_0$。

**训练目标**：
\begin{equation}
\boldsymbol{\theta}^* = \mathop{\text{argmin}}_{\boldsymbol{\theta}} \mathbb{E}_{\boldsymbol{x}_0\sim p_0,\boldsymbol{x}_1\sim p_1, t\sim U(0,1)}\left[\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\Vert^2\right] \tag{4}
\end{equation}

其中 $\boldsymbol{x}_t = (1-t)\boldsymbol{x}_0 + t\boldsymbol{x}_1$。

**损失函数的数学意义**：
- 这是一个最小二乘问题，寻找最优的速度场预测
- 期望是对三个随机变量取的：起点 $\boldsymbol{x}_0$，终点 $\boldsymbol{x}_1$，以及时间 $t$
- $L^2$ 范数保证了速度场在各个方向上的均衡拟合

训练完成后，生成过程变为求解ODE：
\begin{equation}
\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{v}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, t) \tag{5}
\end{equation}

### 2. 欧拉方法与步长问题

#### 2.1 欧拉离散化

在实际计算中，我们无法精确求解连续时间的ODE (5)，而是使用**欧拉方法**进行离散化：

\begin{equation}
\boldsymbol{x}_{t+\epsilon} = \boldsymbol{x}_t + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) \tag{6}
\end{equation}

**欧拉方法的误差分析**：

记精确解为 $\boldsymbol{x}^*(t)$，欧拉方法的局部截断误差为：

\begin{equation}
\boldsymbol{e}_{\text{local}} = \boldsymbol{x}^*(t+\epsilon) - [\boldsymbol{x}^*(t) + \epsilon \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}^*(t), t)] \tag{7}
\end{equation}

通过泰勒展开：
\begin{equation}
\boldsymbol{x}^*(t+\epsilon) = \boldsymbol{x}^*(t) + \epsilon \frac{d\boldsymbol{x}^*}{dt}\bigg|_t + \frac{\epsilon^2}{2}\frac{d^2\boldsymbol{x}^*}{dt^2}\bigg|_t + O(\epsilon^3) \tag{8}
\end{equation}

因为 $\frac{d\boldsymbol{x}^*}{dt} = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}^*, t)$，所以：
\begin{equation}
\boldsymbol{e}_{\text{local}} = \frac{\epsilon^2}{2}\frac{d^2\boldsymbol{x}^*}{dt^2}\bigg|_t + O(\epsilon^3) = O(\epsilon^2) \tag{9}
\end{equation}

**全局误差**：假设需要 $N = 1/\epsilon$ 步从 $t=0$ 到 $t=1$，全局误差为：
\begin{equation}
\boldsymbol{e}_{\text{global}} = N \cdot O(\epsilon^2) = \frac{1}{\epsilon} \cdot O(\epsilon^2) = O(\epsilon) \tag{10}
\end{equation}

**结论**：步长 $\epsilon$ 越小，误差越小，但生成步数 $N = 1/\epsilon$ 越大，计算成本越高。

#### 2.2 步长-精度权衡

生成质量和计算成本之间存在根本矛盾：

| 步长 $\epsilon$ | 生成步数 $N$ | 误差量级 | 生成质量 |
|----------------|-------------|---------|---------|
| $\epsilon = 1$ | $N = 1$ | $O(1)$ | 很差 |
| $\epsilon = 0.1$ | $N = 10$ | $O(0.1)$ | 较好 |
| $\epsilon = 0.01$ | $N = 100$ | $O(0.01)$ | 很好 |
| $\epsilon = 0.001$ | $N = 1000$ | $O(0.001)$ | 极好 |

**Shortcut模型的核心思想**：与其被动接受欧拉方法的误差，不如主动让模型适应不同的步长。

### 3. Shortcut模型：步长条件化

#### 3.1 步长条件速度场

传统速度场 $\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$ 只依赖于状态 $\boldsymbol{x}_t$ 和时间 $t$。Shortcut模型将步长 $\epsilon$ 也作为输入：

\begin{equation}
\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon): \mathbb{R}^d \times [0,1] \times \mathbb{R}_+ \to \mathbb{R}^d \tag{11}
\end{equation}

**更新规则**：
\begin{equation}
\boldsymbol{x}_{t+\epsilon} = \boldsymbol{x}_t + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) \tag{12}
\end{equation}

**数学直觉**：
- 当 $\epsilon \to 0$，$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon)$ 应该收敛到精确的ODE速度场
- 当 $\epsilon$ 较大时，模型可以"预见"更远的未来，输出修正后的速度场
- 这类似于高阶ODE求解器，但通过学习而非手工设计

#### 3.2 第一个损失函数：精确ODE损失

为了保证 $\epsilon \to 0$ 时的精确性，我们需要训练精确的ODE模型：

\begin{equation}
\mathcal{L}_1(\boldsymbol{\theta}) = \mathbb{E}_{\boldsymbol{x}_0\sim p_0,\boldsymbol{x}_1\sim p_1, t\sim U(0,1)}\left[\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 0) - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\Vert^2\right] \tag{13}
\end{equation}

**注意事项**：
- 这里步长设为 $\epsilon = 0$，表示无限小步长
- 这确保了模型在极限情况下的正确性
- 单独这个损失还不够，因为它没有告诉模型如何处理 $\epsilon > 0$ 的情况

### 4. 自洽性约束：核心创新

#### 4.1 自洽性条件的推导

Shortcut模型的关键洞察是：**大步长应该等于多个小步长的组合**。

具体地，用步长 $2\epsilon$ 走1步应该等于用步长 $\epsilon$ 走2步：

\begin{equation}
\boldsymbol{x}_t + 2\epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) = \text{(用步长 } \epsilon \text{ 走2步的结果)} \tag{14}
\end{equation}

**第一步**（从 $t$ 到 $t+\epsilon$）：
\begin{equation}
\tilde{\boldsymbol{x}}_{t+\epsilon} = \boldsymbol{x}_t + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) \tag{15}
\end{equation}

**第二步**（从 $t+\epsilon$ 到 $t+2\epsilon$）：
\begin{equation}
\tilde{\boldsymbol{x}}_{t+2\epsilon} = \tilde{\boldsymbol{x}}_{t+\epsilon} + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\tilde{\boldsymbol{x}}_{t+\epsilon}, t+\epsilon, \epsilon) \tag{16}
\end{equation}

将式 (15) 代入式 (16)：
\begin{equation}
\begin{aligned}
\tilde{\boldsymbol{x}}_{t+2\epsilon} &= \boldsymbol{x}_t + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) \\
&\quad + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon), t+\epsilon, \epsilon)
\end{aligned} \tag{17}
\end{equation}

**自洽性条件**：要求
\begin{equation}
\boldsymbol{x}_t + 2\epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) = \tilde{\boldsymbol{x}}_{t+2\epsilon} \tag{18}
\end{equation}

两边减去 $\boldsymbol{x}_t$ 并除以 $2\epsilon$：
\begin{equation}
\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) = \frac{1}{2}\left[\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) + \boldsymbol{v}_{\boldsymbol{\theta}}(\tilde{\boldsymbol{x}}_{t+\epsilon}, t+\epsilon, \epsilon)\right] \tag{19}
\end{equation}

**数学意义**：大步长的速度场应该是两个小步长速度场的平均。这是一种**时间一致性约束**。

#### 4.2 第二个损失函数：自洽性损失

基于式 (19)，我们构造自洽性损失：

\begin{equation}
\mathcal{L}_2(\boldsymbol{\theta}) = \mathbb{E}_{\boldsymbol{x}_0,\boldsymbol{x}_1,t,\epsilon}\left[\left\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) - \frac{1}{2}\left[\boldsymbol{v}_1 + \boldsymbol{v}_2\right]\right\Vert^2\right] \tag{20}
\end{equation}

其中：
\begin{equation}
\begin{aligned}
\boldsymbol{v}_1 &= \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) \\
\boldsymbol{v}_2 &= \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t + \epsilon \boldsymbol{v}_1, t+\epsilon, \epsilon) \\
\tilde{\boldsymbol{x}}_{t+\epsilon} &= \boldsymbol{x}_t + \epsilon \boldsymbol{v}_1
\end{aligned} \tag{21}
\end{equation}

**展开损失函数**：
\begin{equation}
\begin{aligned}
\mathcal{L}_2 = \mathbb{E}\bigg[&\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon)\Vert^2 \\
&- \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) \cdot [\boldsymbol{v}_1 + \boldsymbol{v}_2] \\
&+ \frac{1}{4}\Vert\boldsymbol{v}_1 + \boldsymbol{v}_2\Vert^2\bigg]
\end{aligned} \tag{22}
\end{equation}

### 5. 多尺度自洽性

#### 5.1 离散步长集合

Shortcut模型不对所有 $\epsilon \in (0,1]$ 进行训练，而是选择离散的步长集合：

\begin{equation}
\mathcal{E} = \{2^{-7}, 2^{-6}, 2^{-5}, 2^{-4}, 2^{-3}, 2^{-2}, 2^{-1}, 2^0\} \tag{23}
\end{equation}

**选择理由**：
1. **指数间隔**：$\epsilon_k = 2^{-k}$ 覆盖了从小步长到大步长的广泛范围
2. **二进制关系**：$2\epsilon_k = \epsilon_{k-1}$，自洽性条件自然成立
3. **计算效率**：有限的步长集合可以用Embedding表示

#### 5.2 递归自洽性

对于任意的 $k$，我们有：
\begin{equation}
\epsilon_{k-1} = 2\epsilon_k \tag{24}
\end{equation}

因此自洽性条件可以递归应用：
\begin{equation}
\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon_{k-1}) = \frac{1}{2}\left[\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon_k) + \boldsymbol{v}_{\boldsymbol{\theta}}(\tilde{\boldsymbol{x}}_{t+\epsilon_k}, t+\epsilon_k, \epsilon_k)\right] \tag{25}
\end{equation}

**训练策略**：
- 对每个 $\epsilon_k \in \{2^{-7}, ..., 2^{-1}\}$，随机选择时间 $t \sim U(0, 1-\epsilon_k)$
- 计算自洽性损失 $\mathcal{L}_2$ for 步长对 $(\epsilon_k, 2\epsilon_k)$
- 这确保了所有尺度上的一致性

### 6. 总损失函数与训练算法

#### 6.1 组合损失

最终的训练目标是：
\begin{equation}
\mathcal{L}(\boldsymbol{\theta}) = \lambda_1 \mathcal{L}_1(\boldsymbol{\theta}) + \lambda_2 \mathcal{L}_2(\boldsymbol{\theta}) \tag{26}
\end{equation}

**权重选择**：
- 理论上 $\lambda_1 = \lambda_2 = 1$ 即可
- 但实际中 $\mathcal{L}_2$ 涉及两次前向传播，计算量是 $\mathcal{L}_1$ 的两倍
- 论文采用策略：75% 样本用于 $\mathcal{L}_1$，25% 样本用于 $\mathcal{L}_2$
- 这相当于隐式地设置 $\lambda_1 : \lambda_2 = 3:1$

#### 6.2 Stop Gradient技巧

实际实现中，$\mathcal{L}_2$ 被修改为：
\begin{equation}
\mathcal{L}_2 = \mathbb{E}\left[\left\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) - \text{sg}\left[\frac{\boldsymbol{v}_1 + \boldsymbol{v}_2}{2}\right]\right\Vert^2\right] \tag{27}
\end{equation}

其中 $\text{sg}[\cdot]$ 是stop gradient算子。

**原因分析**：
1. **目标视角**：将 $\frac{\boldsymbol{v}_1 + \boldsymbol{v}_2}{2}$ 视为固定的"目标"
2. **计算效率**：避免对 $\boldsymbol{v}_2$ 的二次反向传播，节省内存和时间
3. **训练稳定性**：类似BYOL等自监督学习方法，防止梯度爆炸

**梯度流分析**：

不使用stop gradient时：
\begin{equation}
\frac{\partial \mathcal{L}_2}{\partial \boldsymbol{\theta}} = \frac{\partial}{\partial \boldsymbol{\theta}}\left[\text{模型预测}\right] - \frac{\partial}{\partial \boldsymbol{\theta}}\left[\frac{\boldsymbol{v}_1 + \boldsymbol{v}_2}{2}\right] \tag{28}
\end{equation}

使用stop gradient后：
\begin{equation}
\frac{\partial \mathcal{L}_2}{\partial \boldsymbol{\theta}} = \frac{\partial}{\partial \boldsymbol{\theta}}\left[\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon)\right] \tag{29}
\end{equation}

### 7. 步长Embedding的实现

#### 7.1 离散Embedding方案

由于步长集合 $\mathcal{E}$ 是有限的（9个值，包括0），可以用Embedding表示：

\begin{equation}
\epsilon \to \mathbf{e}_{\epsilon} \in \mathbb{R}^{d_{\text{emb}}} \tag{30}
\end{equation}

**实现细节**：
1. 建立映射 $\{0, 2^{-7}, ..., 2^0\} \to \{0, 1, ..., 8\}$
2. 使用Embedding层：$\mathbf{E} \in \mathbb{R}^{9 \times d_{\text{emb}}}$
3. 组合时间和步长的Embedding：
   \begin{equation}
   \mathbf{c}_{t,\epsilon} = \mathbf{e}_t + \mathbf{e}_{\epsilon} \tag{31}
   \end{equation}
4. 将 $\mathbf{c}_{t,\epsilon}$ 注入U-Net的每一层

#### 7.2 与时间Embedding的融合

**标准时间Embedding**（Sinusoidal位置编码）：
\begin{equation}
\begin{aligned}
[\mathbf{e}_t]_{2i} &= \sin\left(\frac{t}{10000^{2i/d}}\right) \\
[\mathbf{e}_t]_{2i+1} &= \cos\left(\frac{t}{10000^{2i/d}}\right)
\end{aligned} \tag{32}
\end{equation}

**组合方案**：
\begin{equation}
\mathbf{h} = \text{MLP}(\mathbf{e}_t + \mathbf{e}_{\epsilon}) \tag{33}
\end{equation}

### 8. 推理过程分析

#### 8.1 单步生成

设步长 $\epsilon = 1$，从纯噪声 $\boldsymbol{x}_0 \sim \mathcal{N}(\boldsymbol{0}, \boldsymbol{I})$ 出发：

\begin{equation}
\boldsymbol{x}_1 = \boldsymbol{x}_0 + 1 \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_0, 0, 1) \tag{34}
\end{equation}

**为什么可行**：
- 训练时的自洽性约束确保了 $\boldsymbol{v}_{\boldsymbol{\theta}}(\cdot, \cdot, 1)$ 能够"预见"整个轨迹
- 它隐式地整合了多个小步长的信息

#### 8.2 多步生成

也可以使用更小的步长 $\epsilon < 1$ 进行多步生成：

\begin{equation}
\boldsymbol{x}_{t_{k+1}} = \boldsymbol{x}_{t_k} + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{t_k}, t_k, \epsilon), \quad t_k = k\epsilon \tag{35}
\end{equation}

**质量-速度权衡**：

| 生成步数 | 步长 $\epsilon$ | FID | NFE |
|---------|----------------|-----|-----|
| 1 | 1 | ~10 | 1 |
| 2 | 0.5 | ~8 | 2 |
| 4 | 0.25 | ~6 | 4 |
| 8 | 0.125 | ~5 | 8 |

### 9. 与传统ODE求解器的对比

#### 9.1 欧拉方法（一阶）

**传统欧拉**：
\begin{equation}
\boldsymbol{x}_{t+\epsilon} = \boldsymbol{x}_t + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) \tag{36}
\end{equation}

局部误差：$O(\epsilon^2)$，全局误差：$O(\epsilon)$

**Shortcut**：
\begin{equation}
\boldsymbol{x}_{t+\epsilon} = \boldsymbol{x}_t + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) \tag{37}
\end{equation}

通过学习适应步长，减小了固定步长带来的系统误差。

#### 9.2 Heun方法（二阶）

**Heun方法**（预测-校正）：
\begin{equation}
\begin{aligned}
\tilde{\boldsymbol{x}}_{t+\epsilon} &= \boldsymbol{x}_t + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) \\
\boldsymbol{x}_{t+\epsilon} &= \boldsymbol{x}_t + \frac{\epsilon}{2}[\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) + \boldsymbol{v}_{\boldsymbol{\theta}}(\tilde{\boldsymbol{x}}_{t+\epsilon}, t+\epsilon)]
\end{aligned} \tag{38}
\end{equation}

局部误差：$O(\epsilon^3)$，全局误差：$O(\epsilon^2)$

**Shortcut的隐式Heun**：
\begin{equation}
\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) \approx \frac{1}{2}[\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) + \boldsymbol{v}_{\boldsymbol{\theta}}(\tilde{\boldsymbol{x}}_{t+\epsilon}, t+\epsilon, \epsilon)] \tag{39}
\end{equation}

这与Heun方法的思想类似，但是通过学习而非手工设计。

### 10. 理论保证与收敛性

#### 10.1 极限情况

**定理1**：当 $\epsilon \to 0$ 时，Shortcut模型收敛到精确ODE。

**证明草图**：
- 损失 $\mathcal{L}_1$ 确保了 $\lim_{\epsilon \to 0}\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon) = \boldsymbol{x}_1 - \boldsymbol{x}_0$
- 这是精确ODE的速度场
- 因此在极限下，模型是正确的

#### 10.2 有限步长的逼近质量

记 $\boldsymbol{x}_1^*$ 为精确解，$\boldsymbol{x}_1^{(\epsilon)}$ 为步长 $\epsilon$ 的近似解。

**定理2**（非正式）：在适当的正则性条件下，
\begin{equation}
\Vert\boldsymbol{x}_1^{(\epsilon)} - \boldsymbol{x}_1^*\Vert = O(\epsilon^p) \tag{40}
\end{equation}
其中 $p \geq 1$，且可能 $p > 1$（通过自洽性约束提升阶数）。

**直觉**：自洽性约束 $\mathcal{L}_2$ 强制模型在不同尺度上保持一致，这降低了离散化误差。

### 11. 实践建议与超参数

#### 11.1 训练超参数

- **批量大小**：512（其中75%用于 $\mathcal{L}_1$，25%用于 $\mathcal{L}_2$）
- **学习率**：$2 \times 10^{-4}$，使用cosine衰减
- **训练步数**：300K-500K
- **时间采样**：$t \sim U(0, 1)$ for $\mathcal{L}_1$；$t \sim U(0, 1-\epsilon)$ for $\mathcal{L}_2$
- **步长采样**：$\epsilon \sim \text{Uniform}(\mathcal{E} \setminus \{0, 1\})$ for $\mathcal{L}_2$

#### 11.2 推理超参数

- **单步生成**：$\epsilon = 1$，NFE=1
- **高质量生成**：$\epsilon = 2^{-3}$ 或 $2^{-4}$，NFE=8或16
- **可以动态调整**：前期用大步长，后期用小步长

### 12. 与相关工作的联系

#### 12.1 AMED（中值定理方法）

AMED基于积分中值定理：
\begin{equation}
\boldsymbol{x}_{t+\epsilon} - \boldsymbol{x}_t = \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_s, s) \tag{41}
\end{equation}
其中 $s \in [t, t+\epsilon]$ 需要预测。

**对比**：
- AMED：事后修正，需要额外小模型预测 $s$
- Shortcut：事先学习，将 $\epsilon$ 直接作为输入

#### 12.2 Consistency Models

Consistency Models直接学习映射 $f: (\boldsymbol{x}_t, t) \to \boldsymbol{x}_0$。

**对比**：
- Consistency：直接预测终点
- Shortcut：预测速度场，更灵活（可多步可单步）

### 13. 局限性与未来方向

#### 13.1 当前局限

1. **离散步长集合**：只训练了有限的步长，中间值需要插值
2. **步长范围**：$[2^{-7}, 1]$ 可能不够覆盖所有需求
3. **训练成本**：$\mathcal{L}_2$ 需要两次前向传播，增加了训练时间

#### 13.2 可能的改进

**连续步长Embedding**：
\begin{equation}
\mathbf{e}_{\epsilon} = \text{MLP}(\log \epsilon) \tag{42}
\end{equation}
允许任意连续的 $\epsilon \in (0, 1]$。

**自适应步长**：
\begin{equation}
\epsilon_{k+1} = f_{\boldsymbol{\phi}}(\boldsymbol{x}_{t_k}, t_k) \tag{43}
\end{equation}
根据当前状态动态选择步长。

**高阶自洽性**：
\begin{equation}
\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 4\epsilon) = g(\boldsymbol{v}_{\epsilon}, \boldsymbol{v}_{2\epsilon}) \tag{44}
\end{equation}
建立更复杂的多尺度关系。

### 14. 数学总结

#### 14.1 核心公式回顾

1. **直线轨迹**：$\boldsymbol{x}_t = (1-t)\boldsymbol{x}_0 + t\boldsymbol{x}_1$
2. **ODE速度场**：$\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon)$
3. **精确ODE损失**：$\mathcal{L}_1 = \mathbb{E}[\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 0) - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\Vert^2]$
4. **自洽性损失**：$\mathcal{L}_2 = \mathbb{E}[\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, 2\epsilon) - \frac{\boldsymbol{v}_1 + \boldsymbol{v}_2}{2}\Vert^2]$
5. **更新规则**：$\boldsymbol{x}_{t+\epsilon} = \boldsymbol{x}_t + \epsilon \cdot \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, \epsilon)$

#### 14.2 理论意义

Shortcut模型展示了：
1. **学习vs设计**：与其设计复杂的ODE求解器，不如让模型学习适应不同步长
2. **多尺度一致性**：自洽性约束是一种强大的归纳偏置
3. **单阶段训练**：无需蒸馏即可实现单步生成

这为扩散模型加速开辟了新的范式。

