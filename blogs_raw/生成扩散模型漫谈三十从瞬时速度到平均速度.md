---
title: 生成扩散模型漫谈（三十）：从瞬时速度到平均速度
slug: 生成扩散模型漫谈三十从瞬时速度到平均速度
date: 2025-05-26
tags: 微分方程, 生成模型, 采样, 扩散, 生成模型
status: completed
---

# 生成扩散模型漫谈（三十）：从瞬时速度到平均速度

**原文链接**: [https://spaces.ac.cn/archives/10958](https://spaces.ac.cn/archives/10958)

**发布日期**: 

---

众所周知，生成速度慢是扩散模型一直以来的痛点，而为了解决这个问题，大家可谓“八仙过海，各显神通”，提出了各式各样的解决方案，然而长久以来并没一项工作能够脱颖而出，成为标配。什么样的工作能够达到这个标准呢？在笔者看来，它至少满足几个条件：

> 1、数学原理清晰，能够揭示出快速生成的本质所在；
> 
> 2、能够单目标从零训练，不需要对抗、蒸馏等额外手段；
> 
> 3、单步生成接近SOTA，可以通过增加步数提升效果。

根据笔者的阅读经历，几乎没有一项工作能同时满足这三个标准。然而，就在几天前，arXiv出了一篇[《Mean Flows for One-step Generative Modeling》](https://papers.cool/arxiv/2505.13447)（简称“MeanFlow”），看上去非常有潜力。接下来，我们将以此为契机，讨论一下相关思路和进展。

## 现有思路 #

扩散模型的生成加速工作已经有非常多，本博客前面也简单介绍过一些。总的来说，加速思路大体上可以分为三类。

第一，将扩散模型转化为SDE/ODE，然后研究更高效的求解器，代表作是[DPM-Solver](https://papers.cool/arxiv/2206.00927)及其一系列后续改进。然而，这个思路通常只能将生成的NFE（Number of Function Evaluations）降到10左右，再低就会明显降低生成质量。这是因为求解器的收敛速度通常都是正比于步长的若干次方，当NFE很小时步长就无法很小，所以收敛不够快以至于没法用。

第二，通过蒸馏将训练好的扩散模型转化为更少步数的生成器，由此衍生出来的工作和方案也非常多，我们此前介绍过其中的一种名为[SiD](/archives/10085)的方案。蒸馏算是比较常规和通用的思路，但缺点也是共同的，即需要额外的训练成本，并非从零训练的方案。有些工作为了蒸馏到单步生成器，还加上了对抗训练等多重优化策略，整个方案往往过于复杂。

第二，基于一致性模型（Consistency Model，CM），包括我们在[《生成扩散模型漫谈（二十八）：分步理解一致性模型》](/archives/10633)简单介绍的CM、它的连续版本[sCM](https://papers.cool/arxiv/2410.11081)以及[CTM](https://papers.cool/arxiv/2310.02279)等。CM是自成一派的思路，可以从零训练得到NFE很小的模型，也可以用于蒸馏，但CM的目标依赖于EMA或者stop_gradient运算，意味着它耦合了优化器动力学，这通常给人一种说不清道不明的感觉。

## 瞬时速度 #

到目前为止，生成NFE最小的扩散模型，基本上都是ODE，因为确定性模型往往更容易分析和求解。本文同样只关注ODE式扩散，所用框架是[《生成扩散模型漫谈（十七）：构建ODE的一般步骤（下）》](/archives/9497)介绍的ReFlow，它跟[Flow Matching](https://papers.cool/arxiv/2210.02747)本质是相通的，但更加直观。

ODE式扩散，是希望学习一个ODE  
\begin{equation}\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)\label{eq:ode}\end{equation}  
来构建一个$\boldsymbol{x}_1\to \boldsymbol{x}_0$的变换。具体来说，设$\boldsymbol{x}_1\sim p_1(\boldsymbol{x}_1)$是某个容易采样的随机噪声，$\boldsymbol{x}_0\sim p_0(\boldsymbol{x}_0)$则是目标分布的真实样本，我们希望能够通过上述ODE，实现随机噪声到目标样本的变换，即随机采样一个$\boldsymbol{x}_1\sim p_1(\boldsymbol{x}_1)$作为初值，求解上述ODE得到的$\boldsymbol{x}_0$就是$p_0(\boldsymbol{x}_0)$的样本。

如果将$t$看成时间，$\boldsymbol{x}_t$看成位移，那么$d\boldsymbol{x}_t/dt$就是瞬时速度，所以ODE式扩散就是瞬时速度的建模。那怎么训练$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$呢？ReFlow提出了一种非常直观的方法：首先构建$\boldsymbol{x}_0$与$\boldsymbol{x}_1$的任意插值方式，如最简单的线性插值$\boldsymbol{x}_t=(1-t)\boldsymbol{x}_0 + t \boldsymbol{x}_1$，那么对$t$求导得  
\begin{equation}\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{x}_1 - \boldsymbol{x}_0\end{equation}  
这是个极简单的ODE，但不符合我们的要求，因为$\boldsymbol{x}_0$是我们的目标，它不应该出现在ODE中。对此，ReFlow提出一个非常符合直觉的想法——用$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$去逼近$\boldsymbol{x}_1 - \boldsymbol{x}_0$：  
\begin{equation}\mathbb{E}_{t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\Vert\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\Vert^2\right]\label{eq:loss-reflow}\end{equation}  
这就是ReFlow的目标函数。值得指出的是：1）ReFlow理论上允许$\boldsymbol{x}_0$与$\boldsymbol{x}_1$的任意插值方式；2）ReFlow虽然直观，但理论上也是严格的，可以证明它的最优解确实是我们所求的ODE。相关细节大家请参考[《生成扩散模型漫谈（十七）：构建ODE的一般步骤（下）》](/archives/9497)以及原论文。

## 平均速度 #

然而，ODE仅仅是一个纯数学形式，实际求解还是需要离散化，比如最简单的欧拉格式：  
\begin{equation}\boldsymbol{x}_{t - \Delta t} = \boldsymbol{x}_t - \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) \Delta t\end{equation}  
从$1$到$0$的NFE是$1/\Delta t$，想要NFE小等价于$\Delta t$大。然而，ReFlow的理论基础是精确的ODE，即精确求解ODE时才能实现目标样本的生成，这意味着$\Delta t$越小越好，跟我们的期望相背。尽管ReFlow声称使用直线插值可以让ODE的轨迹变得更直，从而允许更大的$\Delta t$，但实际轨迹终究是弯曲的，$\Delta t$很难接近1，所以ReFlow很难实现一步生成。

归根结底，ODE本来就是$\Delta t\to 0$的东西，我们非要将它用于$\Delta t \to 1$，还要求它效果好，这本身就是“强模型所难”了。所以说，更换建模目标，而不是继续“为难”模型，才是实现更快生成的本质思路。为此，我们考虑对式$\eqref{eq:ode}$两端进行积分  
\begin{equation}\boldsymbol{x}_t - \boldsymbol{x}_r = \int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau = (t-r)\times \frac{1}{t-r}\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau\end{equation}  
如果我们可以建模  
\begin{equation} \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \triangleq \frac{1}{t-r}\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau\end{equation}  
那么就有$\boldsymbol{x}_0 = \boldsymbol{x}_1 - \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_1, 0, 1)$，即理论上可以精准地实现一步生成，而不必求诸于近似关系。如果说$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$是$t$时刻的瞬时速度，那么很显然$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$是$[r,t]$时间段内的平均速度。也就是说，为了加速生成甚至一步生成，我们的建模目标应该是平均速度，而不是ODE的瞬时速度。

## 恒等变换 #

当然，从瞬时速度到平均速度的转变并不难想，真正难的地方是如何给它构建损失函数。ReFlow只告诉我们如何给瞬时速度构建损失函数，对平均速度的训练我们是一无所知。

接下来很自然的想法是“化未知为已知”，即以平均速度$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$来为出发点来构建瞬时速度$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$，然后代入ReFlow的目标函数，这需要我们去推导两者之间的恒等变换。从$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$的定义我们得到  
\begin{equation} \int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau = (t-r)\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \end{equation}  
两边对$t$求导，得到  
\begin{equation}\begin{aligned}  
\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) =&\, \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\frac{d}{dt}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \\\  
=&\, \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\left[\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right]  
\end{aligned}\label{eq:id1}\end{equation}  
这便是$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$跟$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$的第一个恒等关系。有第一自然就有第二，第二个恒等关系由平均速度的定义得到：  
\begin{equation}\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) = \lim_{r\to t}\frac{1}{t-r}\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau = \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)\label{eq:id2}\end{equation}  
说白了，无限小区间内的平均速度，就等于瞬时速度。

## 第一目标 #

根据$d\boldsymbol{x}_t/dt = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$以及恒等式$\eqref{eq:id2}$，我们可以将恒等式$\eqref{eq:id1}$的$d\boldsymbol{x}_t/dt$换成$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$或者$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)$，前者是隐式关系，我们后面再谈，我们先看后者，此时有：  
\begin{equation}\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) = \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right]\end{equation}  
代入ReFlow，我们得到可以用来训练$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$的第一个目标函数：  
\begin{equation}\mathbb{E}_{r,t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\left\Vert\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\right\Vert^2\right]\label{eq:loss-1}\end{equation}  
这是一个非常理想的结果，它满足我们对生成模型目标函数的所有期望：

> 1、单个显式的最小化目标；
> 
> 2、没有EMA、stop_gradient等运算；
> 
> 3、理论上有保证（ReFlow）。

这些特性意味着，不管我们用什么优化算法，只要我们能找到上式的最小值点，那么它就是我们想要的平均速度模型，即理论上能够实现一步生成的生成模型。换句话说，它具备了扩散模型的训练简单和理论保证，又能像GAN那样一步生成，还不用求神拜佛保佑模型别“想不开”而训崩。

## JVP运算 #

不过，对于部分读者来说，目标函数$\eqref{eq:loss-1}$的实现还是有点困难的，因为它涉及到普通用户比较少见的“雅可比向量积（Jacobian-Vector Product，JVP）”。具体来说，我们可以将目标函数内方括号部分写成：  
\begin{equation}\underbrace{\left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t),0,1\right] \\\\[10pt]}_{\text{向量}}\cdot\underbrace{\left[\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t), \frac{\partial}{\partial r}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t), \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] \\\\[10pt]}_{\text{雅可比矩阵}}\end{equation}  
即$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$的雅可比矩阵与给定向量$[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t),0,1]$的乘法，结果是一个跟$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$大小一致的向量，这种运算就叫做JVP，在Jax、Torch里边都有现成实现，比如Jax的参考代码是：
    
    
    u = lambda xt, r, t: diffusion_model(weights, [xt, r, t])
    urt, durt = jax.jvp(u, (xt, r, t), (u(xt, t, t), r * 0, t * 0 + 1))

其中`urt`就是$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$，而`durt`就是对应的JVP结果，Torch的用法也类似。了解JVP运算后，目标函数$\eqref{eq:loss-1}$的实现就基本上没有难度了。

## 第二目标 #

如果要说目标函数$\eqref{eq:loss-1}$的缺点，在笔者看来只有一个，那就是计算量相对偏大。这是因为它要进行两次不同的前向传播$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$和$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)$，然后JVP求了一次梯度，用基于梯度下降优化时还要再求一次梯度，所以它本质上要求二阶梯度，跟以往的[WGAN-GP](/archives/4439)类似。

为了降低计算量，我们可以考虑给JVP部分加上stop_gradient运算（$\newcommand{\sg}[1]{\color{skyblue}{\mathop{\text{sg}}\left[\color{blue}{#1}\right]}}\sg{\cdot}$）：  
\begin{equation}\mathbb{E}_{r,t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\left\Vert\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\sg{\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)} - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\right\Vert^2\right]\label{eq:loss-2}\end{equation}  
这样就避免了对JVP再次求梯度（但依然需要两次前向传播）。实测结果显示，相比第一目标$\eqref{eq:loss-1}$，上述目标在梯度优化器下训练速度能够快将近一倍，并且效果目测无损。

注意，这里的stop_gradient单纯是出于减少计算量的目的，实际优化方向依然是损失函数值越小越好，这跟CM系列模型尤其是sCM是不一样的，它们的损失函数只是具有等效梯度的等效损失，并不一定是越小越好，它们的stop_gradient往往是必须的，一旦去掉几乎可以肯定会训练崩溃。

## 第三目标 #

前面我们提到，处理恒等式$\eqref{eq:id1}$中的$d\boldsymbol{x}_t/dt$的另一个方案是将其换成$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$，这将导致  
\begin{equation}\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) = \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\left[\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right]\end{equation}  
如果要从中解出$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$，结果将是  
\begin{equation}\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) = \left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right]\cdot\left[\boldsymbol{I} - (t-r)\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right]^{-1}\end{equation}  
这涉及到了非常庞大的矩阵求逆，因此并不现实。MeanFlow给出了一个折中方案：既然$d\boldsymbol{x}_t/dt = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$的回归目标是$\boldsymbol{x}_1-\boldsymbol{x}_0$，那干脆把$d\boldsymbol{x}_t/dt$换成$\boldsymbol{x}_1-\boldsymbol{x}_0$好了，于是目标函数变成  
\begin{equation}\mathbb{E}_{r,t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\left\Vert\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\left[(\boldsymbol{x}_1-\boldsymbol{x}_0)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\right\Vert^2\right]\end{equation}  
然而，此时的$\boldsymbol{x}_1-\boldsymbol{x}_0$既是回归目标，又出现在模型$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$的定义中，难免会有一种“标签泄漏”的感觉。为了避免这个问题，MeanFlow采取的办法同样是给JVP部分加上stop_gradient：  
\begin{equation}\mathbb{E}_{r,t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\left\Vert\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\sg{(\boldsymbol{x}_1-\boldsymbol{x}_0)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)} - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\right\Vert^2\right]\label{eq:loss-3}\end{equation}  
这就是MeanFlow最终所用的损失函数，这里我们称之为“第三目标”。相比第二目标$\eqref{eq:loss-2}$，它少了一次前向传播$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)$，所以训练速度会更快一些。但此时“标签泄漏”的引入和stop_gradient的对策，使得第三目标的训练跟梯度优化器是耦合的，这就跟CM一样，多了一些说不清道不明的神秘感。

论文实验结果表明，加上$\sg{\cdot}$的目标$\eqref{eq:loss-3}$是能训出合理结果的，那如果去掉它呢？笔者向作者请教过，他表明去掉$\sg{\cdot}$后，训练依然能收敛，能多步生成，但没有一步生成能力了。其实这也不难理解，因为$r=t$时不管有没有$\sg{\cdot}$，目标函数都退化为ReFlow：  
\begin{equation}\mathbb{E}_{t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\Vert\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t) - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\Vert^2\right]\label{eq:loss-reflow-2}\end{equation}  
也就是说MeanFlow总有ReFlow在背后“兜底”，因此怎样也不至于太差。而去掉$\sg{\cdot}$后，“标签泄漏”的负面影响加剧，因此就不如加上它了。

## 证明一下 #

我们能否像ReFlow一样，从理论上证明第三目标$\eqref{eq:loss-3}$的最优解确实是我们期望的平均速度模型呢？让我们尝试一下。首先我们回顾证明ReFlow的两个关键引理：

> 1、$\mathop{\text{argmin}}_{\boldsymbol{\mu}}\mathbb{E}[\Vert\boldsymbol{\mu} - \boldsymbol{x}\Vert^2] = \mathbb{E}[\boldsymbol{x}]$，即最小化$\boldsymbol{\mu}$与$\boldsymbol{x}$的平方误差，最优解是$\boldsymbol{x}$的均值；
> 
> 2、按照分布轨迹$\boldsymbol{x}_t=(1-t)\boldsymbol{x}_0 + t \boldsymbol{x}_1$将$\boldsymbol{x}_1$变到$\boldsymbol{x}_0$的ODE形式解是$d\boldsymbol{x}_t/dt = \mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}[\boldsymbol{x}_1-\boldsymbol{x}_0]$。

其中，引理1的证明比较简单，直接对$\boldsymbol{\mu}$求梯度得$\mathbb{E}[\boldsymbol{\mu} - \boldsymbol{x}] = \boldsymbol{\mu} - \mathbb{E}[\boldsymbol{x}]$，令它等于零即可；引理2的证明细节则需要看[《生成扩散模型漫谈（十七）：构建ODE的一般步骤（下）》](/archives/9497)，其中$\mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}[\boldsymbol{x}_1-\boldsymbol{x}_0]$是需要先利用$\boldsymbol{x}_t=(1-t)\boldsymbol{x}_0 + t \boldsymbol{x}_1$消去$\boldsymbol{x}_1$，得到一个$\boldsymbol{x}_0,\boldsymbol{x}_t$的函数，然后对分布$p_t(\boldsymbol{x}_0|\boldsymbol{x}_t)$求期望，结果是关于$t,\boldsymbol{x}_t$的函数。

利用引理1，我们可以证明ReFlow的目标函数$\eqref{eq:loss-reflow}$的理论最优解就是$\boldsymbol{v}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t,t) = \mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}[\boldsymbol{x}_1-\boldsymbol{x}_0]$，结合引理2就得到$d\boldsymbol{x}_t/dt=\boldsymbol{v}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t,t)$是我们所求的ODE。第三目标$\eqref{eq:loss-3}$的证明类似，由于里边有$\sg{\cdot}$，对$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$求梯度并让它等于零的结果是  
\begin{equation}\begin{aligned}  
\boldsymbol{0} =&\, \boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + \mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}\left[(t-r)\left[(\boldsymbol{x}_1-\boldsymbol{x}_0)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t)\right] - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\right] \\\  
=&\, \boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + (t-r)\left[\mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}[\boldsymbol{x}_1-\boldsymbol{x}_0]\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t)\right] - \mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}[\boldsymbol{x}_1 - \boldsymbol{x}_0] \\\  
=&\, \boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + (t-r)\left[\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t)\right] - \frac{d\boldsymbol{x}_t}{dt} \\\  
=&\, \frac{d}{dt}\left[(t - r) \boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) - (\boldsymbol{x}_t - \boldsymbol{x}_r)\right] \\\  
\end{aligned}\end{equation}  
所以在适当的边界条件下就有$\boldsymbol{x}_t - \boldsymbol{x}_r = (t - r) \boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t)$，即我们期望的平均速度模型。

这个过程的关键是$\sg{\cdot}$的引入避免了对JVP部分求梯度，从而简化了梯度表达式并得到了正确的结果。如果去掉$\sg{\cdot}$的话，上式右端就要多乘一项JVP部分对$\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t)$的雅可比矩阵，结果就是最后无法将$\frac{d}{dt}\left[(t - r) \boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) - (\boldsymbol{x}_t - \boldsymbol{x}_r)\right]$这一项分离出来，而引入$\sg{\cdot}$的数学意义便是为了解决此问题。

当然，笔者还是那句话，$\sg{\cdot}$的引入也使得整个模型的训练耦合了梯度优化器，多了一丝不清晰的感觉。此时梯度等于零的点，顶多算是一个驻点而非（局部）最小值点，所以稳定性也不明朗，这其实也是所有耦合$\sg{\cdot}$的模型的共性。

## 相关工作 #

非常有趣的是，我们之前介绍过的两篇加速生成的文章[《生成扩散模型漫谈（二十一）：中值定理加速ODE采样》](/archives/9881)和[《生成扩散模型漫谈（二十七）：将步长作为条件输入》](/archives/10617)，也都是以平均速度为核心的，并且思想上可以说是一脉相承的。尽管作者之间未必相互有联系，但他们的工作内容上确实给人一种承前启后的连贯感。

在中值定理篇，作者已经意识到了平均速度  
\begin{equation}\frac{1}{t-r}\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau\end{equation}  
的重要性，但他的做法是类比一维函数的积分中值定理，试图寻找$s\in[r,t]$使得$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_s,s)$等于平均速度。这本质上还是寻找高阶Solver的思想，但不再是Training-Free，而是需要少量的蒸馏步骤，对Solver来说算是一个小突破。

而步长输入篇所提的Shortcut模型，则几乎已经触碰到了MeanFlow，因为步长作为额外输入，跟MeanFlow的双时间参数$r,t$实质是等价的，不同的是它是直接以平均速度的性质作为额外的正则项来训练模型。用本文的记号，平均速度应该满足的性质是  
\begin{equation}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) = \frac{1}{2}\left[\boldsymbol{u}_{\boldsymbol{\theta}}\left(\boldsymbol{x}_t, s, t\right) + \boldsymbol{u}_{\boldsymbol{\theta}}\left(\boldsymbol{x}_s, r, s\right)\right]\end{equation}  
其中$s = (r+t)/2$。所以Shortcut干脆以它来构建正则项  
\begin{equation}\left\Vert\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) - \frac{1}{2}\sg{\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, s, t) + \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_s, r, s)}\right\Vert^2\end{equation}  
跟ReFlow的目标$\eqref{eq:loss-reflow-2}$混合训练，实际训练中$\boldsymbol{x}_s = \boldsymbol{x}_t - (t-s)\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, s, t)$，$\sg{\cdot}$的引入在笔者看来主要也是为了节省计算量。Shortcut模型其实比MeanFlow更直观，但由于没有恒等变换和ReFlow带来的严格理论支撑，使得它看上去更多是一个过渡期的经验产物。

## 一致模型 #

最后我们再来讨论一下一致性模型。由于CM、sCM珠玉在前，MeanFlow的成功实际上也借鉴了它们的经验，尤其是给JVP加$\sg{\cdot}$的操作，这在原论文中也有提到。当然，MeanFlow作者之一何恺明老师本身也是操控梯度的大师（比如[SimSiam](/archives/7980)），所以MeanFlow的出现看起来是非常水到渠成的。

离散的CM我们在[《生成扩散模型漫谈（二十八）：分步理解一致性模型》](/archives/10633)仔细分析过，如果将其中CM的EMA算符换成stop_gradient，求梯度并取$\Delta t\to 0$的极限，那么就得到了[《Simplifying, Stabilizing and Scaling Continuous-Time Consistency Models》](https://papers.cool/arxiv/2410.11081)中的sCM的目标函数：  
\begin{equation}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)\cdot \frac{d}{dt}\boldsymbol{f}_{\sg{\boldsymbol{\theta}}}(\boldsymbol{x}_t, t) = \boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)\cdot\sg{\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) + \frac{\partial}{\partial t}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)}\label{eq:loss-scm}\end{equation}  
如果将$\frac{d\boldsymbol{x}_t}{dt}$换成$\boldsymbol{x}_1 - \boldsymbol{x}_0$，然后记$\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) = \boldsymbol{x}_t - t\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t , 0, t)$，那么它的梯度跟$r=0$时的MeanFlow第三目标$\eqref{eq:loss-3}$是等价的：  
\begin{equation}\begin{aligned}  
\nabla_{\boldsymbol{\theta}}\eqref{eq:loss-scm} =&\, \nabla_{\boldsymbol{\theta}}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)\cdot \left[\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) + \frac{\partial}{\partial t}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)\right] \\\\[10pt]  
=&\, -t\nabla_{\boldsymbol{\theta}}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t)\cdot \left[\frac{d\boldsymbol{x}_t}{dt} - t\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) - \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) - t\frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t)\right] \\\\[10pt]  
=&\, t\nabla_{\boldsymbol{\theta}}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t)\cdot \left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) + t\left[\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t)\right]- \frac{d\boldsymbol{x}_t}{dt}\right] \\\\[10pt]  
=&\, \frac{t}{2}\nabla_{\boldsymbol{\theta}}\left\Vert\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) + t\sg{\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t)}- \frac{d\boldsymbol{x}_t}{dt}\right\Vert^2 \\\\[10pt]  
\sim &\, \left.\nabla_{\boldsymbol{\theta}}\eqref{eq:loss-3}\right|_{r=0}  
\end{aligned}\end{equation}

所以，从这个角度看，sCM是MeanFlow在$r=0$时的一个特例。正如前面所说，引入另外的时间参数$r$可以让ReFlow给MeanFlow“兜底”（$r=t$时），从而更好地避免训崩，这是它的优点之一。当然，从sCM出发其实也可以引入双时间参数，得到跟第三目标完全相同的结果，但从个人的审美来看，CM、sCM的物理意义终究不如MeanFlow平均速度的诠释直观。

此外，平均速度和ReFlow结合的出发点，还可以得到另外的第一目标$\eqref{eq:loss-1}$和第二目标$\eqref{eq:loss-2}$，这对于像笔者这样的stop_gradient洁癖患者来说是非常舒适和漂亮的结果。在笔者看来，从计算成本出发，我们是可以考虑给损失函数加上stop_gradient，但推导的第一性原理和基本结果不应该跟stop_gradient耦合，否则意味着它跟优化器和动力学是强耦合的，这并不是一个本质结果应有的表现。

## 文章小结 #

本文以最近出来的MeanFlow为中心，讨论了“平均速度”视角下的扩散模型加速生成思路。

_**转载到请包括本文地址：**<https://spaces.ac.cn/archives/10958>_

_**更详细的转载事宜请参考：**_[《科学空间FAQ》](https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8 "《科学空间FAQ》")

**如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。**

**如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！**

打赏

![科学空间](https://spaces.ac.cn/usr/themes/geekg/payment/wx.png)

微信打赏

![科学空间](https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png)

支付宝打赏

因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以[**点击这里**](http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=tN7d1drY3drrx8H0xcWa19vZ)或在下方评论区留言来告知你的建议或需求。

**如果您需要引用本文，请参考：**

苏剑林. (May. 26, 2025). 《生成扩散模型漫谈（三十）：从瞬时速度到平均速度 》[Blog post]. Retrieved from <https://spaces.ac.cn/archives/10958>

@online{kexuefm-10958,  
title={生成扩散模型漫谈（三十）：从瞬时速度到平均速度},  
author={苏剑林},  
year={2025},  
month={May},  
url={\url{https://spaces.ac.cn/archives/10958}},  
} 


---

## 公式推导与注释

### 1. 核心概念与数学框架

#### 1.1 ODE式扩散模型的基本设定

在扩散模型中,我们的目标是学习一个从简单分布(如标准正态分布)到复杂数据分布的变换。ODE式扩散模型通过以下常微分方程来实现这一变换:

$$\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) \tag{1}$$

**符号说明:**
- $\boldsymbol{x}_t$: 时刻$t$的状态变量,可以理解为图像在加噪过程中的中间状态
- $t \in [0,1]$: 时间参数,通常$t=1$对应纯噪声,$t=0$对应真实数据
- $\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t)$: 参数化的速度场,描述状态变化的瞬时速度
- $\boldsymbol{\theta}$: 神经网络参数

**物理直觉:** 将$t$看作时间,$\boldsymbol{x}_t$看作位移,则$\frac{d\boldsymbol{x}_t}{dt}$就是瞬时速度。

#### 1.2 ReFlow框架

ReFlow提供了一种直观的方法来训练速度场$\boldsymbol{v}_{\boldsymbol{\theta}}$。其核心思想是:

1. **构建插值路径:** 在数据点$\boldsymbol{x}_0$和噪声点$\boldsymbol{x}_1$之间构建插值
   $$\boldsymbol{x}_t = (1-t)\boldsymbol{x}_0 + t\boldsymbol{x}_1 \tag{2}$$

2. **计算精确速度:** 对插值路径求导得到精确的速度场
   $$\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{x}_1 - \boldsymbol{x}_0 \tag{3}$$

3. **监督学习:** 用神经网络$\boldsymbol{v}_{\boldsymbol{\theta}}$拟合这个速度场
   $$\mathcal{L}_{\text{ReFlow}} = \mathbb{E}_{t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\|\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\|^2\right] \tag{4}$$

**理论保证:** 可以证明,当损失函数最小化时,学到的ODE确实能将噪声分布$p_1$变换为数据分布$p_0$。

### 2. 从瞬时速度到平均速度的动机

#### 2.1 ODE离散化的问题

在实际应用中,我们需要对ODE进行离散化求解。最简单的欧拉方法为:

$$\boldsymbol{x}_{t-\Delta t} = \boldsymbol{x}_t - \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) \Delta t \tag{5}$$

**关键矛盾:**
- **理论要求:** ODE的精确求解需要$\Delta t \to 0$,即步长越小越好
- **实际需求:** 为了加速生成,我们希望$\Delta t$尽可能大,最好$\Delta t = 1$实现一步生成
- **性能问题:** ReFlow虽然声称直线插值使轨迹更直,但实际轨迹仍有弯曲,$\Delta t$很难接近1

#### 2.2 平均速度的定义

为了解决这个矛盾,我们考虑对ODE两端积分:

$$\int_r^t \frac{d\boldsymbol{x}_{\tau}}{d\tau} d\tau = \int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau \tag{6}$$

左端积分为:
$$\boldsymbol{x}_t - \boldsymbol{x}_r = \int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau \tag{7}$$

**改写为平均速度形式:**
$$\boldsymbol{x}_t - \boldsymbol{x}_r = (t-r) \cdot \frac{1}{t-r}\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau \tag{8}$$

**定义平均速度:**
$$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \triangleq \frac{1}{t-r}\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau \tag{9}$$

**核心优势:** 如果能直接建模平均速度$\boldsymbol{u}_{\boldsymbol{\theta}}$,则有:
$$\boldsymbol{x}_0 = \boldsymbol{x}_1 - \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_1, 0, 1) \tag{10}$$

这样就可以**理论上精确地**实现一步生成,无需依赖离散化近似!

### 3. 瞬时速度与平均速度的恒等变换

#### 3.1 第一个恒等关系的推导

从平均速度的定义出发:
$$\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau = (t-r)\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \tag{11}$$

**两端对$t$求导** (应用Leibniz积分法则):

左端求导:
$$\frac{d}{dt}\left[\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau\right] = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) \tag{12}$$

右端求导(应用乘积法则):
$$\frac{d}{dt}\left[(t-r)\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] = \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\frac{d}{dt}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \tag{13}$$

**对$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$应用链式法则:**

$\boldsymbol{u}_{\boldsymbol{\theta}}$是关于$\boldsymbol{x}_t$和$t$的函数,因此全导数为:
$$\frac{d}{dt}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) = \frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \tag{14}$$

**第一个恒等关系:**
结合(12)-(14),得到:
$$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) = \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\left[\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] \tag{15}$$

#### 3.2 第二个恒等关系的推导

从平均速度的定义,考虑极限情况$r \to t$:

$$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) = \frac{1}{t-r}\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau \tag{16}$$

**应用L'Hôpital法则或积分中值定理:**

当$r \to t$时,分子分母都趋于0,应用L'Hôpital法则:
$$\lim_{r \to t} \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) = \lim_{r \to t} \frac{\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau}{t-r} \tag{17}$$

对分子求导(对$r$):
$$\frac{\partial}{\partial r}\left[\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau\right] = -\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_r,r) \tag{18}$$

对分母求导:
$$\frac{\partial}{\partial r}(t-r) = -1 \tag{19}$$

因此:
$$\lim_{r \to t} \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) \tag{20}$$

**第二个恒等关系:**
$$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) = \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t) \tag{21}$$

**物理直觉:** 无限小时间区间内的平均速度就等于瞬时速度。

### 4. MeanFlow的三个训练目标

#### 4.1 第一目标的推导(最理想)

**策略:** 用平均速度$\boldsymbol{u}_{\boldsymbol{\theta}}$来表达瞬时速度$\boldsymbol{v}_{\boldsymbol{\theta}}$,然后代入ReFlow目标。

**步骤1:** 将第二恒等关系(21)代入第一恒等关系(15)中的$\frac{d\boldsymbol{x}_t}{dt}$:

$$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) = \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] \tag{22}$$

**步骤2:** 代入ReFlow的损失函数(4):

$$\mathcal{L}_1 = \mathbb{E}_{r,t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\left\|\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\right\|^2\right] \tag{23}$$

**优点分析:**
1. **单一目标:** 只有一个最小化目标,没有对抗或多目标优化
2. **无EMA:** 不需要指数移动平均,训练更稳定
3. **无stop_gradient:** 不依赖梯度截断技巧
4. **理论保证:** 继承ReFlow的理论保证

**计算要求:**
- 需要两次前向传播: $\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$和$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)$
- 需要计算JVP(雅可比向量积)
- 反向传播时需要二阶梯度

#### 4.2 雅可比向量积(JVP)的理解

**定义:** 给定函数$f: \mathbb{R}^n \to \mathbb{R}^m$和切向量$\boldsymbol{v} \in \mathbb{R}^n$,JVP计算:

$$\text{JVP}(f, \boldsymbol{v}) = J_f \cdot \boldsymbol{v} = \frac{\partial f}{\partial \boldsymbol{x}} \boldsymbol{v} \tag{24}$$

其中$J_f \in \mathbb{R}^{m \times n}$是雅可比矩阵。

**在MeanFlow中的应用:**

函数: $f(\boldsymbol{x}_t, r, t) = \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$

输入向量: $(\boldsymbol{x}_t, r, t)$

切向量: $(\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t), 0, 1)$

JVP结果:
$$\text{JVP} = \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t) \cdot \frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + 0 \cdot \frac{\partial}{\partial r}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + 1 \cdot \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \tag{25}$$

**计算效率:** JVP的计算复杂度与前向传播相同,远小于完整雅可比矩阵的计算。

#### 4.3 第二目标(减少计算量)

**问题:** 第一目标需要对JVP再次求梯度,计算量较大。

**解决方案:** 对JVP部分添加stop_gradient:

$$\mathcal{L}_2 = \mathbb{E}_{r,t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\left\|\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\text{sg}\left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\right\|^2\right] \tag{26}$$

其中$\text{sg}[\cdot]$表示stop_gradient操作。

**梯度分析:**

对$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$求梯度时:

不含stop_gradient的项:
$$\nabla_{\boldsymbol{\theta}} \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \tag{27}$$

含stop_gradient的项不产生梯度:
$$\nabla_{\boldsymbol{\theta}} \text{sg}[...] = 0 \tag{28}$$

**效果:**
- 训练速度提升约2倍
- 实验表明效果无明显损失
- 仍需两次前向传播

**与Consistency Model的区别:**
- MeanFlow的stop_gradient是为了**计算效率**
- 损失函数值越小越好(真实的优化目标)
- CM的stop_gradient是为了**算法正确性**
- CM的损失不一定越小越好(仅保证梯度等效)

#### 4.4 第三目标(MeanFlow论文使用)

**动机:** 进一步减少计算量,去掉第二次前向传播$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t)$。

**策略:** 用$\boldsymbol{x}_1 - \boldsymbol{x}_0$替换$\frac{d\boldsymbol{x}_t}{dt}$:

从ReFlow我们知道$\frac{d\boldsymbol{x}_t}{dt}$的回归目标就是$\boldsymbol{x}_1 - \boldsymbol{x}_0$,因此在第一恒等关系(15)中:

$$\boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t,t) \approx \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\left[(\boldsymbol{x}_1-\boldsymbol{x}_0)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] \tag{29}$$

**标签泄漏问题:** $\boldsymbol{x}_1 - \boldsymbol{x}_0$既是回归目标,又出现在模型定义中。

**解决方案:** 添加stop_gradient:

$$\mathcal{L}_3 = \mathbb{E}_{r,t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\left\|\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\text{sg}\left[(\boldsymbol{x}_1-\boldsymbol{x}_0)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)\right] - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\right\|^2\right] \tag{30}$$

**特殊情况分析($r=t$):**

当$r=t$时,目标退化为:
$$\mathcal{L}_3|_{r=t} = \mathbb{E}_{t,\boldsymbol{x}_0,\boldsymbol{x}_1}\left[\|\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t, t) - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\|^2\right] \tag{31}$$

这正是ReFlow的目标!因此ReFlow为MeanFlow"兜底",保证训练不会太差。

**优缺点:**
- 优点: 只需一次前向传播,最快
- 缺点: 与优化器耦合,有"神秘感"

### 5. 理论证明与收敛性分析

#### 5.1 ReFlow的理论基础

**引理1(回归最优解):**

$$\mathop{\text{argmin}}_{\boldsymbol{\mu}} \mathbb{E}[\|\boldsymbol{\mu} - \boldsymbol{x}\|^2] = \mathbb{E}[\boldsymbol{x}] \tag{32}$$

**证明:**
对$\boldsymbol{\mu}$求导:
$$\frac{\partial}{\partial \boldsymbol{\mu}} \mathbb{E}[\|\boldsymbol{\mu} - \boldsymbol{x}\|^2] = 2\mathbb{E}[\boldsymbol{\mu} - \boldsymbol{x}] = 2(\boldsymbol{\mu} - \mathbb{E}[\boldsymbol{x}]) \tag{33}$$

令导数为零:
$$\boldsymbol{\mu} = \mathbb{E}[\boldsymbol{x}] \tag{34}$$

**引理2(ODE的概率流形式):**

对于插值轨迹$\boldsymbol{x}_t = (1-t)\boldsymbol{x}_0 + t\boldsymbol{x}_1$,将$\boldsymbol{x}_1$到$\boldsymbol{x}_0$的最优ODE为:

$$\frac{d\boldsymbol{x}_t}{dt} = \mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}[\boldsymbol{x}_1 - \boldsymbol{x}_0] \tag{35}$$

**直觉理解:**
- 在$\boldsymbol{x}_t$处,下一步应该朝着期望方向移动
- 期望是对所有可能的$\boldsymbol{x}_0$(给定$\boldsymbol{x}_t$)取平均

**ReFlow的收敛性:**

最优解满足:
$$\boldsymbol{v}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, t) = \mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}[\boldsymbol{x}_1 - \boldsymbol{x}_0] \tag{36}$$

代入引理2,得到正确的ODE。

#### 5.2 第三目标的理论证明

**目标:** 证明$\mathcal{L}_3$的最优解是期望的平均速度模型。

**步骤1:** 对$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t)$求梯度并令其为零。

由于有stop_gradient,梯度为:
$$\nabla_{\boldsymbol{u}_{\boldsymbol{\theta}}} \mathcal{L}_3 = 2\mathbb{E}\left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) + (t-r)\text{sg}[...] - (\boldsymbol{x}_1 - \boldsymbol{x}_0)\right] \nabla_{\boldsymbol{u}_{\boldsymbol{\theta}}} \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) \tag{37}$$

令梯度为零:
$$\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + (t-r)\mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}\left[(\boldsymbol{x}_1-\boldsymbol{x}_0)\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t)\right] = \mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}[\boldsymbol{x}_1 - \boldsymbol{x}_0] \tag{38}$$

**步骤2:** 利用引理2,将$\mathbb{E}_{\boldsymbol{x}_0|\boldsymbol{x}_t}[\boldsymbol{x}_1 - \boldsymbol{x}_0]$替换为$\frac{d\boldsymbol{x}_t}{dt}$:

$$\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + (t-r)\left[\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t)\right] = \frac{d\boldsymbol{x}_t}{dt} \tag{39}$$

**步骤3:** 识别全导数结构。

注意到:
$$\frac{d}{dt}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) = \frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + \frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) \tag{40}$$

方程(39)可改写为:
$$\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + (t-r)\frac{d}{dt}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) = \frac{d\boldsymbol{x}_t}{dt} \tag{41}$$

**步骤4:** 应用乘积法则。

注意到:
$$\frac{d}{dt}\left[(t-r)\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t)\right] = \boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) + (t-r)\frac{d}{dt}\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) \tag{42}$$

因此方程(41)等价于:
$$\frac{d}{dt}\left[(t-r)\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t)\right] = \frac{d\boldsymbol{x}_t}{dt} \tag{43}$$

**步骤5:** 积分得到结果。

对方程(43)从$r$到$t$积分:
$$\int_r^t \frac{d}{d\tau}\left[(\tau-r)\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_{\tau}, r, \tau)\right] d\tau = \int_r^t \frac{d\boldsymbol{x}_{\tau}}{d\tau} d\tau \tag{44}$$

左端:
$$(t-r)\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) - 0 = (t-r)\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) \tag{45}$$

右端:
$$\boldsymbol{x}_t - \boldsymbol{x}_r \tag{46}$$

**最终结果:**
$$\boldsymbol{x}_t - \boldsymbol{x}_r = (t-r)\boldsymbol{u}_{\boldsymbol{\theta}^*}(\boldsymbol{x}_t, r, t) \tag{47}$$

这正是平均速度的定义!证明完毕。

**stop_gradient的必要性分析:**

如果去掉stop_gradient,求梯度时会多出JVP部分对$\boldsymbol{u}_{\boldsymbol{\theta}^*}$的雅可比矩阵,导致无法将方程化简为(43)的形式。

**数学意义:** stop_gradient的引入避免了对JVP求梯度,使得最优性条件能够化简为微分方程形式。

### 6. 与相关工作的联系

#### 6.1 与中值定理方法的关系

**中值定理方法** ([《生成扩散模型漫谈(二十一)》](/archives/9881)) 的核心思想:

根据积分中值定理,存在$s \in [r,t]$使得:
$$\frac{1}{t-r}\int_r^t \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_{\tau},\tau) d\tau = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_s, s) \tag{48}$$

**策略:** 寻找最优的$s$来近似平均速度。

**与MeanFlow的区别:**
- 中值定理: 寻找特殊点$s$,仍是求解器思想
- MeanFlow: 直接建模平均速度,训练时学习

#### 6.2 与Shortcut模型的关系

**Shortcut模型** ([《生成扩散模型漫谈(二十七)》](/archives/10617)) 将步长作为条件输入。

**平均速度的性质:** 应该满足
$$\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) = \frac{1}{2}\left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, s, t) + \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_s, r, s)\right] \tag{49}$$

其中$s = (r+t)/2$。

**Shortcut的正则化损失:**
$$\mathcal{L}_{\text{reg}} = \left\|\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, r, t) - \frac{1}{2}\text{sg}\left[\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, s, t) + \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_s, r, s)\right]\right\|^2 \tag{50}$$

混合ReFlow目标训练。

**与MeanFlow的区别:**
- Shortcut: 直观但缺乏理论保证,像经验性探索
- MeanFlow: 通过恒等变换有严格理论支撑

#### 6.3 与Consistency Model的关系

**连续一致性模型(sCM)** 的目标函数:
$$\mathcal{L}_{\text{sCM}} = \boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) \cdot \frac{d}{dt}\boldsymbol{f}_{\text{sg}[\boldsymbol{\theta}]}(\boldsymbol{x}_t, t) \tag{51}$$

其中$\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$是一致性函数。

**变换关系:** 令
$$\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) = \boldsymbol{x}_t - t\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) \tag{52}$$

**梯度等价性推导:**

对$\mathcal{L}_{\text{sCM}}$求梯度:
$$\nabla_{\boldsymbol{\theta}}\mathcal{L}_{\text{sCM}} = \nabla_{\boldsymbol{\theta}}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) \cdot \left[\frac{d\boldsymbol{x}_t}{dt}\cdot\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) + \frac{\partial}{\partial t}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)\right] \tag{53}$$

代入(52):
$$\nabla_{\boldsymbol{\theta}}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) = -t\nabla_{\boldsymbol{\theta}}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) \tag{54}$$

$$\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) = \boldsymbol{I} - t\frac{\partial}{\partial \boldsymbol{x}_t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) \tag{55}$$

$$\frac{\partial}{\partial t}\boldsymbol{f}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t) = -\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) - t\frac{\partial}{\partial t}\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, 0, t) \tag{56}$$

经过代数化简(详细过程略),可以证明:
$$\nabla_{\boldsymbol{\theta}}\mathcal{L}_{\text{sCM}} \propto \nabla_{\boldsymbol{\theta}}\mathcal{L}_3|_{r=0} \tag{57}$$

**结论:** sCM是MeanFlow在$r=0$时的特例。

**MeanFlow的优势:**
1. 引入$r$参数,当$r=t$时退化为ReFlow,提供"兜底"保证
2. 物理意义更清晰(平均速度 vs 一致性)
3. 可以得到不依赖stop_gradient的第一、第二目标

### 7. 实现细节与技术要点

#### 7.1 采样算法

**单步生成:**
$$\boldsymbol{x}_0 = \boldsymbol{x}_1 - \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_1, 0, 1) \tag{58}$$

**多步生成** (NFE=N):

将$[0,1]$划分为$0=t_0 < t_1 < \cdots < t_N = 1$

从$\boldsymbol{x}_N \sim \mathcal{N}(\boldsymbol{0}, \boldsymbol{I})$开始:
$$\boldsymbol{x}_{i-1} = \boldsymbol{x}_i - (t_i - t_{i-1})\boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_i, t_{i-1}, t_i), \quad i=N,N-1,\ldots,1 \tag{59}$$

**理论优势:** 多步时是对ODE积分的更精确近似,可以提升质量。

#### 7.2 训练算法伪代码

**输入:** 数据集$\{\boldsymbol{x}_0^{(i)}\}_{i=1}^M$

**输出:** 训练好的$\boldsymbol{u}_{\boldsymbol{\theta}}$

```
for epoch = 1 to max_epochs:
    for batch in data_loader:
        # 采样数据点
        x0 = batch  # 真实数据

        # 采样噪声
        x1 ~ N(0, I)

        # 采样时间参数
        t ~ Uniform(0, 1)
        r ~ Uniform(0, t)  # 或固定 r=0

        # 构建插值
        xt = (1-t)*x0 + t*x1

        # 目标速度
        target = x1 - x0

        # 计算预测(根据选择的目标)
        if using_loss_1:
            u_rt = u_theta(xt, r, t)
            u_tt = u_theta(xt, t, t)
            jvp = compute_jvp(u_rt, (xt,r,t), (u_tt,0,1))
            pred = u_rt + (t-r)*jvp
        elif using_loss_2:
            u_rt = u_theta(xt, r, t)
            u_tt = u_theta(xt, t, t)
            jvp = compute_jvp(u_rt, (xt,r,t), (u_tt,0,1))
            pred = u_rt + (t-r)*stop_gradient(jvp)
        elif using_loss_3:
            u_rt = u_theta(xt, r, t)
            jvp = compute_jvp(u_rt, (xt,r,t), (target,0,1))
            pred = u_rt + (t-r)*stop_gradient(jvp)

        # 计算损失
        loss = ||pred - target||^2

        # 反向传播
        optimizer.step(loss)
```

#### 7.3 JVP的实现

**PyTorch示例:**
```python
def compute_jvp(func, inputs, tangents):
    # func: 要计算JVP的函数
    # inputs: 输入点 (xt, r, t)
    # tangents: 切向量 (v_xt, v_r, v_t)

    outputs, jvp_out = torch.autograd.functional.jvp(
        func, inputs, tangents
    )
    return outputs, jvp_out
```

**JAX示例:**
```python
def compute_jvp(func, inputs, tangents):
    primals_out, tangents_out = jax.jvp(
        func, inputs, tangents
    )
    return primals_out, tangents_out
```

### 8. 理论深度分析

#### 8.1 为什么平均速度更适合大步长?

**瞬时速度的局限性:**

ODE $\frac{d\boldsymbol{x}_t}{dt} = \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)$ 描述的是**局部**性质,只在$\Delta t \to 0$时精确。

欧拉法离散化:
$$\boldsymbol{x}_{t-\Delta t} \approx \boldsymbol{x}_t - \boldsymbol{v}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t)\Delta t \tag{60}$$

**局部截断误差:** $O(\Delta t^2)$

**全局累积误差:** $O(\Delta t)$

当$\Delta t$大时,误差不可接受。

**平均速度的优势:**

平均速度直接建模**全局**性质:
$$\boldsymbol{x}_{t-\Delta t} = \boldsymbol{x}_t - \Delta t \cdot \boldsymbol{u}_{\boldsymbol{\theta}}(\boldsymbol{x}_t, t-\Delta t, t) \tag{61}$$

理论上,当模型完美学习时,这是**精确**的,无近似误差!

**类比:**
- 瞬时速度: 用切线近似曲线
- 平均速度: 直接学习曲线的弦

#### 8.2 双时间参数的意义

**为什么需要$r$和$t$两个参数?**

1. **灵活性:** 可以建模任意时间区间$[r,t]$的平均速度
2. **ReFlow兜底:** 当$r=t$时,退化为瞬时速度,即ReFlow
3. **渐进学习:** 可以先学小区间,再泛化到大区间

**训练策略:**

可以设计课程学习:
- 早期训练: $r$和$t$接近,学习局部性质
- 后期训练: $r$和$t$相差大,学习全局性质

#### 8.3 理论局限性分析

**stop_gradient的理论地位:**

第三目标中的stop_gradient:
- 数学上: 改变了优化目标的性质
- 优化上: 使最优点变为驻点而非极小值点
- 实践上: 依赖优化器动力学

**开放问题:**
1. 能否找到不依赖stop_gradient的全局性建模方法?
2. stop_gradient的稳定性如何理论保证?
3. 不同优化器对结果的影响?

### 9. 实验观察与实践建议

#### 9.1 三个目标的对比

**第一目标($\mathcal{L}_1$):**
- 优点: 理论最清晰,无stop_gradient
- 缺点: 计算量最大(二阶梯度)
- 适用: 理论研究,小规模实验

**第二目标($\mathcal{L}_2$):**
- 优点: 平衡理论与效率
- 缺点: 仍需两次前向传播
- 适用: 高质量生成任务

**第三目标($\mathcal{L}_3$):**
- 优点: 最快,工程实践友好
- 缺点: 理论上有"神秘感"
- 适用: 大规模生产应用

#### 9.2 超参数设置建议

**时间采样:**
- $t \sim \text{Uniform}(0, 1)$: 简单有效
- $t \sim \text{Beta}(\alpha, \beta)$: 可以调整难度分布

**$r$的选择:**
- $r = 0$: 类似sCM,理论保证强
- $r \sim \text{Uniform}(0, t)$: 更灵活,学习全局

**学习率:**
- 建议使用warmup
- AdamW优化器效果较好

### 10. 总结与展望

#### 10.1 核心贡献

MeanFlow的核心贡献可以总结为:

1. **概念创新:** 从瞬时速度转向平均速度,突破ODE的$\Delta t \to 0$限制
2. **理论严格:** 通过恒等变换和ReFlow理论,提供了严格的数学基础
3. **多个目标:** 提供了三个训练目标,平衡理论纯粹性与计算效率
4. **统一框架:** 将sCM、Shortcut等方法统一到平均速度框架下

#### 10.2 理论意义

**对扩散模型的理解:**
- 生成过程不必局限于无限小步长
- 全局性质可以直接建模
- 理论保证与实践效率可以兼顾

**对未来研究的启示:**
- 寻找更多的全局性质进行建模
- 探索stop_gradient的替代方案
- 发展更精细的理论分析工具

#### 10.3 开放问题

1. **最优时间离散化:** 多步生成时,如何选择最优的时间点?
2. **高阶平均速度:** 能否引入加速度等高阶概念?
3. **条件生成:** 如何将平均速度扩展到条件生成?
4. **离散数据:** 能否应用到文本等离散模态?

#### 10.4 实践展望

MeanFlow为扩散模型的快速生成开辟了新路径:
- **一步生成:** 理论上可以达到与多步生成相当的质量
- **可扩展性:** 可以通过增加步数提升效果
- **训练简单:** 单一目标,无对抗训练
- **理论清晰:** 便于进一步改进和扩展

**未来方向:**
1. 结合其他加速技术(蒸馏、剪枝等)
2. 应用到视频、3D等高维数据
3. 与其他生成模型(VAE、GAN)结合
4. 开发更高效的网络架构

---

**参考文献:**
- MeanFlow原论文: [Mean Flows for One-step Generative Modeling](https://papers.cool/arxiv/2505.13447)
- ReFlow: [Flow Straight and Fast: Learning to Generate and Transfer Data with Rectified Flow](https://papers.cool/arxiv/2209.03003)
- sCM: [Simplifying, Stabilizing and Scaling Continuous-Time Consistency Models](https://papers.cool/arxiv/2410.11081)

