<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAN：借助先验分布提升分类性能的简单后处理技巧</title>
    <style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    line-height: 1.6; color: #333; max-width: 900px; margin: 0 auto; padding: 20px; background: #f5f5f5;
}
.container { background: white; padding: 40px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
header { border-bottom: 2px solid #e0e0e0; padding-bottom: 20px; margin-bottom: 30px; }
h1 { color: #2c3e50; margin-bottom: 10px; font-size: 2em; }
.meta { color: #666; font-size: 0.9em; margin-bottom: 20px; }
.content { margin-top: 30px; overflow-wrap: break-word; }
.content h2 { color: #34495e; margin-top: 30px; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
.content p { margin-bottom: 15px; }
.content pre { background: #f8f8f8; padding: 15px; border-radius: 5px; overflow-x: auto; border-left: 3px solid #3498db; margin: 15px 0; }
.content code { background: #f8f8f8; padding: 2px 5px; border-radius: 3px; font-family: monospace; font-size: 0.9em; }
.content blockquote { border-left: 4px solid #3498db; padding-left: 20px; margin: 20px 0; color: #555; font-style: italic; }
.content table { border-collapse: collapse; width: 100%; margin: 20px 0; }
.content th, .content td { border: 1px solid #ddd; padding: 10px; text-align: left; }
.back-link { display: inline-block; margin-bottom: 20px; color: #3498db; text-decoration: none; font-weight: 500; }
</style>
    
<script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\(', '\)']],
            displayMath: [['$$', '$$'], ['\[', '\]']],
            processEscapes: true
        }
    };
</script>
<script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">← 返回首页</a>
        <header>
            <h1>CAN：借助先验分布提升分类性能的简单后处理技巧</h1>
            <div class="meta">📅 最后更新: 2025-11-26 | 📄 大小: 34.0 KB</div>
        </header>
        <div class="content">
            <p><strong>原文链接</strong>: <a href="https://spaces.ac.cn/archives/8728">https://spaces.ac.cn/archives/8728</a></p>
<p><strong>发布日期</strong>: </p>
<hr />
<p>顾名思义，本文将会介绍一种用于分类问题的后处理技巧——CAN（Classification with Alternating Normalization），出自论文<a href="https://papers.cool/arxiv/2109.13449">《When in Doubt: Improving Classification Performance with Alternating Normalization》</a>。经过笔者的实测，CAN确实多数情况下能提升多分类问题的效果，而且几乎没有增加预测成本，因为它仅仅是对预测结果的简单重新归一化操作。</p>
<p>有趣的是，其实CAN的思想是非常朴素的，朴素到每个人在生活中都应该用过同样的思想。然而，CAN的论文却没有很好地说清楚这个思想，只是纯粹形式化地介绍和实验这个方法。本文的分享中，将会尽量将算法思想介绍清楚。</p>
<h2 id="_1">思想例子</h2>
<p>假设有一个二分类问题，模型对于输入$a$给出的预测结果是$p^{(a)} = [0.05, 0.95]$，那么我们就可以给出预测类别为$1$；接下来，对于输入$b$，模型给出的预测结果是$p^{(b)}=[0.5,0.5]$，这时候处于最不确定的状态，我们也不知道输出哪个类别好。</p>
<p>但是，假如我告诉你：1、类别必然是0或1其中之一；2、两个类别的出现概率各为0.5。在这两点先验信息之下，由于前一个样本预测结果为1，那么基于朴素的均匀思想，我们是否更倾向于将后一个样本预测为0，以得到一个满足第二点先验的预测结果？</p>
<p>这样的例子还有很多，比如做10道选择题，前9道你都比较有信心，第10题完全不会只能瞎蒙，然后你一看发现前9题选A、B、C的都有就是没有一个选D的，那么第10题在蒙的时候你会不会更倾向于选D？</p>
<p>这些简单例子的背后，有着跟CAN同样的思想，它其实就是 <em>用先验分布来校正低置信度的预测结果，使得新的预测结果的分布更接近先验分布。</em></p>
<h2 id="_2">不确定性</h2>
<p>准确来说， <em>CAN是针对低置信度预测结果的后处理手段</em> ，所以我们首先要有一个衡量预测结果不确定性的指标。常见的度量是“熵”（参考<a href="/archives/3534">《“熵”不起：从熵、最大熵原理到最大熵模型（一）》</a>），对于$p=[p_1,p_2,\cdots,p_m]$，定义为：<br />
\begin{equation}H(p) = -\sum_{i=1}^m p_i\log p_i\end{equation}<br />
然而，虽然熵是一个常见选择，但其实它得出的结果并不总是符合我们的直观理解。比如对于$p^{(a)}=[0.5,0.25,0.25]$和$p^{(b)}=[0.5,0.5,0]$，直接套用公式得到$H(p^{(a)}) &gt; H(p^{(b)})$，但就我们的分类场景而言，显然我们会认为$p^{(b)}$比$p^{(a)}$更不确定，所以直接用熵还不够合理。</p>
<p>一个简单的修正是只用前top-$k$个概率值来算熵，不失一般性，假设$p_1,p_2,\cdots,p_k$是概率最高的$k$个值，那么<br />
\begin{equation}H_{\text{top-}k}(p) = -\sum_{i=1}^k \tilde{p}<em i="1">i\log \tilde{p}_i\end{equation}<br />
其中$\tilde{p}_i=p_i\Big/ \sum\limits</em>(p)/\log k$为最终的不确定性指标。}^k p_i$。为了得到一个0～1范围内的结果，我们取$H_{\text{top-}k</p>
<h2 id="_3">算法步骤</h2>
<p>现在假设我们有$N$个样本需要预测类别，模型直接的预测结果是$N$个概率分布$p^{(1)},p^{(2)},\cdots,p^{(N)}$，假设测试样本和训练样本是同分布的，那么完美的预测结果应该有：<br />
\begin{equation}\frac{1}{N}\sum_{i=1}^N p^{(i)} = \tilde{p}\label{eq:prior}\end{equation}<br />
其中$\tilde{p}$是类别的先验分布，我们可以直接从训练集估计。也就是说，全体预测结果应该跟先验分布是一致的，但受限于模型性能等原因，实际的预测结果可能明显偏离上式，这时候我们就可以人为修正这部分。</p>
<p>具体来说，我们选定一个阈值$\tau$，将指标小于$\tau$的预测结果视为高置信度的，而大于等于$\tau$的则是低置信度的，不失一般性，我们假设前$n$个结果$p^{(1)},p^{(2)},\cdots,p^{(n)}$属于高置信度的，而剩下的$N-n$个属于低置信度的。我们认为高置信度部分是更加可靠的，所以它们不用修正，并且可以用它们来作为“标准参考系”来修正低置信度部分。</p>
<p>具体来说，对于$\forall j\in\{n+1,n+2,\cdots,N\}$，我们将$p^{(j)}$与高置信度的$p^{(1)},p^{(2)},\cdots,p^{(n)}$一起，执行一次<strong>“行间”标准化</strong> ：<br />
\begin{equation}p^{(k)} \leftarrow p^{(k)}\big/\bar{p}\times\tilde{p},\quad\bar{p}=\frac{1}{n+1}\left(p^{(j)} + \sum_{i=1}^n p^{(i)}\right)\label{eq:step-1}\end{equation}<br />
这里的$k\in\{1,2,\cdots,n\}\cup\{j\}$，其中乘除法都是element-wise的。不难发现，这个标准化的目的是使得所有新的$p^{(k)}$的平均向量等于先验分布$\tilde{p}$，也就是促使式$\eqref{eq:prior}$的成立。然而，这样标准化之后，每个$p^{(k)}$就未必满足归一化了，所以我们还要执行一次<strong>“行内”标准化</strong> ：<br />
\begin{equation}p^{(k)} \leftarrow \frac{p^{(k)}<em i="1">i}{\sum\limits</em>}^m p^{(k)}_i}\label{eq:step-2}\end{equation<br />
但这样一来，式$\eqref{eq:prior}$可能又不成立了。所以理论上我们可以交替迭代执行这两步，直到结果收敛（不过实验结果显示一般情况下一次的效果是最好的）。最后，我们只保留最新的$p^{(j)}$作为原来第$j$个样本的预测结果，其余的$p^{(k)}$均弃之不用。</p>
<p>注意，这个过程需要我们遍历每个低置信度结果$j\in\{n+1,n+2,\cdots,N\}$执行，也就是说是 <em>逐个样本进行修正</em> ，而不是一次性修正的，每个$p^{(j)}$都借助<strong>原始的</strong> 高置信度结果$p^{(1)},p^{(2)},\cdots,p^{(n)}$组合来按照上述步骤迭代，虽然迭代过程中对应的$p^{(1)},p^{(2)},\cdots,p^{(n)}$都会随之更新，但那只是临时结果，最后都是弃之不用的，每次修正都是用原始的$p^{(1)},p^{(2)},\cdots,p^{(n)}$。</p>
<h2 id="_4">参考实现</h2>
<p>这是笔者给出的参考实现代码：</p>
<div class="codehilite"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="n">预测结果</span><span class="err">，</span><span class="n">计算修正前准确率</span>
<span class="n">y_pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span>
<span class="w">    </span><span class="n">valid_generator</span><span class="p">.</span><span class="n">fortest</span><span class="p">(),</span><span class="w"> </span><span class="n">steps</span><span class="o">=</span><span class="nf">len</span><span class="p">(</span><span class="n">valid_generator</span><span class="p">),</span><span class="w"> </span><span class="n">verbose</span><span class="o">=</span><span class="k">True</span>
<span class="p">)</span>
<span class="n">y_true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">array</span><span class="p">(</span><span class="o">[</span><span class="n">d[1</span><span class="o">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">valid_data</span><span class="err">]</span><span class="p">)</span>
<span class="n">acc_original</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="o">[</span><span class="n">y_pred.argmax(1) == y_true</span><span class="o">]</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;original acc: %s&#39;</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">acc_original</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="n">评价每个预测结果的不确定性</span>
<span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="n">y_pred_topk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">[</span><span class="n">:, -k:</span><span class="o">]</span>
<span class="n">y_pred_topk</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">y_pred_topk</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">keepdims</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="n">y_pred_uncertainty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">y_pred_topk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">y_pred_topk</span><span class="p">)).</span><span class="nf">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="n">选择阈值</span><span class="err">，</span><span class="n">划分高</span><span class="err">、</span><span class="n">低置信度两部分</span>
<span class="n">threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.9</span>
<span class="n">y_pred_confident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y_pred</span><span class="o">[</span><span class="n">y_pred_uncertainty &lt; threshold</span><span class="o">]</span>
<span class="n">y_pred_unconfident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y_pred</span><span class="o">[</span><span class="n">y_pred_uncertainty &gt;= threshold</span><span class="o">]</span>
<span class="n">y_true_confident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y_true</span><span class="o">[</span><span class="n">y_pred_uncertainty &lt; threshold</span><span class="o">]</span>
<span class="n">y_true_unconfident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y_true</span><span class="o">[</span><span class="n">y_pred_uncertainty &gt;= threshold</span><span class="o">]</span>

<span class="err">#</span><span class="w"> </span><span class="n">显示两部分各自的准确率</span>
<span class="err">#</span><span class="w"> </span><span class="n">一般而言</span><span class="err">，</span><span class="n">高置信度集准确率会远高于低置信度的</span>
<span class="n">acc_confident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">y_pred_confident</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y_true_confident</span><span class="p">).</span><span class="n">mean</span><span class="p">()</span>
<span class="n">acc_unconfident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">y_pred_unconfident</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y_true_unconfident</span><span class="p">).</span><span class="n">mean</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;confident acc: %s&#39;</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">acc_confident</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;unconfident acc: %s&#39;</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">acc_unconfident</span><span class="p">)</span>

<span class="err">#</span><span class="w"> </span><span class="n">从训练集统计先验分布</span>
<span class="k">prior</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_classes</span><span class="p">)</span>
<span class="k">for</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">train_data</span><span class="p">:</span>
<span class="w">    </span><span class="k">prior</span><span class="o">[</span><span class="n">d[1</span><span class="o">]</span><span class="err">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1.</span>

<span class="k">prior</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="k">prior</span><span class="p">.</span><span class="nf">sum</span><span class="p">()</span>

<span class="err">#</span><span class="w"> </span><span class="n">逐个修改低置信度样本</span><span class="err">，</span><span class="n">并重新评价准确率</span>
<span class="nf">right</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">iters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">enumerate</span><span class="p">(</span><span class="n">y_pred_unconfident</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">(</span><span class="o">[</span><span class="n">y_pred_confident, y[None</span><span class="o">]</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">iters</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Y</span><span class="o">**</span><span class="n">alpha</span>
<span class="w">        </span><span class="n">Y</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">Y</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">keepdims</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="w">        </span><span class="n">Y</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="k">prior</span><span class="o">[</span><span class="n">None</span><span class="o">]</span>
<span class="w">        </span><span class="n">Y</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">Y</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">keepdims</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Y</span><span class="o">[</span><span class="n">-1</span><span class="o">]</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">argmax</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y_true_unconfident</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="err">:</span>
<span class="w">        </span><span class="nf">right</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>

<span class="err">#</span><span class="w"> </span><span class="n">输出修正后的准确率</span>
<span class="n">acc_final</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">acc_confident</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">y_pred_confident</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">right</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nf">len</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;new unconfident acc: %s&#39;</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="nf">right</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;final acc: %s&#39;</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">acc_final</span><span class="p">)</span>
</code></pre></div>

<h2 id="_5">实验结果</h2>
<p>那么，这样的简单后处理，究竟能带来多大的提升呢？原论文给出的实验结果是相当可观的：  </p>
<p><a href="/usr/uploads/2021/10/3322086689.png" title="点击查看原图"><img alt="原论文的实验结果之一" src="/usr/uploads/2021/10/3322086689.png" /></a></p>
<p>原论文的实验结果之一</p>
<p>笔者也在CLUE上的两个中文文本分类任务上做了实验，显示基本也有点提升，但没那么可观（验证集结果）：<br />
\begin{array}{c|c|c}<br />
\hline<br />
&amp; \text{IFLYTEK(类别数:119)} &amp; \text{TNEWS(类别数:15)}\\\<br />
\hline<br />
\text{BERT} &amp; 60.06\% &amp; 56.80\% \\\<br />
\text{BERT + CAN} &amp; 60.52\% &amp; 56.86\% \\\<br />
\hline<br />
\text{RoBERTa} &amp; 60.64\% &amp; 58.06\% \\\<br />
\text{RoBERTa + CAN} &amp; 60.95\% &amp; 58.00\% \\\<br />
\hline<br />
\end{array}</p>
<p>大体上来说，类别数目越多，效果提升越明显，如果类别数目比较少，那么可能提升比较微弱甚至会下降（当然就算下降也是微弱的），所以这算是一个“几乎免费的午餐”了。超参数选择方面，上面给出的中文结果，只迭代了1次，$k$的选择为3、$\tau$的选择为0.9，经过简单的调试，发现这基本上已经是比较优的参数组合了。</p>
<p>还有的读者可能想问前面说的“高置信度那部分结果更可靠”这个情况是否真的成立？至少在笔者的两个中文实验上它是明显成立的，比如IFLYTEK任务，筛选出来的高置信度集准确率为0.63+，而低置信度集的准确率只有0.22+；TNEWS任务类似，高置信度集准确率为0.58+，而低置信度集的准确率只有0.23+。</p>
<h2 id="_6">个人评价</h2>
<p>最后再来综合地思考和评价一下CAN。</p>
<p>首先，一个很自然的疑问是为什么不直接将所有低置信度结果跟高置信度结果拼在一起进行修正，而是要逐个进行修正？笔者不知道原论文作者有没有对比过，但笔者确实实验过这个想法，结果是批量修正有时跟逐个修正持平，但有时也会下降。其实也可以理解，CAN本意应该是借助先验分布，结合高置信度结果来修正低置信度的，在这个过程中，如果掺入越多的低置信度结果，那么最终的偏差可能就越大，因此理论上逐个修正会比批量修正更为可靠。</p>
<p>说到原论文，读过CAN论文的读者，应该能发现本文介绍与CAN原论文大致有三点不同：</p>
<p>1、不确定性指标的计算方法不同。按照原论文的描述，它最终的不确定性指标计算方式应该是<br />
\begin{equation}-\frac{1}{\log m}\sum_{i=1}^k p_i\log p_i\end{equation}<br />
也就是说，它也是top-$k$个概率算熵的形式，但是它没有对这$k$个概率值重新归一化，并且它将其压缩到0～1之间的因子是$\log m$而不是$\log k$（因为它没有重新归一化，所以只有除$\log m$才能保证0～1之间）。经过笔者测试，原论文的这种方式计算出来的结果通常明显小于1，这不利于我们对阈值的感知和调试。</p>
<p>2、对CAN的介绍方式不同。原论文是纯粹数学化、矩阵化地陈述CAN的算法步骤，而且没有介绍算法的思想来源，这对理解CAN是相当不友好的。如果读者没有自行深入思考算法原理，是很难理解为什么这样的后处理手段就能提升分类效果的，而在彻底弄懂之后则会有一种故弄玄虚之感。</p>
<p>3、CAN的算法流程略有不同。原论文在迭代过程中还引入了参数$\alpha$，使得式$\eqref{eq:step-1}$变为<br />
\begin{equation}p^{(k)} \leftarrow [p^{(k)}]^{\alpha}\big/\bar{p}\times\tilde{p},\quad\bar{p}=\frac{1}{n+1}\left([p^{(j)}]^{\alpha} + \sum_{i=1}^n [p^{(i)}]^{\alpha}\right)\end{equation}<br />
也就是对每个结果进行$\alpha$次方后再迭代。当然，原论文也没有对此进行解释，而在笔者看来，该参数纯粹是为了调参而引入的（参数多了，总能把效果调到有所提升），没有太多实际意义。而且笔者自己在实验中发现，$\alpha=1$基本已经是最优选择了，精调$\alpha$也很难获得是实质收益。</p>
<h2 id="_7">文章小结</h2>
<p>本文介绍了一种名为CAN的简单后处理技巧，它借助先验分布来将预测结果重新归一化，几乎没有增加多少计算成本就能提高分类性能。经过笔者的实验，CAN确实能给分类效果带来一定提升，并且通常来说类别数越多，效果越明显。</p>
<p><em><strong>转载到请包括本文地址：</strong><a href="https://spaces.ac.cn/archives/8728">https://spaces.ac.cn/archives/8728</a></em></p>
<p><em><strong>更详细的转载事宜请参考：</strong></em><a href="https://spaces.ac.cn/archives/6508#%E6%96%87%E7%AB%A0%E5%A6%82%E4%BD%95%E8%BD%AC%E8%BD%BD/%E5%BC%95%E7%94%A8" title="《科学空间FAQ》">《科学空间FAQ》</a></p>
<p><strong>如果您还有什么疑惑或建议，欢迎在下方评论区继续讨论。</strong></p>
<p><strong>如果您觉得本文还不错，欢迎分享/打赏本文。打赏并非要从中获得收益，而是希望知道科学空间获得了多少读者的真心关注。当然，如果你无视它，也不会影响你的阅读。再次表示欢迎和感谢！</strong></p>
<p>打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/wx.png" /></p>
<p>微信打赏</p>
<p><img alt="科学空间" src="https://spaces.ac.cn/usr/themes/geekg/payment/zfb.png" /></p>
<p>支付宝打赏</p>
<p>因为网站后台对打赏并无记录，因此欢迎在打赏时候备注留言。你还可以<a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=tN7d1drY3drrx8H0xcWa19vZ"><strong>点击这里</strong></a>或在下方评论区留言来告知你的建议或需求。</p>
<p><strong>如果您需要引用本文，请参考：</strong></p>
<p>苏剑林. (Oct. 22, 2021). 《CAN：借助先验分布提升分类性能的简单后处理技巧 》[Blog post]. Retrieved from <a href="https://spaces.ac.cn/archives/8728">https://spaces.ac.cn/archives/8728</a></p>
<p>@online{kexuefm-8728,<br />
title={CAN：借助先验分布提升分类性能的简单后处理技巧},<br />
author={苏剑林},<br />
year={2021},<br />
month={Oct},<br />
url={\url{https://spaces.ac.cn/archives/8728}},<br />
} </p>
<hr />
<h2 id="_8">公式推导与注释</h2>
<h3 id="_9">一、贝叶斯框架下的分类问题</h3>
<h4 id="11">1.1 基本贝叶斯公式</h4>
<p><strong>标准分类目标</strong>：给定输入 $x$，我们希望预测其类别 $y \in {1, 2, \ldots, m}$。理想的分类器应该输出后验概率：</p>
<p>\begin{equation}
p(y|x) = \frac{p(x|y)p(y)}{p(x)} = \frac{p(x|y)p(y)}{\sum_{j=1}^m p(x|y=j)p(y=j)} \tag{1}
\end{equation}</p>
<p>其中：
- $p(y)$ 是类别的先验分布
- $p(x|y)$ 是类条件概率密度
- $p(x)$ 是边缘概率密度</p>
<p><strong>注释</strong>：这个公式是贝叶斯定理的直接应用，它告诉我们如何从似然 $p(x|y)$ 和先验 $p(y)$ 计算后验 $p(y|x)$。</p>
<h4 id="12">1.2 神经网络分类器的输出</h4>
<p><strong>实际情况</strong>：深度学习分类器通常不直接建模 $p(x|y)$，而是通过softmax输出一个概率分布：</p>
<p>\begin{equation}
\hat{p}(y|x) = \text{softmax}(f_\theta(x))<em>y = \frac{e^{f</em>\theta(x)<em j="1">y}}{\sum</em>
\end{equation}}^m e^{f_\theta(x)_j}} \tag{2</p>
<p>其中 $f_\theta(x) \in \mathbb{R}^m$ 是神经网络的logits输出。</p>
<p><strong>隐含假设</strong>：标准的交叉熵训练实际上隐含地假设：
1. 训练集的类别分布 $\tilde{p}(y)$ 等于真实的先验分布 $p(y)$
2. 模型完美地学习了后验概率</p>
<p><strong>注释</strong>：但在实际中，这两个假设往往都不成立。训练集可能是平衡采样的（人为均匀），而真实世界的类别分布可能高度不平衡。</p>
<h4 id="13">1.3 先验不匹配的影响</h4>
<p><strong>训练集先验</strong>：设训练时的类别分布为 $\tilde{p}(y)$。</p>
<p><strong>测试集先验</strong>：真实世界的类别分布为 $p(y)$。</p>
<p><strong>模型学到的后验</strong>：如果模型完美拟合训练分布，那么：</p>
<p>\begin{equation}
\hat{p}(y|x) \approx \frac{p(x|y)\tilde{p}(y)}{\sum_{j=1}^m p(x|y=j)\tilde{p}(y=j)} \tag{3}
\end{equation}</p>
<p><strong>真实后验</strong>：而我们真正需要的是：</p>
<p>\begin{equation}
p(y|x) = \frac{p(x|y)p(y)}{\sum_{j=1}^m p(x|y=j)p(y=j)} \tag{4}
\end{equation}</p>
<p><strong>修正公式</strong>：通过比较式(3)和式(4)，我们可以推导出修正关系：</p>
<p>\begin{equation}
p(y|x) = \frac{\hat{p}(y|x) \cdot \frac{p(y)}{\tilde{p}(y)}}{\sum_{j=1}^m \hat{p}(y=j|x) \cdot \frac{p(y=j)}{\tilde{p}(y=j)}} \tag{5}
\end{equation}</p>
<p><strong>注释</strong>：这个公式是后验校准的理论基础。它告诉我们，如果知道训练先验和测试先验，可以直接修正模型输出。</p>
<h3 id="_10">二、不确定性度量与熵</h3>
<h4 id="21">2.1 熵的定义与性质</h4>
<p><strong>Shannon熵</strong>：对于离散概率分布 $p = (p_1, \ldots, p_m)$，Shannon熵定义为：</p>
<p>\begin{equation}
H(p) = -\sum_{i=1}^m p_i \log p_i \tag{6}
\end{equation}</p>
<p><strong>基本性质</strong>：
1. <strong>非负性</strong>：$H(p) \geq 0$，当且仅当存在某个 $i$ 使得 $p_i = 1$ 时等号成立
2. <strong>最大性</strong>：在约束 $\sum_i p_i = 1$ 下，均匀分布 $p_i = 1/m$ 使得熵达到最大值 $H_{\max} = \log m$
3. <strong>凹性</strong>：$H$ 是关于 $p$ 的凹函数</p>
<p><strong>注释</strong>：熵度量了分布的"不确定性"或"混乱度"。熵越大，分布越"平坦"，预测越不确定。</p>
<h4 id="22">2.2 熵在分类中的问题</h4>
<p><strong>示例对比</strong>：考虑三分类问题，两个预测结果：
- $p^{(a)} = [0.5, 0.25, 0.25]$：最大概率是0.5，其余两个类别各0.25
- $p^{(b)} = [0.5, 0.5, 0]$：最大概率是0.5（并列），第三个类别概率为0</p>
<p><strong>熵的计算</strong>：</p>
<p>\begin{align}
H(p^{(a)}) &amp;= -0.5\log 0.5 - 0.25\log 0.25 - 0.25\log 0.25 \tag{7}\
&amp;= 0.5\cdot 0.693 + 2\cdot 0.25\cdot 1.386 = 1.040 \tag{8}\
H(p^{(b)}) &amp;= -0.5\log 0.5 - 0.5\log 0.5 - 0\log 0 = 0.693 \tag{9}
\end{align}</p>
<p><strong>直觉矛盾</strong>：按照熵的定义，$H(p^{(a)}) &gt; H(p^{(b)})$，似乎 $p^{(a)}$ 更不确定。但从分类任务的角度看：
- $p^{(a)}$ 有明确的最大值（0.5），预测类别1
- $p^{(b)}$ 有两个并列最大值，无法明确选择类别1还是类别2</p>
<p>因此 $p^{(b)}$ 实际上更不确定！</p>
<p><strong>注释</strong>：标准熵对所有类别一视同仁，但在分类任务中，我们更关心"谁是第一名"以及"第一名和第二名差距多大"。</p>
<h4 id="23-top-k">2.3 Top-K熵</h4>
<p><strong>定义</strong>：只考虑概率最大的 $k$ 个类别，并重新归一化后计算熵：</p>
<p>设 $p_{(1)} \geq p_{(2)} \geq \cdots \geq p_{(m)}$ 是概率值的降序排列，定义：</p>
<p>\begin{equation}
\tilde{p}<em _i_="(i)">i = \frac{p</em>
\end{equation}}}{\sum_{j=1}^k p_{(j)}}, \quad i = 1, \ldots, k \tag{10</p>
<p>\begin{equation}
H_{\text{top-}k}(p) = -\sum_{i=1}^k \tilde{p}_i \log \tilde{p}_i \tag{11}
\end{equation}</p>
<p><strong>归一化到[0,1]</strong>：</p>
<p>\begin{equation}
U_{\text{top-}k}(p) = \frac{H_{\text{top-}k}(p)}{\log k} \tag{12}
\end{equation}</p>
<p><strong>重新计算示例</strong>：以 $k=2$ 为例：</p>
<p>\begin{align}
p^{(a)}: &amp;\quad \tilde{p} = [\frac{0.5}{0.75}, \frac{0.25}{0.75}] = [0.667, 0.333] \tag{13}\
&amp;\quad U_{\text{top-2}}(p^{(a)}) = \frac{-0.667\log 0.667 - 0.333\log 0.333}{\log 2} = 0.637 \tag{14}\
p^{(b)}: &amp;\quad \tilde{p} = [\frac{0.5}{1.0}, \frac{0.5}{1.0}] = [0.5, 0.5] \tag{15}\
&amp;\quad U_{\text{top-2}}(p^{(b)}) = \frac{-0.5\log 0.5 - 0.5\log 0.5}{\log 2} = 1.0 \tag{16}
\end{align}</p>
<p><strong>注释</strong>：现在 $U_{\text{top-2}}(p^{(b)}) &gt; U_{\text{top-2}}(p^{(a)})$，与我们的直觉一致！$p^{(b)}$ 确实更不确定。</p>
<h3 id="can">三、CAN算法的数学原理</h3>
<h4 id="31">3.1 先验分布的估计</h4>
<p><strong>从训练集估计</strong>：设训练集 $\mathcal{D}<em i="1">{\text{train}} = {(x_i, y_i)}</em>^N$，先验分布估计为：</p>
<p>\begin{equation}
\tilde{p}(y = j) = \frac{\sum_{i=1}^N \mathbb{1}{y_i = j}}{N} = \frac{N_j}{N} \tag{17}
\end{equation}</p>
<p>其中 $N_j$ 是类别 $j$ 在训练集中出现的次数。</p>
<p><strong>拉普拉斯平滑</strong>（可选）：为避免零概率：</p>
<p>\begin{equation}
\tilde{p}(y = j) = \frac{N_j + \alpha}{N + m\alpha} \tag{18}
\end{equation}</p>
<p>通常取 $\alpha = 1$。</p>
<p><strong>注释</strong>：如果训练集是人为平衡的，则 $\tilde{p}(y) \approx [1/m, \ldots, 1/m]$ 均匀分布。</p>
<h4 id="32-row-wise-normalization">3.2 行间标准化（Row-wise Normalization）</h4>
<p><strong>动机</strong>：我们希望让一组预测结果的平均分布等于先验分布 $\tilde{p}(y)$。</p>
<p><strong>标准化步骤</strong>：给定一组预测 ${p^{(1)}, \ldots, p^{(n)}, p^{(j)}}$，计算平均：</p>
<p>\begin{equation}
\bar{p} = \frac{1}{n+1}\left(p^{(j)} + \sum_{i=1}^n p^{(i)}\right) \tag{19}
\end{equation}</p>
<p>然后对每个预测进行element-wise的缩放：</p>
<p>\begin{equation}
p^{(k)} \leftarrow p^{(k)} \odot \frac{\tilde{p}}{\bar{p}} \tag{20}
\end{equation}</p>
<p>其中 $\odot$ 表示element-wise乘法，$\frac{\tilde{p}}{\bar{p}}$ 也是element-wise除法。</p>
<p><strong>验证均值</strong>：缩放后，新的平均值为：</p>
<p>\begin{align}
\bar{p}<em k="k">{\text{new}} &amp;= \frac{1}{n+1}\sum</em>\
&amp;= \frac{1}{n+1}\left(\sum_{k} p^{(k)}\right) \odot \frac{\tilde{p}}{\bar{p}} = \bar{p} \odot \frac{\tilde{p}}{\bar{p}} = \tilde{p} \tag{22}
\end{align}} p^{(k)} \odot \frac{\tilde{p}}{\bar{p}} \tag{21</p>
<p><strong>注释</strong>：这个操作确保了新的平均分布等于先验分布，这正是我们想要的！</p>
<h4 id="33-column-wise-normalization">3.3 行内标准化（Column-wise Normalization）</h4>
<p><strong>问题</strong>：经过行间标准化后，每个 $p^{(k)}$ 不再满足归一化条件 $\sum_i p^{(k)}_i = 1$。</p>
<p><strong>修正</strong>：对每个预测重新归一化：</p>
<p>\begin{equation}
p^{(k)} \leftarrow \frac{p^{(k)}}{\sum_{i=1}^m p^{(k)}_i} \tag{23}
\end{equation}</p>
<p><strong>注释</strong>：这个操作恢复了概率分布的归一化性质，但也会破坏式(22)的性质。因此理论上需要交替迭代。</p>
<h4 id="34">3.4 交替标准化的收敛性</h4>
<p><strong>迭代算法</strong>：</p>
<p>\begin{equation}
\begin{aligned}
&amp;\text{For } t = 1, 2, \ldots, T:\
&amp;\quad \text{行间标准化: } p^{(k)} \leftarrow p^{(k)} \odot \frac{\tilde{p}}{\bar{p}}\
&amp;\quad \text{行内标准化: } p^{(k)} \leftarrow \frac{p^{(k)}}{\sum_i p^{(k)}_i}
\end{aligned} \tag{24}
\end{equation}</p>
<p><strong>收敛性质</strong>：这个交替投影算法类似于Sinkhorn算法，在一定条件下可以证明收敛到一个满足：
1. 每行归一化：$\sum_i p^{(k)}_i = 1$
2. 列平均等于先验：$\frac{1}{n+1}\sum_k p^{(k)}_i = \tilde{p}_i$</p>
<p>的不动点。</p>
<p><strong>实践中</strong>：论文发现 $T=1$ （只迭代一次）效果最好，过多迭代反而会降低性能。</p>
<p><strong>注释</strong>：这可能是因为模型输出本身存在误差，过度强制满足先验分布反而会引入额外偏差。</p>
<h3 id="can_1">四、CAN算法的信息论解释</h3>
<h4 id="41">4.1 互信息的角度</h4>
<p><strong>互信息</strong>：预测 $p(y|x)$ 和先验 $p(y)$ 之间的互信息定义为：</p>
<p>\begin{equation}
I(Y; X) = \sum_{x,y} p(x,y)\log\frac{p(y|x)}{p(y)} = H(Y) - H(Y|X) \tag{25}
\end{equation}</p>
<p>其中 $H(Y|X) = \mathbb{E}_{x}[H(p(y|x))]$ 是条件熵。</p>
<p><strong>CAN的作用</strong>：通过修正后验使其平均分布等于先验，相当于在保持条件熵 $H(Y|X)$ 基本不变的情况下，调整边缘熵 $H(Y)$ 使其与真实先验匹配。</p>
<p><strong>注释</strong>：这确保了模型不会因为训练集的类别不平衡而系统性地偏向某些类别。</p>
<h4 id="42-kl">4.2 KL散度的视角</h4>
<p><strong>目标</strong>：最小化修正后的预测分布与真实后验之间的KL散度：</p>
<p>\begin{equation}
\min_{p'} \mathbb{E}<em _text_KL="\text{KL">{x}\left[D</em>
\end{equation}}}(p_{\text{true}}(y|x) | p'(y|x))\right] \tag{26</p>
<p>在约束条件下：</p>
<p>\begin{equation}
\mathbb{E}_{x}[p'(y|x)] = \tilde{p}(y) \tag{27}
\end{equation}</p>
<p><strong>拉格朗日形式</strong>：</p>
<p>\begin{equation}
\mathcal{L} = \mathbb{E}<em _text_KL="\text{KL">{x}\left[D</em>
\end{equation}}}(p_{\text{true}}(y|x) | p'(y|x))\right] + \lambda \left|\mathbb{E}_{x}[p'(y|x)] - \tilde{p}(y)\right|^2 \tag{28</p>
<p><strong>注释</strong>：CAN可以看作是这个优化问题的一个近似解法，通过启发式的标准化步骤来逼近最优解。</p>
<h3 id="_11">五、高置信度与低置信度的分离</h3>
<h4 id="51">5.1 置信度阈值的选择</h4>
<p><strong>阈值选择</strong>：设定阈值 $\tau \in [0, 1]$，将样本分为两组：
- 高置信度：$U_{\text{top-}k}(p^{(i)}) &lt; \tau$
- 低置信度：$U_{\text{top-}k}(p^{(i)}) \geq \tau$</p>
<p><strong>经验准则</strong>：通常 $\tau \in [0.8, 0.95]$ 之间。$\tau$ 越小，高置信度集越小，越"精英化"。</p>
<p><strong>统计验证</strong>：计算两组的准确率：</p>
<p>\begin{equation}
\text{Acc}<em U_p_i_="U(p^{(i)" i:="i:">{\text{high}} = \frac{\sum</em>
\end{equation}}) &lt; \tau} \mathbb{1}{\arg\max p^{(i)} = y_i}}{\sum_{i} \mathbb{1}{U(p^{(i)}) &lt; \tau}} \tag{29</p>
<p>\begin{equation}
\text{Acc}<em U_p_i_="U(p^{(i)" i:="i:">{\text{low}} = \frac{\sum</em>
\end{equation}}) \geq \tau} \mathbb{1}{\arg\max p^{(i)} = y_i}}{\sum_{i} \mathbb{1}{U(p^{(i)}) \geq \tau}} \tag{30</p>
<p><strong>期望结果</strong>：应该有 $\text{Acc}<em _text_low="\text{low">{\text{high}} \gg \text{Acc}</em>$。}</p>
<p><strong>注释</strong>：如果这个不等式不成立，说明不确定性度量可能不合适，或者模型校准很差。</p>
<h4 id="52">5.2 逐个修正的原理</h4>
<p><strong>为什么不批量修正</strong>：如果将所有低置信度样本一起修正：</p>
<p>\begin{equation}
{p^{(1)}, \ldots, p^{(n)}, p^{(n+1)}, \ldots, p^{(N)}} \tag{31}
\end{equation}</p>
<p>其中前 $n$ 个是高置信度，后 $N-n$ 个是低置信度。</p>
<p><strong>问题</strong>：批量修正时，大量的低置信度样本会稀释高置信度样本的影响，导致平均分布 $\bar{p}$ 不准确。</p>
<p><strong>逐个修正的优势</strong>：对于每个低置信度样本 $p^{(j)}$，只与高置信度样本组合：</p>
<p>\begin{equation}
{p^{(1)}, \ldots, p^{(n)}, p^{(j)}} \tag{32}
\end{equation}</p>
<p>这样高置信度样本的"信号强度"更大，能更好地引导修正。</p>
<p><strong>注释</strong>：这是一个bias-variance权衡。批量修正variance小但bias可能大；逐个修正variance稍大但bias更小。</p>
<h3 id="alpha">六、超参数 $\alpha$ 的作用</h3>
<h4 id="61-alpha">6.1 $\alpha$ 的定义</h4>
<p>原论文引入了参数 $\alpha$，将行间标准化修改为：</p>
<p>\begin{equation}
p^{(k)} \leftarrow [p^{(k)}]^\alpha \odot \frac{\tilde{p}}{[\bar{p}]^\alpha} \tag{33}
\end{equation}</p>
<p>其中 $[\cdot]^\alpha$ 表示element-wise的幂运算。</p>
<h4 id="62-alpha">6.2 $\alpha$ 的效果分析</h4>
<p><strong>$\alpha &gt; 1$</strong>：增强差异，使得大概率更大，小概率更小
- $p = [0.7, 0.2, 0.1]$，$\alpha = 2$ 时：$p^\alpha = [0.49, 0.04, 0.01]$（归一化前）</p>
<p><strong>$\alpha &lt; 1$</strong>：减弱差异，使得分布更平坦
- $p = [0.7, 0.2, 0.1]$，$\alpha = 0.5$ 时：$p^\alpha = [0.837, 0.447, 0.316]$（归一化前）</p>
<p><strong>$\alpha = 1$</strong>：不改变，即本文前面推导的标准CAN</p>
<p><strong>温度的关系</strong>：这个操作类似于softmax中的温度参数 $T$：</p>
<p>\begin{equation}
\text{softmax}(z/T)_i = \frac{e^{z_i/T}}{\sum_j e^{z_j/T}} \tag{34}
\end{equation}</p>
<p>其中 $T &gt; 1$ 使分布平滑，$T &lt; 1$ 使分布尖锐。</p>
<p><strong>注释</strong>：原论文报告 $\alpha = 1$ 通常是最优选择，额外调参收益很小，这支持了我们的简化版本（不考虑 $\alpha$）。</p>
<h3 id="can_2">七、CAN的概率校准理论</h3>
<h4 id="71">7.1 模型校准的定义</h4>
<p><strong>完美校准</strong>：一个模型是完美校准的，如果对于所有 $p \in [0, 1]$：</p>
<p>\begin{equation}
\mathbb{P}(Y = y | \hat{p}(y|X) = p) = p \tag{35}
\end{equation}</p>
<p>即预测概率等于实际条件概率。</p>
<p><strong>期望校准误差（ECE）</strong>：</p>
<p>\begin{equation}
\text{ECE} = \sum_{k=1}^K \frac{|B_k|}{N} \left| \text{Acc}(B_k) - \text{Conf}(B_k) \right| \tag{36}
\end{equation}</p>
<p>其中：
- $B_k$ 是预测概率在区间 $[(k-1)/K, k/K)$ 内的样本
- $\text{Acc}(B_k)$ 是该bin内的准确率
- $\text{Conf}(B_k)$ 是该bin内的平均置信度</p>
<p><strong>注释</strong>：ECE越小，模型校准越好。完美校准时 ECE = 0。</p>
<h4 id="72-can">7.2 CAN对校准的影响</h4>
<p><strong>后验修正的效果</strong>：CAN通过式(5)的后验修正，理论上应该改善校准。</p>
<p><strong>实验验证</strong>：通过绘制可靠性图（Reliability Diagram）：
- x轴：预测置信度（binned）
- y轴：实际准确率</p>
<p>理想情况下应该是 $y = x$ 直线。</p>
<p><strong>CAN前后对比</strong>：
- CAN前：可能出现系统性偏差，如高估或低估
- CAN后：应该更接近 $y = x$ 直线</p>
<p><strong>注释</strong>：CAN不仅改善准确率，还能改善校准，这在需要置信度估计的应用（如主动学习、拒绝选项）中很重要。</p>
<h3 id="_12">八、理论上界与误差分析</h3>
<h4 id="81">8.1 修正误差的来源</h4>
<p><strong>误差分解</strong>：CAN的总误差可以分解为：</p>
<p>\begin{equation}
\epsilon_{\text{total}} = \epsilon_{\text{model}} + \epsilon_{\text{prior}} + \epsilon_{\text{CAN}} \tag{37}
\end{equation}</p>
<p>其中：
- $\epsilon_{\text{model}}$：模型本身的误差（未完美学习 $p(y|x)$）
- $\epsilon_{\text{prior}}$：先验估计误差（$\tilde{p}(y) \neq p(y)$）
- $\epsilon_{\text{CAN}}$：CAN算法的近似误差</p>
<p><strong>注释</strong>：只有当前两项足够小时，CAN才能发挥作用。如果模型本身很差，CAN也无济于事。</p>
<h4 id="82">8.2 先验估计的鲁棒性</h4>
<p><strong>敏感性分析</strong>：当先验估计有误差时：</p>
<p>\begin{equation}
\tilde{p}'(y) = \tilde{p}(y) + \delta(y), \quad \sum_y \delta(y) = 0 \tag{38}
\end{equation}</p>
<p>修正后的后验变为：</p>
<p>\begin{equation}
p'(y|x) \approx p(y|x) + \mathcal{O}(|\delta|) \tag{39}
\end{equation}</p>
<p><strong>注释</strong>：只要先验估计大致正确（$|\delta|$ 小），CAN就能带来改善。不需要精确知道真实先验。</p>
<h3 id="_13">九、多次迭代的理论分析</h3>
<h4 id="91-vs">9.1 单次 vs 多次迭代</h4>
<p><strong>单次迭代</strong> ($T=1$)：</p>
<p>\begin{equation}
p^{(j)}<em 0_i="0,i">1 = \frac{p^{(j)}_0 \odot \frac{\tilde{p}}{\bar{p}_0}}{\sum_i \left(p^{(j)}</em>} \cdot \frac{\tilde{p<em 0_i="0,i">i}{\bar{p}</em>
\end{equation}}}\right)} \tag{40</p>
<p><strong>两次迭代</strong> ($T=2$)：</p>
<p>先得到 $p^{(j)}_1$，然后计算新的 $\bar{p}_1$，再次修正：</p>
<p>\begin{equation}
p^{(j)}<em 1_i="1,i">2 = \frac{p^{(j)}_1 \odot \frac{\tilde{p}}{\bar{p}_1}}{\sum_i \left(p^{(j)}</em>} \cdot \frac{\tilde{p<em 1_i="1,i">i}{\bar{p}</em>
\end{equation}}}\right)} \tag{41</p>
<h4 id="92">9.2 过度迭代的风险</h4>
<p><strong>理论分析</strong>：每次迭代都会使得平均分布更接近 $\tilde{p}$，但同时也会：
1. 增加对先验估计误差的敏感性
2. 可能过度平滑，损失模型的原始信息</p>
<p><strong>实验观察</strong>：
- $T=1$：通常最优
- $T=2,3$：效果与 $T=1$ 接近或略差
- $T\geq 5$：效果开始明显下降</p>
<p><strong>注释</strong>：这是过拟合先验的表现。先验只是一个粗略的统计信息，不应过度依赖。</p>
<h3 id="_14">十、与其他校准方法的比较</h3>
<h4 id="101-temperature-scaling">10.1 温度缩放（Temperature Scaling）</h4>
<p><strong>方法</strong>：在softmax中引入温度参数 $T$：</p>
<p>\begin{equation}
p_T(y|x) = \frac{e^{z_y/T}}{\sum_j e^{z_j/T}} \tag{42}
\end{equation}</p>
<p>在验证集上优化 $T$ 以最小化负对数似然。</p>
<p><strong>优点</strong>：简单，只有一个参数
<strong>缺点</strong>：所有样本使用同一个 $T$，无法个性化调整</p>
<p><strong>与CAN的区别</strong>：CAN针对低置信度样本单独处理，更灵活。</p>
<h4 id="102-platt-scaling">10.2 Platt Scaling</h4>
<p><strong>方法</strong>：学习一个逻辑回归模型：</p>
<p>\begin{equation}
p_{\text{calib}}(y|x) = \sigma(az_y + b) \tag{43}
\end{equation}</p>
<p>其中 $a, b$ 在验证集上学习。</p>
<p><strong>优点</strong>：理论上可以修正任意单调误差
<strong>缺点</strong>：需要额外的训练；多分类需要one-vs-rest</p>
<p><strong>与CAN的区别</strong>：Platt Scaling需要训练，CAN是纯后处理，无需额外训练。</p>
<h4 id="103-isotonic-regression">10.3 Isotonic Regression</h4>
<p><strong>方法</strong>：学习一个单调的非参数映射 $f: [0,1] \to [0,1]$：</p>
<p>\begin{equation}
p_{\text{calib}}(y|x) = f(\hat{p}(y|x)) \tag{44}
\end{equation}</p>
<p>使得 $f$ 单调且最小化校准误差。</p>
<p><strong>优点</strong>：非常灵活，可以拟合任意单调关系
<strong>缺点</strong>：容易过拟合；需要大量验证数据</p>
<p><strong>与CAN的区别</strong>：Isotonic Regression是单变量校准，CAN考虑了类别之间的依赖（通过先验分布）。</p>
<h3 id="_15">十一、数值实验与案例分析</h3>
<h4 id="111">11.1 类别不平衡的案例</h4>
<p><strong>设定</strong>：
- 真实先验：$p(y) = [0.1, 0.3, 0.6]$（高度不平衡）
- 训练先验：$\tilde{p}(y) = [1/3, 1/3, 1/3]$（人为平衡）</p>
<p><strong>模型输出</strong>（未校准）：</p>
<p>\begin{equation}
\hat{p}(y|x) = [0.4, 0.35, 0.25] \tag{45}
\end{equation}</p>
<p>预测类别1（概率0.4）。</p>
<p><strong>CAN修正</strong>：</p>
<p>\begin{align}
p_{\text{CAN}}(y|x) &amp;\propto \hat{p}(y|x) \odot \frac{p(y)}{\tilde{p}(y)} \tag{46}\
&amp;\propto [0.4, 0.35, 0.25] \odot \frac{[0.1, 0.3, 0.6]}{[1/3, 1/3, 1/3]} \tag{47}\
&amp;\propto [0.4\times 0.3, 0.35\times 0.9, 0.25\times 1.8] \tag{48}\
&amp;= [0.12, 0.315, 0.45] \tag{49}
\end{align}</p>
<p>归一化后：$p_{\text{CAN}}(y|x) = [0.136, 0.358, 0.506]$</p>
<p><strong>预测变化</strong>：类别从1变为3！这反映了真实世界中类别3更常见的事实。</p>
<p><strong>注释</strong>：这个例子展示了CAN如何利用先验信息修正预测。</p>
<h4 id="112">11.2 高置信度样本的稳定性</h4>
<p><strong>高置信度样本</strong>：</p>
<p>\begin{equation}
p^{(h)} = [0.95, 0.03, 0.02], \quad U_{\text{top-2}}(p^{(h)}) = 0.23 &lt; 0.9 \tag{50}
\end{equation}</p>
<p><strong>CAN修正前后</strong>：由于 $p^{(h)}$ 是高置信度样本，不会被修正，保持不变。</p>
<p><strong>低置信度样本</strong>：</p>
<p>\begin{equation}
p^{(l)} = [0.45, 0.35, 0.20], \quad U_{\text{top-2}}(p^{(l)}) = 0.99 &gt; 0.9 \tag{51}
\end{equation}</p>
<p>会被修正。</p>
<p><strong>注释</strong>：CAN只对不确定的预测进行调整，保留了高置信度预测的原始信息。</p>
<h3 id="_16">十二、实现细节与优化</h3>
<h4 id="121">12.1 高效实现</h4>
<p><strong>向量化计算</strong>：使用NumPy/PyTorch的向量化操作，避免显式循环：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 高置信度样本</span>
<span class="n">p_conf</span> <span class="o">=</span> <span class="n">predictions</span><span class="p">[</span><span class="n">uncertainty</span> <span class="o">&lt;</span> <span class="n">tau</span><span class="p">]</span>  <span class="c1"># (n, m)</span>
<span class="c1"># 对于每个低置信度样本</span>
<span class="k">for</span> <span class="n">p_low</span> <span class="ow">in</span> <span class="n">predictions</span><span class="p">[</span><span class="n">uncertainty</span> <span class="o">&gt;=</span> <span class="n">tau</span><span class="p">]:</span>
    <span class="c1"># 拼接</span>
    <span class="n">p_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">p_conf</span><span class="p">,</span> <span class="n">p_low</span><span class="p">[</span><span class="kc">None</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># (n+1, m)</span>
    <span class="c1"># 行间标准化</span>
    <span class="n">p_mean</span> <span class="o">=</span> <span class="n">p_all</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># (m,)</span>
    <span class="n">p_all</span> <span class="o">=</span> <span class="n">p_all</span> <span class="o">*</span> <span class="p">(</span><span class="n">prior</span> <span class="o">/</span> <span class="n">p_mean</span><span class="p">)</span>  <span class="c1"># broadcasting</span>
    <span class="c1"># 行内标准化</span>
    <span class="n">p_all</span> <span class="o">=</span> <span class="n">p_all</span> <span class="o">/</span> <span class="n">p_all</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># 提取修正后的低置信度样本</span>
    <span class="n">p_low_new</span> <span class="o">=</span> <span class="n">p_all</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>

<p><strong>注释</strong>：这个实现的复杂度是 $O(N_{\text{low}} \times N_{\text{high}} \times m)$，对于大规模问题可能较慢。</p>
<h4 id="122">12.2 近似加速</h4>
<p><strong>随机采样高置信度样本</strong>：如果 $N_{\text{high}}$ 很大，可以随机采样一个子集：</p>
<p>\begin{equation}
\tilde{p}<em _in="\in" _mathcal_S="\mathcal{S" i="i">{\text{conf}} = {p^{(i)}}</em>
\end{equation}}} \tag{52</p>
<p>其中 $\mathcal{S}$ 是大小为 $n_{\text{sample}}$ 的随机子集（如 $n_{\text{sample}} = 1000$）。</p>
<p><strong>注释</strong>：实验表明，只要 $n_{\text{sample}}$ 足够大（$\geq 500$），近似效果与使用全部高置信度样本几乎相同。</p>
<h3 id="_17">十三、总结与展望</h3>
<p>本节详细推导了CAN算法的数学原理，核心内容包括：</p>
<ol>
<li><strong>贝叶斯框架</strong>：从贝叶斯公式出发，理解先验不匹配如何影响后验</li>
<li><strong>不确定性度量</strong>：改进的top-k熵更适合分类任务</li>
<li><strong>交替标准化</strong>：行间-行内标准化的迭代收敛</li>
<li><strong>逐个修正</strong>：避免低置信度样本的稀释效应</li>
<li><strong>校准理论</strong>：CAN改善模型的概率校准性</li>
<li><strong>数值分析</strong>：具体案例展示CAN的修正效果</li>
</ol>
<p>CAN作为一个简单的后处理方法，在几乎不增加计算成本的情况下，有效利用先验信息改善了分类性能和校准性。</p>
        </div>
    </div>
</body>
</html>